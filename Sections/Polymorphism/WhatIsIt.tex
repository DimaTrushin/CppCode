\ProvidesFile{WhatIsIt.tex}[Что это]


\subsection{Что это и каким оно бывает}

По определению полиморфизм означает, что один и тот же текст (=код) делает разные вещи.
Например в языке C++ можно написать строчку кода:
\begin{cppcode}
z = x + y;
\end{cppcode}
В зависимости от типа переменных \texttt{x}, \texttt{y} и \texttt{z} эта строчка будет вызывать разные процессорные инструкции даже для встроенных типов \texttt{int}, \texttt{double}, не говоря уже о перегруженных операторах для классов.
Потому технически, это пример полиморфного поведения кода.
Обычно про такие примеры не говорят, но и полиморфизм обычно определяют очень узко, привязывая его только к определенной имплементации или инструменту языка, а не к поведению.
На мой взгляд на языковые вещи надо смотреть не с точки зрения имплементации, а с точки зрения поведения.

Прежде чем двигаться дальше я хочу сделать полезное замечание.
Языки программирования по отношению к типам данных бывают трех типов:
\begin{itemize}
\item Статическая типизация.
Тип переменной не может измениться во время исполнения.

\item Динамическая типизация.
Тип переменной может поменяться во время исполнения.

\item Без типизации.
Понятия типа просто не существует.
\end{itemize}
Язык C++ относится к языкам со статической типизацией.
Чем мы выше в этом списке, тем надежнее механизмы языка, тем больше гарантий вам может теоретически предоставить компилятор и инструменты разработки.
Чем ниже в этом списке, тем более гибким является язык.
Это всегда размен надежности на гибкость.
Если в языке нет типизации или динамическая типизация, то все поведение полиморфно.
Возьмите для примера язык Python с динамической типизацией.
Если у вас есть функция вида
\begin{pythoncode}
def function(a):
  a.f()
\end{pythoncode}
То не важно какого типа аргумент \texttt{a} функции \texttt{function}.
Единственное что нужно для исполнения этого кода, чтобы для \texttt{a} имела смысл строчка вызова \texttt{a.f()} и все.
В эту функцию можно подставлять любой объект, у которого можно вызвать метод \texttt{f} без аргументов.
А потому про полиморфизм имеет смысл говорить только в языках со статической типизацией, где по определению вы не можете подставить вместо переменной одного типа переменную другого типа.
Точнее, в языках со статической типизацией возникает следующий вопрос: <<как добиться полиморфного поведения, не ломая систему типов?>>

\paragraph{Полиморфизм и функции}

Давайте для начала обсудим какие есть механизмы в C++ для полиморфизма.
\begin{enumerate}
\item Перегрузка функций, методов и операторов.
Да, это тоже полиморфизм и именно с этого примера я начал этот раздел.
\begin{cppcode}
void f(int);
void f(double);
void f(A);

int main() {
  int x = 1;
  f(x);
  double y = 2.;
  f(y);
  A a;
  f(a);
 return 0;
}
\end{cppcode}
Как вы видите, функция с именем \texttt{f} может быть вызвана для переменных разных типов.
То есть один и тот же код вида \texttt{f(...)} может выполнять разные действия.

Важно отметить, что в данном случае у нас есть полиморфзим на стороне пользователя функции \texttt{f}, но не на стороне автора функции \texttt{f}.
Действительно, перегрузка требует от вас определить все три вида функции, а потому вы обязаны написать все три имплементации и у вас нет возможности использовать один и тот же код для этого (я не говорю сейчас про баловство с макросами, потому что это в целом издевательство над текстом программы).
\begin{cppcode}
void f(int) {
  std::cout << "f(int);\n";
}
void f(double) {
  std::cout << "f(double);\n";
}
void f(A) {
  std::cout << "f(A);\n";
}
\end{cppcode}

\item Шаблоны функций, переменных и классов.
Этот вид полиморфизма обычно называют compile-time polymorphims.
Благодаря шаблонам вы можете добиться полиморфизма и на стороне пользователя кода и на стороне автора кода, то есть когда и пользователь и автор кода пишет один код, который делает разную работу.
\begin{cppcode}
template<class T>
void f(T);

int main() {
  int x = 1;
  f(x);
  double y = 2.;
  f(y);
  A a;
  f(a);
}
\end{cppcode}
В этом случае программист может написать следующую имплементацию
\begin{cppcode}
template<class T>
void f(T) {
  std::cout << "f(" << ClassPrintName<T> << ");\n";
}
\end{cppcode}
Здесь \texttt{ClassPrintName} -- это вспомогательный шаблон, который перерабатывает класс в читаемое имя класса в формате строки для отображения.
По сути шаблоны -- это умная кодогенерация, которая делается механизмами языка.

\item Run-time polynorphism.
Это вид полиморфизма относится к ситуации, когда вы хотите менять поведение кода во время исполнения, то есть что именно будет исполнено не определяется на этапе компиляции кода.
Например, когда вы хотите поменять поведение кода в зависимости от ввода пользователя или от возможностей железа, на котором исполняется программа.
Если вы думаете, что run-time polymorphism это сугубо фича объектно ориентированных языков программирования, то вы глубоко ошибаетесь.
Даже в языке Си можно добиться полиморфзного поведения во время исполнения и имплементация всех операционных систем использует этот механизм.
Для этого используются указатели на функции (код ниже содержит псевдонимы типов из C++ для удобства чтения кода)
\begin{cppcode}
void f1();
void f2();

using Signature = void();
using FPtr = Signature*;
FPtr f = &f1;

int main() {
  f(); // f1 executes
  f = &f2;
  f(); // f2 executes
  return 0;
}
\end{cppcode}
Обратите внимание, что в коде выше мы подменяем указатель на функцию и в зависимости от этого вызов \texttt{f()} приводит к выполнению разных функций.
\end{enumerate}

\paragraph{Полиморфизм и классы}

Теперь давайте обсудим, что означает полиморфизм на уровне классов, а не функций.
В этом случае есть две задачи:
\begin{enumerate}
\item Мы хотим ссылаться на переменные разных типов и уметь звать у них методы с фиксированными названиями.
Например:
\begin{cppcode}
struct A {
  void f() const;
};

struct B {
  void f() const;
};

void f(Pointer ptr) {
  ptr->f();
}

int main() {
  A a;
  f(&a);
  B b;
  f(&b);
}
\end{cppcode}
Здесь \texttt{Pointer} -- это какой-то пока какой-то нам неизвестно как устроенный класс, который играет роль указателя, но только в него можно положить указатель на любой класс, в котором есть метод \texttt{f}, который можно вызвать без аргументов.
Я не знаю, есть ли у этого подхода стандартное название, но я бы по аналогии со следующим пунктом назвал это <<стирающим указателем>>, потому что мы стираем информацию о типе объекта, на который указывает <<указатель>>, и все что нам доступно -- это вызов методов из поддерживаемого интерфейса стирающего указателя.

\item Мы хотим хранить в переменной объекты разных типов и обращаться к их методам по фиксированным названиям.
Например мы хотим написать что-то в таком духе
\begin{cppcode}
struct A {
  void f() const;
};

struct B {
  void f() const;
};

int main() {
  std::vector<Any> vec;
  vec.push_back(A());
  vec.back().f();
  vec.push_back(B());
  vec.back().f();
}
\end{cppcode}
В этом случае \texttt{Any} -- это тип, в который можно положить любую переменную любого типа, главное, чтобы в ее интерфейсе был метод \texttt{f}, который можно вызвать без аргументов.
Такой подход называется <<стирающим типом>> или по английски <<Type Erasure>>.
В этом случае тип \texttt{Any} как раз является стирающим типом, потому что при присваивании ему, стирается информация о типе исходной переменной, и единственный способ взаимодействовать с ней у нас остается лишь посредством интерфейса, который поддерживает стирающий тип.
При этом статическая типизация языка позволяет проверять во время компиляции, можно ли положить данную переменную внутрь стирающего типа или нет и выдать ошибку компиляции, если нельзя.
\end{enumerate}

\paragraph{Важное замечание}

В этом месте я хочу сделать важное замечание, когда я говорю про <<общий интерфейс>>, я НЕ имею в виду наследование или интерфейсы с виртуальными методами.
Я имею в виду публичные методы класса и все.
То есть стирающие типы и указатели не требуют от вас калечить код всех возможных классов, чтобы они стали используемыми в коде, а наоборот, суть в том, что мы хотим, навесить интерфейс поверх класса неинтрузивно (то есть не вмешиваясь в код класса).
Бывает два вида навешивания интерфейса:
\begin{enumerate}
\item Утиный принцип.
Мы можем присвоить к \texttt{Pointer} из примера выше любой адрес любого объекта, главное, чтобы через этот указатель можно было позвать нужные методы.
То есть если синтаксически использование возможно, то оно разрешено без каких-то дополнительных ограничений.
Этот принцип похож на поведение Python с его динамической типизацией, когда вы можете положить в переменную, что хотите, главное чтобы синтаксически код был корректным.

\item Явное объявление присоединяемого интерфейса.
В этом случае где-то в коде должна быть строчка, которая говорит, что мы разрешаем данному классу присоединяться к данному интерфейсу.
Данное поведение можно встретить в таких языках как Rust, когда вы присоединяете trait-ы к структуре.
\end{enumerate}
Обратим внимание, что имплементация стирающих типов не обязана использовать наследование в каком-либо виде, но так исторически сложилось, что именно наследование с виртуальными методами рассматривается как тот самый настоящий run-time polymoprhism.
Но это просто ошибка.
