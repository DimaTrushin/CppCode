\ProvidesFile{Classic.tex}[Классический подход]


\subsection{Классический подход и наследование с виртуальными методами}
\label{section::ClassicPolymorphism}

Давайте я начну с описания того, что мы вообще хотим сделать.
Мы хотим добиться полиморфного поведения для классов, а именно, мы хотим, чтобы методы класса с одними и теми же именами во время исполнения могли исполнять разный код.
Для этого в языке C++ предусмотрен специальный механизм -- наследование с виртуальными методами.
В начале мы заводим класс-интерфейс, в котором фиксируем интересующий нас публичный интерфейс
\begin{cppcode}
struct Interface {
  virtual void f() const = 0;
};
\end{cppcode}
После чего, если мы хотим, чтобы класс подходил под этот интерфейс, мы должны прикрепить этот интерфейс к нужному классу.
Происходит это путем наследования ОТ интерфейса вот так:
\begin{cppcode}
struct A : Interface {
  void f() const override { /*implementation*/ }
};

struct B : Interface {
  void f() const override { /*implementation*/ }
};
\end{cppcode}
Тут есть две проблемы.
Это точно не утиный принцип, но это еще не большая беда.
Главная проблема такого соединения -- мы не интерфейс прицепляем к классу, а класс к интерфейсу.
То есть мы делаем зависимость не в ту сторону, в которую хотим.
Проблемы такого соединения интерфейса и класса мы обсудим ниже, а пока логическая диаграмма наследования между классами:
\begin{center}
\[
\xymatrix{
  {}&{\text{Interface}}
   	{\save
   [].[]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}\\
  {\text{A}}\ar[ur]+(-1, -3)
 	{\save
   [].[]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{\text{B}}\ar[ul]+(1, -3)
   {	\save
   [].[]*+[F-:<3pt>]\frm{}
   \restore
	}
}
\]
\end{center}
Теперь, чтобы полиморфизм работал, нам нужно создать объект типа \texttt{A}, но ссылаться на него как на объект типа \texttt{Interface}.
Если нам не надо владеть объектами, то это можно сделать так
\begin{cppcode}
void f(Interface* ptr) {
  ptr->f();
}

int main() {
  A a;
  f(&a); // casts A* to Interface*
  B b;
  f(&b); // casts B* to Interface*
}
\end{cppcode}
Если же мы напишем так
\begin{cppcode}
int main() {
  A a;
  Interface obj = a; // compilation error
}
\end{cppcode}
То так как класс \texttt{Interface} содержит чисто виртуальный метод (тот что равен нулю при объявлении), то невозможно создать объект такого типа и это ошибка компиляции.
Давайте поменяем определение так
\begin{cppcode}
struct Interface {
  virtual void f() const {}
};
\end{cppcode}
Теперь можно написать код вида
\begin{cppcode}
A a;
a.f(); // calls A::f()
Interface obj = a;
obj.f(); // calls Interface::f()
B b;
b.f(); // calls B::f()
obj = b;
obj.f(); // calls Interface::f()
\end{cppcode}
Как мы видим, в этом случае полиморфного поведения нет.
Вся причина в том, что оператор присваивания \texttt{obj = a} строит по объекту типа \texttt{A} объект типа \texttt{Interface}, то есть от класса \texttt{A} отрезается его базовая часть и складывается внутрь \texttt{obj}.
И мы лишаемся таким образом полиморфного поведения.
Обойти эту проблему на уровне value semantics не возможно.
Нам придется работать с голыми указателями.
А именно, нам надо создать где-то объект типа \texttt{A}, и потом кастовать его адрес к адресу на \texttt{Interface}.
И вот в этом случае обращение к методу \texttt{f} через \texttt{Interface} гарантирует вызов \texttt{A::f}.
Теперь пользоваться всем этим можно так
\begin{cppcode}
int main() {
  std::unique_ptr<Interface> ptr = std::make_unique<A>();
  ptr->f(); // calls A::f()
  ptr = std::make_unique<B>(); // calls ~Interface before storing new value
  ptr->f(); // calls B::f()
  return 0;
} // ~ptr calls ~Interface
\end{cppcode}
Однако, в 4-ой строке перед тем, как положить новое значение в \texttt{ptr}, будет уничтожено старое значение, а именно вызывается \texttt{\~{}Interface}.
Но по указателю лежит объект класса \texttt{A}, а значит вызовется не верный деструктор.
Аналогичная проблема есть в 7-ой строке при выходе из \texttt{main} вызывается деструктор для \texttt{ptr}, который опять же вызовет деструктор для \texttt{Interface}.
Для решения этой проблемы надо сделать деструктор в \texttt{Interface} тоже виртуальным, чтобы вызвался нужный деструктор.
\begin{cppcode}
struct Interface {
  virtual void f() const = 0;
  virtual ~Interface() = default;
};
\end{cppcode}
Вот теперь это безобразие заработает как надо.
Но не как мы хотели.
Давайте обсудим, что же не так с этим решением.

\paragraph{Проблемы классического решения}
\begin{enumerate}
\item Первое и самое главное: мы делаем не то, что хотим.
А именно, мы хотим к любому типу привесить интерфейс, но делаем это наоборот, мы к интерфейсу привешиваем тип.
А именно у нас зависимость $\texttt{Interface}\leftarrow\texttt{A}$, а не наоборот.
В частности, класс \texttt{A} начинает зависеть от интерфейса, а не наоборот.
Мы не можем подвесить интерфейс к классу постфактум, если нет доступа к коду класса, то нет возможности к нему подвесить интерфейс.
Для того, чтобы обойти эту проблему придется писать адаптеры.

\item Мы ломаем логику зависимостей в кодовой базе.
Так как у нас класс \texttt{A} зависит от \texttt{Interface}, то мы инклудим в файл с классом \texttt{A} файлы, необходимые для работы интерфейса, а не самого класса.

\item Вместо написания самого класса \texttt{A}, мы теперь должны думать про виртуальные методы.
А именно, мы теперь для каждого интерфейса должны писать лишний код, который делает простой и понятный класс \texttt{A}, который до этого имел простую и понятную структуру, сложным и непонятным.

\item Наличие чистых виртуальных функций не согласовано с оператором присваивания.
А потому нам приходится работать с объектами через указатели.

\item Наличие виртуальных функций -- удар по производительности даже если вы используете класс не полиморфно.
Вы всегда платите цену за наличие интерфейса.

\item Работа с объектами через указатели означает, что мы поменяли семантику кода.
Если до использования интерфейсов мы могли оперировать переменными и вызывать у них методы, то теперь мы оперируем ссылками и указателями.

\item Работа с объектами через указатели означает так же, что мы должны аллоцировать объекты на куче.
А это значит, что пользователь полиморфного класса обязан следить за памятью и lifetime-ом объекта.
Нужно заворачивать объекты в адаптеры вроде \texttt{unique\_ptr}.

\item Потеря value semantics и использование прямых указателей в коде побуждает в объектах ссылаться друг на друга или иметь общее состояние через \texttt{shared\_ptr}.
Это порождает случайные связи между совершенно разными не связанными кусками кода.
Код становится сложно оценивать из локальных соображений.
Код становится сложно поддерживаемым.
Начинаются проблемы с синхронизацией и lifetime-ами.
\end{enumerate}

Если вернуться к примеру из предыдущего раздела
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{5cm}
\begin{cppcode}[numbers = none, linewidth=5cm]
// Function.h

struct Function {
  static void f1();
  static void f2();
  static void f3();
  void operator()() const {
    f1();
    f();
    f3();
  }
  virtual void f() const {
    f2();
  }
  virtual ~Function();
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{5.5cm}
\begin{cppcode}[numbers = none, linewidth=5.5cm]
struct FunctionG : Function {
  static void g();
  void f() const {
    g();
  }
};

int main() {
  Function* f = new Function();
  (*f)();
  delete f;
  f = new FunctionG();
  (*f)();
  delete f;
  return 0;
}
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}
То можно добавить еще одну проблему.
Конкретно в этом случае мы не можем использовать любую функцию \texttt{g}.
Нам приходится заворачивать код этой функции внутрь класса наследника.
Потому что теперь объект -- это то же самое, что наследник.
То есть поведение контролируется НЕ переменной класса, а самим классом.
Все переменные одного класса имеют одинаковое поведение и чтобы поменять поведение, надо писать аж целый новый класс.
