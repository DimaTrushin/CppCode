\ProvidesFile{Dangerous.tex}[Опасные механизмы языка]


\section{Опасные механизмы языка}
\label{section::Dangerous}
Когда у вас в руках очень мощный язык, который умеет делать все и любым образом очень важно отличать какие его механизмы для каких нужд были созданы.
Это помогает понять, когда какими механизмами надо и не надо пользоваться.
Один из способов смотреть на возможности языка -- разделить их на опасные и безопасные.
И тогда важно придерживаться следующего правила:
\begin{itemize}
\item Безопасными механизмами языка можно пользоваться всегда

\item Опасными механизмами языка можно пользоваться только для имплементации какого-то паттерна или структуры данных, который снаружи имеет безопасный интерфейс для использования.
Опасные механизмы -- это ТОЛЬКО библиотечный код.
НИКОГДА не использовать их в бизнес логике.
\end{itemize}

Стоит отметить, что в языке Rust даже есть ключевое слово \verb"unsafe", которое показывает, что вы начинаете пользоваться небезопасными механизмами.
В языке Rust понятие безопасного и не безопасного формализовано очень просто: если вы используете только безопасный код, то вы не получите undefined behavior.
И если вы гарантируете, что ваш \verb"unsafe" код не содержит undefined behavior, то и вся программа его не содержит.
Более того, с безопасным кодом, компилятор Rust отдаст свою жизнь за то, чтобы не пропустить UB и прочтет вам лекцию по поводу каждой ошибки и предложит варианты их решения.
В случае C++, к сожалению, вам приходится полагаться только на себя и свой опыт.
Никакой помощи от компилятора вы не дождетесь.
Это осознанное решение комитета.
А потому в C++ намного важнее, чем в Rust понимать, чем можно пользоваться, а чем нужно пользоваться осторожно и только в особых случаях.
Если вы себя не защитите от использования небезопасного языка, то вас ничто не спасет.
А это плохая тактика работы с кодом.

Давайте я начну с перечисления механизмов, которые я бы считал не безопасными, и которым нет места в повседневном коде.
А потом я обсужу пару примеров и прокомментирую, как это все должно работать.
Список небезопасных механизмов языка:
\begin{enumerate}
\item \verb"goto"

\item \verb"new"/\verb"delete", \verb"fopen"/\verb"fclose", \verb"malloc"/\verb"free" и любые другие парные операции захвата и освобождения ресурса (не обязательно памяти)

\item \verb"cast"-s, в особенности \verb"const_cast"

\item Exceptions

\item friend

\item mutable

\item Lock примитивы

\item \verb"shared_ptr" (в особенности на неконстантный объект)

\item Глобальные переменные

\item Наследование с виртуальными методами

\item Итераторы, ссылки и указатели в структурах (НЕ в алгоритмах)

\item RTTI
\end{enumerate}


% TO DO
% Я думаю надо разделить на subsection, чтобы в оглавлении были эти штуки видны. Надо подумать.

Давайте разберем эти примеры.
Я на примере \verb"goto" обсужу важные философские моменты, потому первый пункт прочитайте обязательно:
\begin{enumerate}
\item \verb"goto".
Я думаю, вы уже ни раз слышали, что это главное зло всех программистов и его не надо ни в коем случае никогда и ни при каких условиях использовать.
Это стало понятно уже больше 50 лет назад еще до создания языка C++.
Тем не менее \verb"goto" присутствует в языке и доступен программисту.
Проблема с этой командой в том, что вы можете прыгнуть внутри функции из любой строки кода в любую, при этом логика исполнения становится очень запутанной.
Очень тяжело отследить состояние программы и что и как может измениться при таких прыжках.
Потому эту команду не надо использовать никогда.

После такого вступления должен возникнуть разумный вопрос: а зачем тогда вообще нужна \verb"goto"?
И ответ очень простой: вообще без этой команды написать разумную программу не получится.
Любые условные переходы по \verb"if"/\verb"else", циклы \verb"while" или \verb"for" используют внутри себя \verb"goto".
И без нее их просто не возможно имплементировать.
Именно эта причина и порождает необходимость использования \verb"goto".
Теперь возникает следующий вопрос: почему \verb"goto" внутри условных переходов и циклов -- это хорошо, а в коде программы -- плохо?
И ответ опять очень простой: дело в том, что внутри условного перехода по \verb"if"/\verb"else" или внутри циклов \verb"while" или \verb"for" команда \verb"goto" используется в очень ограниченном наборе сценариев.
И потому их можно просто все перебрать и убедиться, что при любом исполнении программы блок, содержащий \verb"goto" будет работать корректно, как и полагается.
Именно это ограниченное использование позволяет не просто поверить, а именно проверить (доказать), что программа будет корректной.
Если же использовать эту команду в бизнес логике приложения, то сделать такой перебор просто не представляется возможным.
Кроме того, снаружи и условные переходы по \verb"if"/\verb"else" и циклы \verb"while" или \verb"for" являются безопасными механизмами.
Они не несут в себе проблем, которые несет \verb"goto".%
\footnote{Хорошо держать в голове аналогию: есть нож для хлеба, а есть циркулярная пила.
Вы не используете циркулярную пилу, чтобы намазывать масло на хлеб по утрам, но это не значит, что она не нужна.
Есть задачи, которые без нее не сделать, где обычный нож не подойдет.
Но когда вы работаете с циркулярной пилой, у вас есть огромное количество техник безопасности и правил, тогда как при использовании ножа, вы даже не задумываетесь об этом.}

\item \verb"new"/\verb"delete", \verb"fopen"/\verb"fclose", \verb"malloc"/\verb"free" и любые другие парные операции захвата и освобождения ресурса (не обязательно памяти).
Очевидная причина почему эти операции опасны -- они идут в паре и надо не забыть освободить ресурс и не освободить его дважды.
И проблема тут не только в дисциплинированности программиста, а так же в том, что в C++ есть исключения.
А потому вы можете выйти из scope в любой точке кода.
Давайте рассмотрим пример
\begin{cppcode}
void f() {
  A* ptr = new A();
  g(ptr);
  delete ptr;
}
\end{cppcode}
Если функция \verb"g" может кинуть исключение, то наличие \verb"delete" в 4 строчке не поможет.
Мы выйдем из функции \verb"f" раньше.
Потому такие парные операции всегда надо запаковывать в RAII (смотри~\ref{section::RAII}) обертки:
\begin{cppcode}
void f() {
  std::unique_ptr<A> ptr = std::make_unique<A>();
  g(ptr.get());
} // ptr destructor is called automatically
\end{cppcode}
Теперь деструктор \verb"ptr" вызовется при любом выходе из функции \verb"f" и при нормальном завершении работы и при брошенном исключении.

Давайте я на всякий случай проговорю важную вещь про \verb"new"/\verb"delete".
Они конечно же используются внутри всех динамических контейнеров в STL, иначе вы просто не сможете выделить память под него.
Тогда почему внутри контейнера их использовать хорошо, а вне плохо?
Потому что внутри контейнера они используются в ограниченном количестве сценариев таком маленьком, что их все можно перебрать руками и доказать, что ваш контейнер работает корректно и снаружи для использования безопасен.
Вот эта мысль: опасно внутри, но там мы все проверили, а снаружи безопасно -- это главная мысль при использовании опасных механизмов языка.
Тут мысль такая же как и при описании \verb"goto", но я решил, что все равно стоит произнести эти слова еще раз.

\item \verb"cast"-s, в особенности \verb"const_cast".
Касты это очень низкоуровневый механизм.
С помощью них можно легко получить UB и не заметить этого.
А \verb"const_cast" вообще был создан только для того, чтобы делать UB и никаких других функций у него нет.
Потому касты должны быть использованы внутри каких-то паттернов или хотя бы вспомогательных функций (которые снаружи работают безопасно).
Хороший пример -- CRTP (Curiously Recursive Template Pattern).
Про этот шаблон я расскажу позже в разделе~\ref{section::CRTP}.

\item Exceptions.
С исключениями есть несколько проблем
\begin{enumerate}
\item Из-за исключений брошенных в любой точке программы ее исполнение может обвалиться в любой момент времени в любом месте и вы ничего с этим сделать не сможете.

\item Бросание исключения при уже висящем исключении приводит к завершению программы по terminate и вы ничего с этим сделать не сможете.

\item Не все фреймворки поддерживают исключения, например Qt не поддерживает.

\item При бросании исключений нужно выходить из функций, чьи данные лежат на стеке.
А значит надо чистить эти данные.
Такой процесс называется stack unwinding.
Существуют две версии имплементации исключений:
\begin{enumerate}
\item Имплементация gcc хранит для каждого scope, где может быть брошено исключение таблицу из всех деструкторов всех объектов, которые надо позвать.
Что раздувает бинарники.

\item Имплементация msvc параллельно в run-time поддерживает второй стек, куда складываются деструкторы для текущего стека.
Это означает, что вы платите за использование исключений, даже когда они не кидаются.
\end{enumerate}
\end{enumerate}

\item friend.
Данное ключевое слово нарушает инкапсюляцию данных в классе, то есть позволяет получить доступ к внутренностям класса.
Это чревато тем, что вы можете через этот доступ сломать внутренние инварианты класса.
Использовать же friend надо тогда, когда два класса шарят один общий инвариант.
\begin{enumerate}
\item В качестве примера можно привести блокирующий observer pattern (см. раздел~\ref{section::Observer}).
В этом случае observer и observable должны поддерживать друг на друга согласованные указатели и чтобы уметь восстанавливать этот инвариант, они должны друг у друга дергать не безопасные методы.

\item Еще один пример builder pattern (см. раздел~\ref{section::Builder}).
Если сложно объект построить сразу одним конструктором (например потому что для этого надо указывать кучу данных в аргументах и это не удобно) слишком сложно.
Тогда можно завести класс builder, который будет строить нужный класс по частям и внутри builder-а нужный класс может быть в некорректном состоянии и builder-у разрешено управлять его инвариантами.
\end{enumerate}

\item mutable.
Данное ключевое слово нарушает const correctness в прямом смысле слова.
Оно позволяет добавить в класс поле, которое можно менять даже в const методах.
Предполагается, что для этого ключевого слова есть два use-case-а:
\begin{enumerate}
\item Кэш.
Действительно, даже при работе константного метода вам может понадобиться записать в специальное поле результат, чтобы потом не пересчитывать его.
Однако, есть куда более простой способ.
Вспомним, что const не пробрасывается сквозь указатели.
А потому кэш можно хранить в \verb"std::unique_ptr".
Либо получать доступ к внешнему сервису кэширования.

\item Lock примитивы.
Если вам нужны lock примитивы, то вы скорее всего пишите какую-то известную структуру данных, про которую доказано, что она в такой имплементации будет работать корректно.
Если это не так, то вы не знаете, что вы делаете.
Проблема с хранением lock примитивов в классе лишает класс value semantics (см. раздел~\ref{section::Semantics}).
Если вам нужна на таком классе синхронизация, возможно вам и не нужна value semantics.
Но если нужна, то все так же можно положить все \verb"std::unique_ptr".
Все что касается синхронизации и межпоточного взаимодействия -- это отдельная болезненная тема.
\end{enumerate}

\item Lock примитивы.
Примитивы синхронизации -- это слишком низкоуровневые элементы языка, чтобы они появлялись в бизнес логике.
Кроме того, бездумное использование этих примитивов может легко подвесить вашу программу в deadlock или race condition.

\item \label{item::SharedPtr}
\verb"shared_ptr" (в особенности на неконстантный объект).
Использование \verb"shared_ptr" на неконстантный объект нарушает локальность.
У вас может быть две переменные очень далеко друг от друга в коде, которые хранят указатель на один и тот же ресурс.
И теперь любые изменения в одной точке программы, могут вызвать любые непредсказуемые изменения в сколь угодно далекой точке программы, про которую вы можете даже не подозревать.
Такие связанные воедино данные и раскиданные по всему коду называются Incidental Data Structures.
Есть всего два случая для использования \verb"shared_ptr" на неконстантный объект.
Их мы обсудим позже в разделе~\ref{section::SharedPtr}.
Так же не забывайте, что \verb"shared_ptr" из STL имеют скрытую синхронизацию счетчика ссылок, что будет вам стоить производительности всегда и вы не можете ее отключить, только если не напишете свою версию.
Это печально.

С другой стороны \verb"shared_ptr" на константный объект -- это дешевый способ сделать данные дешево копируемыми при условии их константности.
Это не рассматривается, как опасный механизм языка (потому что он обладает value semantics~\ref{section::Semantics}), но даже в этих условиях надо прятать \verb"shared_ptr" внутрь шаблонного класса, потому что это лишь деталь имплементации.
Одна из причин в том, что у \verb"shared_ptr" скорее всего не тот интерфейс, который вы хотите иметь.

\item Глобальные переменные.
Очевидная проблема с глобальными переменными та же, что и с \verb"shared_ptr" -- это создание Incidental Data Structures, то есть данных, которые тесно связаны друг с другом и находятся в неожиданных и совершенно несвязанных друг с другом местах.
Но кроме этого у глобальных переменных есть еще одна проблема, которая растет из модели компиляции C++.
Так как компиляция происходит в две стадии: сначала компиляция каждой единицы трансляции, а потом линковка всех полученных бинарников в едино, то возникает вопрос: а в каком порядке запускаются конструкторы и деструкторы глобальных переменных?
Внутри одной единицы трансляции они идут в том же порядке, в котором они написаны в коде.
А вот между единицами трансляциями нет никаких гарантий.
А это значит, что если вы хотите использовать глобальную переменную из другой единицы трансляции в конструкторе другой глобальной переменной, то она может быть еще не создана.
А значит вы не можете к ней безопасно обратиться.
Для таких ситуаций придуман Singleton pattern.
Использование их не лучшая практика, но все таки есть ситуации, когда они нужны.
Это мы обсудим отдельно в разделе~\ref{section::Singleton}.

\item Наследование с виртуальными методами.
Изначально наследование в языке -- это лишь вид слияния интерфейсов, или другими словами <<горизонтальная композиция>> про это можно почитать в разделе~\ref{section::Composition}.
Однако, есть возможность унаследоваться от базового класса с виртуальными методами, что позволяет использовать вместо класса напрямую только интерфейс класса (базовый класс).
На этом приеме обычно принято строить полиморфное поведение в run-time (что это такое можно посмотреть в разделе~\ref{section::Polymorphism}).
Однако, у этого решения есть огромное количество недостатков и дефектов, которые делают код хуже как по читаемости, так и по поддерживаемости, так и по производительности.
На данный момент есть куда более хорошее решение -- стирающие типы (Type Erasure, разделы~\ref{section::RefErasure} и~\ref{section::TypeErasure}).
К сожалению в C++ нет поддержки стирающих типов на уровне языка и в STL есть только три стирающих типа (точнее даже два с половиной).
Детально проблемы с наследованием с виртуальными методами я буду говорить тут~\ref{section::ClassicPolymorphism}.

\item Итераторы, ссылки и указатели в структурах (НЕ в алгоритмах).
Давайте начнем со ссылок.
Причина почему они есть в языке -- мы не хотим передавать в функцию тяжелые данные по копии.
Вместо этого давайте передадим указатель на данные.
И чтобы не возиться со случаем, что он может быть нулевой в языке есть отдельный вид указателя со специальным поведением, который имитирует исходный объект, и который называется ссылка.
То есть при использовании ссылок, всегда предполагается, что мы можем гарантировать, что данные всегда живы во время работы ссылок.
И для этого даже есть специальные правила языка по продлению life-time временных объектов, которые забиндились на ссылки (посмотрите конец раздела~\ref{section::Semantics} про то, как это работает).
Итераторы -- это по сути более умные указатели, которые просто унифицируют работу с разными контейнерами и используются для передачи данных в алгоритмы.
То есть ссылки, указатели и итераторы -- это данные для передачи аргументов в методы.
Они НЕ предназначены для длительного хранения, чтобы по ним ссылаться на другие объекты.
Причина очень простая -- объект по указанному адресу мог переехать или мог быть уничтожен.
Потому, если только вы не пишите свой итератор, использовать ссылки или указатели для постоянного хранения -- плохая идея.

Есть отдельный специальный случай -- Си-шные строковые константы.
Они хранятся по \verb"const char*".
И единственная причина почему их безопасно использовать -- такие строковые константы создаются и инициализируются до запуска любой программы и в течение времени работы программы лежат в одной и той же области памяти.
Потому ссылаться на них по константному указателю имеет value semantics (что это такое смотри в разделе~\ref{section::Semantics}), а значит безопасно.
Но это касается только констант, а не создаваемых в run-time новых строк.

\item RTTI (Run Time Type Information).
Это механизм языка, который позволяет во время исполнения программы работать с информацией о типе объекта.
На мой взгляд эта фича языка является ошибкой дизайна и крутится вокруг проблем связанных с наследованием с виртуальными методами, иерархиями интерфейсов и прочей хренью, которых не должно существовать в коде.
Если мы используем язык со статической типизацией, давайте мы не будем ее ломать.
А если вам нужно полиморфное поведение, то стирающие типы решают эту задачу в run-time лучше, чем любое другое кустарное решение.
\end{enumerate}
