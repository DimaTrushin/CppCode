\ProvidesFile{Ecosystem.tex}[Экосистема C++]


\section{Экосистема C++ и модель компиляции}

В начале надо сказать несколько общих слов про экосистему C++.

\subsection{Модель компиляции}

Изначально C++ был надстройкой вокруг языка Си добавляющий в него новый функционал.
Идея была в том, что любой Си код должен компилироваться C++ компилятором.
А потому модель компиляции у C++ целиком и полностью позаимствована у Си.
Однако, надо понимать, что эти языки очень сильно отличаются друг от друга.
Кроме того, с самого начала многие аспекты C++ не были стандартизированы, язык развивался хаотично, что в итоге привело к тому, что поверх старой экосистемы Си был построен совсем новый язык, который только формально совместим с Си и уж точно не предназначен для использования вместо Си.
Что эти слова в точности значат я постараюсь объяснить ниже в деталях.
А начать я хочу прежде всего с общей картины.
На диаграмме ниже изображена общая картинка того, как функционирует сборка приложения в языке C++ (включая информацию о доступных инструментах):
\begin{center}
\[
\xymatrix{
{}\ar@{}[dddd]_*+[F--]{\txt{\begin{minipage}{3cm}
\begin{enumerate}
\item git
\item clang-format
\item clang-tidy
\item IDE
\item linter
\item static analyzer
\end{enumerate}
\end{minipage}}}&{}&*+[F]{\txt{STL}}\ar@{-->}@/_/[d]\ar@{-->}@/_25pt/[dd]&{}&*+[F]{\txt{3d party\\Libs}}\ar@{-->}@/_20pt/[lld]\ar@{-->}@/^20pt/[d]-(0,10)&*+[F--]{\txt{Package\\Manager}}\ar@{..>}[l]+(9,0)\\
{}\ar@{..>}[r]-(10,0)&*+[F-:<3pt>]{\txt{Source\\\phantom{111} TU}}\ar[rr]_{\txt{Compiler}}
{
\save
[]*+\frm{}.[rrrdd]*+[F-,]\frm{}
\restore
}
&{}&*+[F-:<3pt>]{\txt{Binary}}\ar`r[r][rdd]_(0.2){\txt{Linker}}&{}&{}\\
{}\ar@{..>}[r]-(10,0)&*+[F-:<3pt>]{\txt{Source\\\phantom{111} TU}}\ar[rr]_{\txt{Compiler}}&{}&*+[F-:<3pt>]{\txt{Binary}}\ar`r[r][rd]&{}&{}\\
{}&{}&{}&{}&*+[F-:<3pt>]{\txt{Exe}}&{}\\
{}\ar@{}[rr]_*+[F--]{\begin{minipage}{3cm}
Система сборки:
\begin{enumerate}
\item cmake
\item qmake
\item meson
\item \ldots
\end{enumerate}
\end{minipage}}&\ar@{..>}[u]-(0,5)&{}&{}\ar@{}[rr]_*+[F--]{\begin{minipage}{2.4cm}
\begin{enumerate}
\item debugger
\item profiller
\item sanitizers
\item tests
\end{enumerate}
\end{minipage}}&{}\ar@{..>}[u]-(0,5)&{}\\
}
\]
\begin{tabular}{cc}
{
\begin{minipage}[t]{8cm}
\textbf{Круглые боксы}:
\begin{enumerate}
\item Source/TU -- исходный код/единицы трансляции

\item Binary -- бинарный код

\item Exe -- исполняемый код
\end{enumerate}
\end{minipage}
}&{
\begin{minipage}[t]{8cm}
\textbf{Прямоугольные боксы}:
\begin{enumerate}
\item STL -- стандартная библиотека

\item 3d party Libs -- сторонние библиотеки

\item Бокс с затенением представляет весь проект 
\end{enumerate}
\end{minipage}
}\\
{
\begin{minipage}[t]{8cm}
\textbf{Пунктирные боксы}:
\begin{enumerate}
\item Инструменты для исходного кода

\item Инструменты для сторонних библиотек

\item Системы сборки

\item Инструменты для анализа собранного приложения
\end{enumerate}
\end{minipage}
}&{
\begin{minipage}[t]{8cm}
\textbf{Стрелки}:
\begin{enumerate}
\item $\xymatrix@1{{}\ar@{->}[r]&{}}$ -- поток данных при сборке

\item $\xymatrix@1{{}\ar@{-->}[r]&{}}$ -- показывает точки использования

\item $\xymatrix@1{{}\ar@{..>}[r]&{}}$ -- показывает инструменты для работы на этом этапе сборки
\end{enumerate}
\end{minipage}
}
\end{tabular}
\end{center}

\subsubsection{Объяснение модели компиляции}

Давайте я опишу, что тут происходит.
Прежде всего задача сборки любого проекта -- преобразование кода C++ в машинный код.
Сборка проекта происходит в два этапа:
\begin{enumerate}
\item Этап компиляции.
Выполняется компилятором (compiler).
Преобразует код на C++ в отдельный бинарный файл (binary).
Единица компиляции называется translation unit (TU).
Обычно это cpp файл.

\item Этап линковки.
Выполняется линковщиком (linker).
Собирает из нескольких бинарных файлов полученных на этапе компиляции единый бинарный файл с исполняемым кодом (Exe).
\end{enumerate}

Это две независимые стадии, которые выполняются разными программами.
Давайте я на модельном примере поясню, что это все значит, и как понимать компиляцию плюсов.
Предположим у вас есть следующие файлы:
\begin{cppcode}
// function.h

void function();

// function.cpp

#include "function.h"

void function() {
}

// main.cpp

#include "function.h"

int main() {
function();
return 0;
}
\end{cppcode}
Теперь надо провести компиляцию и линковку кода командами%
\footnote{Я использую условные команды и не использую синтаксис конкретных комиляторов и линкеров.}
\begin{enumerate}
\item compile \verb"function.cpp" to \verb"function.bin"

\item compile \verb"main.cpp" to \verb"main.bin"
\end{enumerate}
Во время первой команды компиляции \verb"function.cpp" создается так называемая единица трансляции.
По простому, выполняются команды препроцессора и вставляются все \verb"#include" копипастой.
То есть получается файл
\begin{cppcode}
// TU for function.cpp

void function();

void function() {
}
\end{cppcode}
После чего создается бинарный файл, скажем, \verb"function.bin", в который складывается информация о функциях и переменных из единицы трансляции.%
\footnote{Я не использую конкретный синтаксис ассемблера, я пишу условный машинный код.}
\begin{cppcode}
// function.bin

function:
  return;
\end{cppcode}

Теперь выполняется компиляция \verb"main.cpp".
В начале составляется единица трансляции.
\begin{cppcode}
// TU for main.cpp

void function();

int main() {
  function();
  return 0;
}
\end{cppcode}
Теперь эта единица трансляции компилируется в машинный код.
\begin{cppcode}
// main.bin

main:
  call function();
  return 0;
\end{cppcode}

Обратите внимание, что компилятору не нужно знать определение \verb"function".
Ему достаточно знать, что имя \verb"function" является именем функции и что \verb"function()" -- это вызов функции.
Об этом компилятору сообщает строчка $3$ в единице трансляции для \verb"main.cpp".
Без этой строчки \verb"function" было бы неизвестным именем и вызывало бы ошибку компиляции.
А так это функция, которую компилятор не знает, но знает все, чтобы в \verb"main.bin" поместить правила ее вызова.

Теперь у нас есть два бинарных файла
\begin{cppcode}
// function.bin

function:
  return;
  
// main.bin

main:
  call function();
  return 0;
\end{cppcode}
И нам нужно вызвать линковку командой
\begin{itemize}
\item Link \verb"function.bin" and \verb"main.bin" to \verb"main.exe"
\end{itemize}
Точкой входа в программу является функция \verb"main()".
Потому компилятор найдет ее и начнет из всех бинарников подставлять все необходимые функции.
Мы видим, что внутри \verb"main" есть вызов функции \verb"function()".
Для этого линкер должен где-то среди всех бинарников найти одну единственную функцию \verb"funcion()" и добавить ее код в \verb"main.exe".
В итоге получится следующее
\begin{cppcode}
// main.exe

main:
  call function();
  return 0;

function:
  return;
\end{cppcode}
Если линкер не находит имени \verb"function()" ни в одном бинарнике -- это ошибка линковки.
Если линкер находит две функции \verb"function" в разных бинарниках, то это тоже ошибка линковки, кроме специальных случаев.%
\footnote{К специальным случаям относятся функции помеченные словом \verb"inline" и инстанциации шаблонов, о которых я поговорю позже.}
В специальных случаях мы должны гарантировать линкеру, что все определения для \verb"function" являются одинаковыми, потому что он может выбрать любое из них взамен другого.
Соответственно, если это не так, то это undefined behavior.

Для чего сделано такое безобразие?
Расчет в такой модели сделан на следующую организацию кода.
Единицей кода является файл.
И мы специально делим проект на несколько файлов, чтобы в случае внесения изменений нам не надо было перекомпилировать все файлы целиком, а лишь перекомпилировать один-два файла, и потом перелинковать нужные бинарники.
Эта идея помогала значительно сократить время компиляции для больших проектов.
Такая модель использовалась в Си, и потому плюсы переняли ее, добавив свои дополнительные стадии.
Однако, файл, как единица компиляции, это очень плохая идея, особенно учитывая, что в плюсах появились шаблоны.
Они как раз и ломают всю идиллию такого подхода.

\paragraph{Что нужно знать компилятору}

Обратите внимание, что в плюсах есть два понятия declaration и definition.
Declaration -- это объявление объекта, которое говорит компилятору, что это за объект (переменная, функция, имя класса, имя шаблона и т.д.).
Declaration может быть не достаточно для того, чтобы полностью скомпилировать код с этим объектом.
Definition -- это declaration, которое полностью определяет объект.
Например
\begin{cppcode}
void f(); // declaration

void f() {} // definition

static int x; // declaration

static int x = 1; // definition

class A; // declaration

class A {}; // definition

int y; // definition
\end{cppcode}
В строчке 1 мы видим declaration для функции.
Его не достаточно, чтобы поместить в бинарник код для функции.
Однако, его достаточно, чтобы поместить в бинарник точку вызова функции.
В строчке 3 идет defintion для функции, его достаточно, чтобы поместить в бинарник код функции.
В строчке 5 идет declaration для статической переменной.
Чудесатость таких переменных заключается в том, что эта строчка не помещает переменную в память и не дает ей адрес, но говорит, что имя \verb"x" означает имя переменной типа \verb"int".
А вот строчка 7 уже полностью определяет \verb"x" и после нее у \verb"x" появляется адрес.
Строчка 9 -- declaration для класса.
Ее не достаточно, чтобы создать переменную класса \verb"A", однако ее достаточно, чтобы создать указатель на этот класс, потому что все указатели имеют одинаковый размер.
Строчка 11 -- definition для класса \verb"A" и ее уже достаточно, чтобы создать объект этого класса, мы точно знаем какой размер должен занять этот объект.
Обратите внимание, что объявление не статической переменной на строке 13 является definition, потому что позволяет полностью определить объект с именем \verb"y" и работать с ним, хранить его в памяти и брать его адрес.

Как мы видели выше на модельном примере, модель компиляции плюсов построена вокруг идеи, что во время компиляции функций, если мы знаем ее определение (definition), то мы его добавляем в бинарник, а если не знаем, то добавляем в бинарник точку вызова этой функции.
Главное -- надо знать, что имя действительно было именем функции.
Для этого мы делаем \verb"#include" header-а содержащего declaration для имени функции.
А тело функции будет компилировать в отдельной единице трансляции.
И уже задача линкера найти нужное тело функции.

\subsubsection{Сборка проекта}

Как мы видим в выбранной модели компиляции единицей компиляции является файл.
Это очень архаичная система, которая не позволяет внедрить многие фичи, доступные современным языкам программирования.
В основном они связаны с тем, что у нас не может быть никакой информации между разными единицами трансляции.

\paragraph{Системы сборки}

Для управления сборкой проекта нужна система, которая отслеживает изменился ли файл с исходным кодом для проверки нужно ли его перекомпилировать.
И если нужно, то перекомпилировать и перелинковать лишь те части проекта, которые необходимо.
Такие системы называются системами сборки.
Правила хорошего тона использовать систему, которая собирает весь проект по нажатию одной кнопки.
Вот примеры систем сборки (это далеко не все примеры):
\begin{enumerate}
\item cmake -- считается стандартной системой сборки.
Постоянно развивается и большинство проектов поддерживают именно ее.

\item qmake -- специальная система сборки для экосистемы Qt.
Она поддерживает дополнительные стадии компиляции с кодогенерацией для Qt специфичного служебного кода.

\item meson -- основанная на Python система сборки.
Очень удобна в использовании, так как не требует изучения специального синтаксиса системы сборки.
\end{enumerate}

\paragraph{Виды сборки}

Важно понимать, что существуют два основных режима сборки:
\begin{enumerate}
\item Debug.
Сборка без оптимизаций и с дополнительной информацией и проверками при исполнении.
Медленная в исполнении, но более удобна для отлавливания bug-ов при исполнении.
Обычно используется вместе с Debugger-ом.
Debugger -- специальная программа, которая следит за состоянием всех переменных программы при исполнении и стеком вызываемых функций.
Позволяет пошагово исполнять программу и отслеживать ошибки исполнения.

\item Release.
Оптимизированная сборка без дополнительной информации в run-time.
Используется для релизных версий программных продуктов.
\end{enumerate}
Обе сборки выполняются компилятором и линковщиком.
Отличие только в используемых ключах для компилятора и линковщика.
Убедитесь, что ваша система сборки позволяет собрать проект в одном из двух режимах и от вас требуется лишь указать один параметр -- вид сборки.
Запомните, все настройки должны быть автоматизированы.
Вся рутинная работа должна быть поручена компьютеру.
Не надо руками консольными командами собирать проект с указанием явных ключей.
Даже написание своих make файлов%
\footnote{Если вы вдруг знаете, что это такое.}
-- это плохая практика.
Такие проекты тяжело поддерживать.
Еще бывает выделяют другие виды сборок.
Например сборщик с профилировщиком (специальная программа отслеживающая какой процент времени исполнения тратится на какие части кода).
Такая сборка хорошая для тестирования боттлнеков в производительности вашего приложения.

Есть еще один интересный момент в сборке проектов.
Есть так называемая кросс-компиляция.
Это когда вы собираете на windows приложение для linux.
Современные компиляторы и системы сборки позволяют делать и такое.
Кроме того, ваше приложение может быть мультиплатформенным в том смысле, что его можно собрать под разные операционные системы.
Как такое организовывать, я расскажу ниже.

\paragraph{Роли файлов}

При сборке любого проекта на C++ все файлы с кодом обычно делятся на две категории:
\begin{enumerate}
\item Заголовочные файлы (headers) и имеют расширение h (или hpp).

\item Файлы с кодом (sources) и имеют расширение cpp.
\end{enumerate}
Заголовочные файлы используются для копипасты их текста внутрь других h или cpp файлов.
Их задача -- снабдить компилятор всей необходимой информацией о символах, чтобы он мог скомпилировать код в бинарный файл.
Файлы с кодом или cpp файлы используются как единицы трансляции, то есть их передают компилятору на первой стадии для генерации бинарного кода.
Потому вам НИКОГДА НЕ надо отдавать h файлы компилятору.

\subsubsection{Использование сторонних библиотек}

Сторонние библиотеки бывают следующих типов
\begin{enumerate}
\item Header-only библиотеки состоят только из заголовочных h файлов и не содержат бинарных файлов.

\item Библиотека из h и cpp файлов.
Подключение таких библиотек проста, вам просто надо трактовать файлы библиотеки как файлы проекта.
Использовать h файлы для подключения в другие h и cpp файлы.
А cpp файлы надо скомпилировать и потом полученный код слинковать со своим проектом.

\item Библиотека из h файлов и файлов бинарного кода вместо (cpp).
Такие библиотеки за вас выполнили компиляцию cpp файлов.
Потому вам не надо выполнять ее на вашей машине.
Потому вы лишь подключаете h файлы библиотеки куда надо и линкуетесь с бинарниками библиотеки.
Надо понимать, что бинарные файлы от разных компиляторов (и даже разных версий компиляторов или от компиляторов одной версии, но с разными флагами компиляции) могут быть НЕ совместимы.
Потому вам надо еще найти версию библиотеки именно под ваш конкретный компилятор.
\end{enumerate}

Откуда брать библиотеки?
Если во всех современных языках программирования есть своя экосистема вокруг языка, где кроме компилятора у вас есть еще куча библиотек и пакетный менеджер для управления и подключения библиотек, то в C++ ничего такого из коробки нет.
Потому приходится опираться на сторонние решения.
Есть следующие способы менеджерить сторонние библиотеки:
\begin{enumerate}
\item Пакетный менеджер.
Это специальные приложения, задача которых автоматизировать подключение сторонних библиотек в ваш проект.
Нет какого-то единого пакетного менеджера, которым пользуются все.
Но есть несколько распространенных пакетных менеджеров:
\begin{enumerate}
\item conan

\item vcpkg
\end{enumerate}
Обычно пакетный менеджер имеет свой удаленный репозиторий в интернете, где находится база данных всех поддерживаемых библиотек.
Вы должны добавить в проект файл в специальном формате с указанием деталей о требуемых библиотеках и в систему сборки добавить соответствующие шаги по подключение библиотек указанных в таком файле.
Такой подход позволяет вам избавиться от указания конкретных путей к библиотекам или необходимости их ручной установки.
Пакетный менеджер выполнит всю работу сам.

\item Управление библиотеками с помощью системы сборки.
Разные системы сборки имеют функционал покрывающий функции пакетного менеджера.
Например cmake способен выполнять функции пакетного менеджера.

\item Использование git submodule.
Это позволяет включить стороннюю библиотеку в ваш git репозиторий без копирования ее кода.
Вам все равно придется настраивать сборки библиотеки у себя локально.
Но использование систем сборки вроде cmake обычно автоматизирует и эту часть процесса.
А для header-only библиотек это вообще супер простое решение.
\end{enumerate}


\subsubsection{Шаблоны и модель компиляции плюсов}
% шаблоны -- не согласуются с моделью компиляции

А теперь добро пожаловать в мир интересных интересностей -- шаблоны.


\paragraph{Что такое шаблоны}
Прежде всего отмечу, что бывают шаблоны функций, классов и переменных.
\begin{cppcode}
template<class T>
void f(T);

template<class T>
int x;

template<class T>
class A;
\end{cppcode}
Самое важное, что надо знать про шаблоны: шаблоны -- это не объекты, это правила по которому надо создать объект.
Например шаблон функции -- это не функция, это правило с параметрами, как создать конкретную функцию, когда вы в него подставите все значения параметров.
Аналогично с шаблоном класса -- это не класс, это правило как собрать класс, когда вы подставите все параметры.
Шаблон переменной тоже не исключение и говорит как собрать переменную со своим значением параметров.
Важно понимать, что получающиеся объекты (функции, классы и перменные) определяются именем шаблона и значением параметров, а не только именем шаблона.
Шаблон -- это лишь рецепт, как собрать.

У шаблонов так же есть declarations и definitions.
Declarations лишь говорят, что данное имя является правилом, как собрать объект.
Например в строчках 1-2 выше имя \verb"f" является именем для правила собрать функцию.
У этого правила есть один параметр \verb"T" и он параметризует тип аргумента.
Однако, это не definition, мы не знаем, как именно собрать функцию по этому правил.
Вот пример определений
\begin{cppcode}
template<class T>
void f(T) {}

template<class T>
int x;

template<class T>
class A {};
\end{cppcode}
Как я писал выше для переменных это уже будет definition, потому что шаблон точно знает, что надо собрать переменную типа \verb"int".

\paragraph{Как компилируются шаблоны}

Так как шаблоны -- это не объекты (не функции, не классы, не переменные), то они не дают кода в бинарниках, проще говоря они просто так не компилируются.
Например
\begin{cppcode}
// file.h

template<class T>
T f(T t) {
  return t;
}
\end{cppcode}
При компиляции compile \verb"file.h" to \verb"file.bin" мы получим пустой бинарный файл \verb"file.bin".
Шаблоны компилируются, только если кто-то затребовал создать объект по данному шаблону с конкретными параметрами!
Например,
\begin{cppcode}
// file.h

template<class T>
T f(T t) {
  return t;
}

// main.cpp

#include "file.h"

int main() {
  int x = f(2);
  return 0;
}
\end{cppcode}
Если мы теперь запустим компиляцию compile \verb"main.cpp" to \verb"main.bin", то произойдет следующее.
Компилятор дойдет до строчки 13 и увидит, что используется имя \verb"f", которое является шаблоном функции.
По-хорошему, мы должны были указать \verb"f<int>(2)", чтобы сказать с каким параметром мы строим функцию.
Однако, компилятор для функции умеет определять тип параметров.
Здесь передается константа \verb"2", которая по умолчанию имеет тип \verb"int", а значит компилятор определит тип \verb"T = int".
В этот момент, когда компилятор понял, что ему надо использовать \verb"f<int>", он налету создаст код для этой функции поместит его в бинарник:%
\footnote{Не забываю напоминать дотошных формалистов, что мне глубоко плевать на конкретный синтаксис конкретного ассемблера и на детали имплементации бинарного кода.}
\begin{cppcode}
// main.bin

main:
  int x = call f<int>(2);
  return 0;

f<int>(int t):
  return t;
\end{cppcode}
Теперь самое интересное, нельзя разбивать declaration и definition для шаблона на header и source файлы.
Давайте я объясню почему.
Предположим у нас есть:
\begin{cppcode}
// file.h

template<class T>
T f(T t);

// file.cpp

#include "file.h"

template<class T>
T f(T t) {
  return t;
}

// main.cpp

#include "file.h"

int main() {
  int x = f(2);
  return 0;
}
\end{cppcode}
Теперь проведем компиляцию обеих единиц трансляции.
Когда мы выполним compile \verb"file.cpp" to \verb"file.bin", то создастся единица трансляции:
\begin{cppcode}
// TU for file.cpp

template<class T>
T f(T t);

template<class T>
T f(T t) {
  return t;
}
\end{cppcode}
После чего компилятор видит, что тут одни шаблоны и создает пустой бинарник, ибо ни один шаблон не был затребован для построения конкретной функции.
Далее мы делаем compile \verb"main.cpp" to \verb"main.bin" и получаем единицу трансляции
\begin{cppcode}
// TU for main.cpp

template<class T>
T f(T t);

int main() {
  int x = f(2);
  return 0;
}
\end{cppcode}
Теперь, когда компилятор доходит до строчки 7, он видит, что тут \verb"f" -- это имя шаблон и он восстанавливает, что нам нужно построить функцию \verb"f<int>".
Однако, компилятор не видит definition для шаблона и потому не может тут налету сгенерировать код для функции \verb"f<int>".
Но это не страшно, компилятор умный, он знает, что программист тоже не дурак и специально тут вызывает функцию, которая будет определена где-то еще, и генерирует бинарник
\begin{cppcode}
// main.bin

main:
  int x = f<int>(2);
  return 0;
\end{cppcode}
А теперь самое интересно, надо линковать.
Запускаем Link \verb"file.bin" and \verb"main.bin" to \verb"main.exe".
Линкер получает на вход
\begin{cppcode}
// file.bin

// main.bin

main:
  int x = f<int>(2);
  return 0;
\end{cppcode}
Теперь линкер начинает с функции \verb"main" идет по ее телу и добавляет в \verb"main.exe" код всех функций, которые \verb"main" вызывает.
Встречает \verb"f<int>" и понимает, что ни в одном бинарнике для нее нет кода.
Это ошибка линковки.
Привет.
Именно по этой причине шаблоны всегда пишут в header файле.
Более того, их часто определяют там же, где объявляют.

\paragraph{Шаблоны и время компиляции}

О да, шаблоны любят поднасрать в длительность компиляции вашего проекта.
Ведь вы же каждый раз как встретили шаблон, должны сгенерировать для него код.
Можно надеяться, что компиляторы будут кэшировать информацию о встреченных шаблонах, но по-хорошему, компилятор видит только одну единицу трансляции за раз.
Потому без дополнительных костылей разные единицы трансляции должны заново генерировать код для всех встреченных шаблонов.
<<Это не дело!>> решили программисты из Microsoft и придумали precompiled headers.
Идея их вот в чем.
Создается единый файл *.pch, в котором компилятор хранит какое-то внутреннее представление для шаблонов для их быстрой генерации.
Получается такой не маленький файл.
Обычно туда отправляют файлы из STL или других внешних библиотек, которые вы не будете менять ибо при любых изменениях pch файл надо перекомпилировать, а это долго.
Но если вы его один раз создали, то можете потом быстро генерировать шаблоны, которые в нем учтены.
Более того, таких pch файлов можно делать несколько и подключать к сборке только нужные из них в нужный момент.
Вот такая вот технология.
Я знаю, что gcc тоже умеет делать что-то подобное, не удивлюсь, что и clang умеет, но врать не буду.


\subsubsection{Правила организации кода и пространств имен}

Запомните, никогда ни при каких условиях не пишите в global scope.
Выберете для проекта namespace и весь ваш код должен быть целиком и полностью внутри этого namespace.
Для лучшей грануляции вы можете выделить еще несколько namespace внутри.
Например
\begin{cppcode}
// Project.h

namespace Project {
struct A {
  void g();
};

namespace Impl {
void f();
} // namespace Impl
} // namespace Project

// Project.cpp

namespace Project {
void A::g() {}

namespace Impl {
void f() {}
} // namespace Impl
} // namespace Project

// main.cpp

#include "Project.h"

int main() {
  namespace pj = Project;
  pj::A x;
  x.g();
  pj::Impl::f();
  return 0;
}
\end{cppcode}
Кроме того, никогда и ни при каких условиях не пишите в пространство имен \verb"std".
Может быть встретятся ситуации с хэш функциями, когда вам придется так сделать, но все равно не делайте так.
Превознемогайте.

\paragraph{Тонкости с cpp файлами}

Есть еще пара тонкостей критичных и нет.
Начнем с критичных вещей.
Давайте напомним страшную тайну про линкер -- у него только глобальные имена и линкер не любит видеть какое-то имя в количестве отличном от одного (кроме определенных случаев).
Вот пример, когда такая проблема может появиться
\begin{cppcode}
// a.cpp
void f() {}

// b.cpp
void f() {}
\end{cppcode}
Если вы скомпилируете эти два файла в бинарники, то в каждом из них будет лежать функция с именем \verb"f" и когда линкер попытается залинковать эту функцию, то он увидит два определения и ругнется.
Такая ошибка встречается, когда внутри cpp файла вам нужна вспомогательная функция и вы случайно даете вспомогательной функции одинаковое название (и одинаковую сигнатуру).
Эта проблема лечится таким образом.
Все определения, которые выделаете в cpp файлах надо делать static или (что более удобно и равносильно для функций) помещать в anonymous namespace:
\begin{cppcode}
// a.cpp
static void f() {}

// b.cpp
namespace {
void f() {}
}
\end{cppcode}
В этом случае создается уникальное для единицы трансляции имя для namespace и потом только в этой единице трансляции выполняется \verb"using namespace".
Но когда имена помещены в namespace компилятор дает им специальные имена, чтобы линкер мог их различать.

Подобная проблема будет и с переменными и классами в cpp файлах.
Потому, когда вы определяете хоть что-либо в cpp файле, то обязательно помещайте весь код в anonymous namespace.
Даже если это не глобальные имена, просто сделайте anonymous namespace внутри того пространства имен, внутри которого это понадобится.
Разницы со словом \verb"static" нет, кроме того, что классы нельзя объявить со словом \verb"static" их придется помещать в namespace.
Кроме того, в namespace можно помещать массово в отличие от \verb"static", которым надо помечать каждое имя.

\paragraph{Тонкости с h файлами}

Если вы создаете h файл, то это файл, которым будет кто-то пользоваться.
Так бывает, что вам надо определить вспомогательные классы, которые пользователь видеть не должен и какие-то другие вспомогательные конструкции.
Чтобы не засорять видимость пользователю, предлагается помещать этот код в специальное поле имен \verb"detail" (или даже делать свое специальное имя для каждого случая).
Вот пример
\begin{cppcode}
namespace project {
namespace detail {
void auxiliary_function() {}

struct Proxy {};
}

class A {
  using Proxy = detail::Proxy;
public:
  Proxy get();
};
}
\end{cppcode}
Такой подход позволяет вам контролировать, что видит пользователь и давать ему в руки только те инструменты, которые вы хотите раскрыть для него.
И ему не придется копаться в кишках вашей имплементации.
Не используйте в h файлах anonymous namespace.
Это бесполезно и просто увеличивает количество имен в единицах трансляции.
Кроме того, это может подгадить вашим глобальным ресурсам (потому что такой ресурс теперь в каждой единице трансляции станет локальным, а это скорее всего не то, что вы хотели.).

Бывают ситуации, когда вы можете спрятать вспомогательные типы внутри вашего класса в приватной части.
Однако, вложенные определения классов в плюсах работают с некоторыми ограничениями, которые я не готов обсуждать прямо здесь и сейчас.
Но могу сказать одно, бывают ситуации, когда вы просто не можете имплементировать то, что вы хотите с помощью вложенных классов.
И тогда приходится делать классы не вложенными и так как это детали имплементации, то их хорошо бы спрятать внутри какого-нибудь пространства имен.

\subsubsection{Дефекты языка C++}
\label{section::DefectCpp}

Тут я хочу просто перечислить некоторые важные моменты, которые важно иметь в виду при работе с языком и которые по сути являются страшными недостатками, которые невозможно обойти.
\begin{enumerate}
\item % синтаксис -- говно
Синтаксис C++ сформировался поверх синтаксиса Си.
И так как Си -- это всего лишь высокоуровневый ассемблер без какой-то сверх сложной логики, то для него этот синтаксис не вызывает проблем.
Хотя даже у него есть Однако, в случае C++ усложнение синтаксиса привело к любопытным дефектам.
Например, программу просто невозможно однозначно распарсить.
Вот мои два любимых примера:
\begin{enumerate}
\item Most vexing parse.

\begin{cppcode}
void f(double x) {
  int y(int(x));
}
\end{cppcode}
Вот тут строка 2 может трактоваться одним из двух способов:
\begin{center}
\begin{tabular}{cc}
{
\begin{minipage}{7cm}
Переменной \verb"y" присваиваем значение \verb"x", которое кастуется из \verb"double" к \verb"int":
\begin{cppcode}[numbers=none]
int y = int(x);
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}{7cm}
Объявлена функция \verb"y" с единственным аргументом \verb"x".
\begin{cppcode}[numbers=none]
int y(int x);
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}

\item Привет от синтаксиса шаблонов.
\begin{cppcode}
a < b, c > d;
\end{cppcode}
Вот эту строчку тоже можно распарсить двумя разными способами.
\begin{center}
\begin{tabular}{cc}
{
\begin{minipage}[b]{7cm}
Вначале выполняются два сравнения, а потом оператор запятая, который вычисляет оба выражения слева направо, а потом откидывает результат первого и возвращает результат второго.
\begin{cppcode}[numbers=none]
(a < b), (c > d);
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[b]{7cm}
Это объявлена переменная \verb"d" шаблонного типа \verb"a" с параметрами \verb"b" и \verb"c".
\begin{cppcode}[numbers=none]
a<b, c> d;
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Локально глядя на код эти две ситуации не возможно отличить.
Нужно знать контекст.
И все усложняется, если этот код внутри шаблонного кода, где все имена -- зависимые параметры.
\end{enumerate}

\item % препроцессор -- опасен
Немного о препроцессоре.
Напомним, что у плюсов архаичная система сборки, где единица компиляции -- файл, а метод работы с файлами -- это текстовый препроцессор и его директивами.
Это значит, что перед тем как код вашей программы попадет компилятору его официально предобрабатывает как текст некая другая программа -- препроцессор.
И это может приводить к совершенно непредсказуемым результатам.
Вы будете получать ошибки компилятора, который ругается на код, который вы даже не увидите в программе.
Мой любимый пример, с которым я сам сталкивался, когда собирал одну из сторонних библиотек из исходников.
При сборке проекта по официальной инструкции получаю ошибку компиляции, где компилятор ругается на строчку кода, которой нет в проекте.
После нескольких дней гуглежки нашел решение: <<Нужно зайти в файл некой сторонней библиотеки (не той, которую я собираю, а ту которая используется той, которую я собираю), найти там некую строчку и заменить имя переменной \verb"small" на \verb"little".>> Я когда нашел это, то просто не поверил, что сработает.
И как же я был удивлен, когда после этой правки проект собрался.
Оказывается, официальная версия библиотеки тестировалась на сборку только под Linux.
А под Windows она включала один из заголовочных файлов операционной системы Windows.
А Windows просто обожает вводить новые макросы среди которых был такой:
\begin{cppcode}[numbers=none]
#define small short
\end{cppcode}
И конечно же этот заголовок был подключен до использование сторонней библиотеки, где слово \verb"small" использовалось для имени переменной.
И компилятор выдавал ошибку на строчку вида
\begin{cppcode}[numbers=none]
int short = 0;
\end{cppcode}
Которой конечно же не было в исходном коде.

\item % шаблоны ломают систему сборки
Шаблоны ломают систему сборки плюсов.
Тут хочется сказать сразу две вещи:
\begin{enumerate}
\item Шаблоны ломают систему компиляции плюсов.
Как мы разобрали выше, невозможно делить код шаблонов на заголовочный и имплементацию.

\item Язык шаблонов полный.
А это значит, что на них можно написать любую программу, которая будет исполняться в compile-time.
Например я могу написать какой-нибудь сервер, который будет крутиться в бесконечном цикле и выполнять обработку запросов.
А это значит, что компилятор не может знать заранее остановится компиляция программы или нет, потому что это неразрешимая задача.
Это не так страшно, и решается time лимитами, но все же неприятно.
\end{enumerate}

\item % отсутствие стандартизации почти всего
Важно отметить, что при разработке C++ нужно было усидеть на двух стульях.
С одной стороны -- это низкоуровневый язык наравне с Си, с другой -- все правила языка определены аксиоматически и абстрактно независимо от имплементации.
Но хуже, что многие важные вещи не были стандартизированы.
Вот два важных примера:
\begin{enumerate}
\item STL.
Стандартная библиотека не имеет стандартной имплементации.
Она лишь фиксирует требуемое поведение и интерфейсы.
А это значит, что код разных STL просто не совместим на бинарном уровне.
Потому что одна и та же структура данных может просто по разному лежать в памяти и занимать разное количество байт.

\item Перегрузка функций и операторов а так же введение пространства имен породило еще одну большую беду -- разрешение конфликта имен для линковщика.
Давайте напомним, что линковщик работает с бинарными файлами, в которых все имена глобальные.
Потому если мы имеем функции с одинаковыми именами в коде
\begin{cppcode}
void f(int);
void f(int, double);
namespace A {
int f(char);
}
\end{cppcode}
то нельзя их имена передавать линковщику как есть.
У него не будет способа их отличить.
По простому к имени функции добавляются имена всех scope, где она содержится, и типы всех аргументов.
Эта процедура называется Name Mangling.
Потому линковщик будет видеть три разных названия вместо этих имен.
И как вы понимаете, при сообщении об ошибке о функции на стороне линковщика, вы не увидите привычного имени \verb"f", вы увидите какую-то мешанину из символов, по которой надо будет догадаться, что это за функция.
А самое классное, что сама процедура изменения имени тоже не стандартизирована.
Каждый компилятор использует свою.
У msvc своя закрытая имплементация (у которой правда есть reverse engineering версия), а у gcc используется Itanium.
\end{enumerate}
\end{enumerate}

\subsection{Си и C++}

Дизайн языка C++ изначально планировал, что любая программа на Си должна компилироваться компилятором C++.%
\footnote{И это почти работает.
Точнее есть одно ключевое слово из Си, которое не поддерживается компилятором C++ -- это слово \texttt{restrict}.
Давайте я не буду ничего про него говорить.}
Однако, если вы когда-нибудь настраивали сборку проектов, то заметили, что вы всегда указываете два компилятора -- один для Си, другой для C++.
Возникает вопрос: а зачем?
Если C++ компилятор может компилировать все.
И тут мы приходим в суровый мир продуманного Си, как низкоуровнего языка, и прекрасный мир стихийного развития C++ поверх Си.

\subsubsection{ABI совместимость и Name Mangling}
% ABI и для чего не предназначен С++

Одна из основных идей за двухступенчатой системой компиляции -- модульная структура приложений на уровне бинарного кода.
А именно, мы будем хранить приложение не в виде одного бинарного файла, в виде нескольких бинарных файлов.
И если нам надо обновить какую-то компоненту, то мы можем перекомпилировать только нужный бинарник и подменить его.
Но для такого подхода важно, чтобы на уровне бинарного кода старая и новая имплементация были совместимы.
Такая совместимость в частности предполагает одни и те же имена функций.
И потому, если у вас на уровне бинарного кода есть Name Mangling (смотри раздел~\ref{section::DefectCpp}), который не стандартизирован, то вы просто не можете использовать язык C++ в рамках такой парадигмы.

Давайте вернемся к вопросу зачем нам два компилятора для Си и C++ кода.
Если вы имеете код на Си, то он конечно скомпилируется обоими компиляторами.
Но бинарный файл будет разные.
В случае компилятора Си имена методов будут такими же как их видит программист, а в случае C++ имена будут подвергнуты Name Mangling-у.
Подобная проблема в частности не позволяет слинковаться с методами скомпилированными с помощью Си компилятора.
Действительно
\begin{cppcode}
// c-file 
void f(int) {
...
}
// c++ file
void f(int);

int main() {
  f(5); // linking error
  return 0;
}
\end{cppcode}
Если мы скомпилировали первый файл с помощью Си компилятора на на уровне бинарника имя функции будет \verb"f".
А при компиляции второго файла с помощью C++ компилятора имя объявленной в строчке 6 и вызываемой в строчке 9 функции будет совсем другой, условно пусть будет \verb"_Zfint".
А тогда линковщик не найдет нужную функцию.
Для решения этой проблемы есть специальное ключевое слово: % extern "c"
\begin{cppcode}
// c-file 
void f(int) {
...
}
// c++ file
extern "C" void f(int);

int main() {
  f(5); // OK
  return 0;
}
\end{cppcode}
Теперь для функции \verb"f" в строчке 6 отключен Name Mangling и линковщик сможет понять какое у нее имя в бинарнике после Си компилятора.

\subsubsection{ABI совместимость и отсутствие стандартизации}

Если вы думали, что Name Mangling -- это единственная причина для отсутствия ABI совместимости, то у меня для вас плохие новости.
На этом список не заканчивается.
Если вы хотите ABI совместимость, то вы автоматически не можете использовать STL, даже для одно и того же компилятора, потому что имплементация STL не фиксирована на уровне бинарников.
И есть известная история со строками в STL для gcc.
Изначальная имплементация строк имела copy-on-write оптимизацию, которую потом насильно запретили.
И потому теперь есть две несовместимые на уровне бинарника имплементации STL для gcc, между которыми нужно переключаться специальным макросом.
Но и это не самая большая проблема.
Даже внутри самого языка ничего не стандартизировано.
Вот перечень проблем:
\begin{enumerate}
\item Exception (смотри раздел~\ref{section::Dangerous}).
Данный механизм языка имплементирован по разному на разных компиляторах.
При этом на msvc есть еще возможность переключаться между разными имплементациями исключений по флагу компилятора.

\item RTTI (смотри раздел~\ref{section::Dangerous}).
Имплементация этой фичи тоже не стандартизирована и на разных компиляторах имплементирована по разному.

\item Наследование с виртуальными методами (смотри раздел~\ref{section::Dangerous}).
Имплементация так называемых виртуальных методов также не стандартизирована.
Где и как располагается таблица виртуальных функций, какого она размера и прочие и прочие детали не стандартизированы.
Да и вообще, что должна быть использована именно таблица для виртуальных методов никак в стандарте не указано (хотя все имплементации используют только такой подход).
Тем не менее, конкретное расположение в памяти объектов такого класса может отличаться для разных компиляторов.

\item C-run-time.
Если вы изучали АКОС,%
\footnote{Архитектура компьютера и операционной системы}
то знаете, что точка входа в программу -- функция start, а не main.
Дело в том, что для работы программы на C++ нужны некоторые возможности, которые гарантируются языком, но не операционной системой.
Например использование операторов \verb"new" и \verb"delete".
Эти операции зовут библиотечный код относящийся к так называемому C-run-time-у.
И конечно же его имплементация не стандартизирована.
И у разных компиляторов эти методы работают по-разному и не совместимы.
\end{enumerate}
Все указанные выше проблемы практически уничтожают возможность распространения кода для C++ проектов на уровне бинарников.
Потому подключение сторонних библиотек почти всегда означает сборку библиотеки из исходников для своего проекта, либо использовать пакетный менеджер и надеяться, что ваша конфигурация найдется и не надо будет собирать все с нуля.
Под Windows из-за распространенности компилятора Visual Studio (msvc) вопросы со стандартизации на уровне бинарников в некоторой степени решаются сильно проще, но все же привязаны к версии компилятора.
