\ProvidesFile{Decorators.tex}[Декораторы]

\section{Декораторы}
\label{section::Decorators}

\subsection{Измерение времени выполнения функции}
\label{section::TimeEstimation}

Если по простому, то декоратор, это такой паттерн, который добавляет к какому-либо действию набор автоматически выполняемых действий.
Например, если мы хотим замерить время выполнения функции \verb"f", то мы хотим добавить код засекающий стартовое время перед вызовом функции, а потом посчитать пройденное время после вызова функции
\begin{cppcode}
void f(int, double);

int main() {
  Time start = Timer.now();
  f(5, 42.);
  Time elapsed = Timer.now() - start;
  return 0;
}
\end{cppcode}
Но представьте, что мы теперь хотим измерить в произвольной точке программы время вызова какого-то метода.
Для этого нам придется руками прописывать две строчки кода, которые измеряют время.
Кроме того, если надо вычислить время работы двух методов в одном scope, нам придется называть по разному переменные \verb"start" и \verb"elapsed".
Как минимум тут видно две проблемы с таким подходом:
\begin{enumerate}
\item Мы будем повторять однотипный код

\item Коллизия имен
\end{enumerate}
Кроме этого, у нас есть еще две проблемы, которые я еще буду обсуждать отдельно
\begin{enumerate}
\item Нелокальность.
Дело в том, что строчки 3 и 5 в коде выше связаны друг с другом по смыслу и по выполняемой работе, но они у нас разделены другим кодом.
И да, пусть в этом месте это одна строчка, но это может быть много строчек кода.
И потому чтобы понять смысл строчки 5 надо знать строчку 3, которая могла быть далеко до этого.
Мы разрываем связанную работу.

\item Нарушение уровня абстракции.
Это означает, что в строчке 4 выше вызываем одну функцию, то есть мы даем команду высокого уровня, не производя ее руками.
А в строчках 3 и 5 мы вместо вызова функций, которые делают нужную работу, делаем ее прям тут же в коде руками.
То есть строчки 3 и 5 выполняют более мелкую работу, чем строчка 4.
\end{enumerate}
Кроме того, важно отметить, что мы не хотим лезть внутрь функции \verb"f".
Во-первых, это не решит проблемы с повторением кода, если мы захотим измерить время работы другой функции.
Во-вторых, это может быть сторонняя функция, которая нам не доступна.

Для автоматизации процесса измерения времени предлагается сделать очень простую вещь: давайте заведем промежуточную функцию, которая будет выполнять всю нужную работу по вычислению времени, и звать функцию \verb"f", а именно так
\begin{cppcode}
void f(int, double);

void time_of_f(int x, double y) {
  Time start = Timer.now();
  f(x, y);
  Time elapsed = Timer.now() - start;
}

int main() {
  time_of_f(5, 42.);
  return 0;
}
\end{cppcode}
Теперь мы всю работу по измерению времени убрали в отдельный метод.
Теперь надо лишь сделать ее generic, то есть сделать так, чтобы не было зависимости от конкретной функции \verb"f".
Передать функцию \verb"f" в метод по измерению времени можно двумя способами: в run-time и в compile-time.
Делается это так
\begin{cppcode}
// run-time
template<class F, class... Args>
void rtime_of(F f, Args&&... args) {
  Time start = Timer.now();
  f(std::forward<Args>(args)...);
  Time elapsed = Timer.now() - start;
  // print the time
}

// compile-time
template<auto F, class... Args>
void ctime_of(Args&&... args) {
  Time start = Timer.now();
  F(std::forward<Args>(args)...);
  Time elapsed = Timer.now() - start;
  // print the time
}

int main() {
  // run-time
  rtime_of(f, 5, 42.);
  // compile-time
  ctime_of<f>(5, 42.);
  return 0;
}
\end{cppcode}
Принципиальная разница между этими подходами в том, что в первом случае мы можем передавать не только функции, но и любой функтор (то есть объект, у которого перегружен оператор \verb"operator()").
Однако, в этом случае лучше сделать perfect forwarding и самого функтора так
\begin{cppcode}
template<class F, class... Args>
void rtime_of(F&& f, Args&&... args) {
  Time start = Timer.now();
  std::forward<F>(f)(std::forward<Args>(args)...);
  Time elapsed = Timer.now() - start;
  // print the time
}
\end{cppcode}
Либо надо считать, что функторы всегда легкие и передавать копию.
Второй же способ удобнее тем, что вызов \verb"f(5, 42.);" нужно заменить на \verb"ctime_of<f>(5, 42.);", что делается просто через автозамену ну и компилятор не будет звать метод по указателю.

Кроме того, если вы собираетесь логировать время куда-то, можно добавить дополнительные аргументы для сообщения или другой информации.
\begin{cppcode}
template<class F, class... Args>
void time_of(F f, const char* msg, Args&&... args) {
  Time start = Timer.now();
  f(std::forward<Args>(args)...);
  Time elapsed = Timer.now() - start;
  std::cout << msg << ", time = " << elapsed.inSeconds() << '\n';
}

int main() {
  time_of(f, "f(5, 42.)", 5, 42.);
}
\end{cppcode}

\subsection{Оператор \texttt{operator->}}

Теперь давайте сделаем все то же самое, только теперь вместо времени работы глобальной функции хочется замерить время работы метода у объекта какого-то класса, то есть хотим автоматизировать процесс:
\begin{cppcode}
struct A {
  void f(int, double) const;
};

int main() {
  A a;
  Time start = Timer.now();
  a.f(5, 42.);
  Time elapsed = Timer.now() - start;
  return 0;
}
\end{cppcode}
Подобные трюки делаются с помощью перегрузки оператора \verb"operator->".
Но для начала давайте поймем как он работает.
Когда компилятор видит выражение
\begin{cppcode}
a->f(5, 42.);
\end{cppcode}
То он проверяет что стоит слева от оператора стрелки и тут есть следующие варианты:
\begin{enumerate}
\item Слева стоит указатель
\begin{cppcode}
struct A {
  void f(int, double) const;
};

int main() {
  A a;
  A* ptr = &a;
  ptr->f(5, 42.);
  return 0;
}
\end{cppcode}
В этом случае если это указатель на класс, который содержит метод \verb"f", то строчка 8 эквивалентна вызову
\begin{cppcode}
a.f(5, 42.);
\end{cppcode}
Если же это указатель на класс, где нет метода \verb"f" с нужной сигнатурой или указатель на встроенный тип, то это ошибка компиляции.
\begin{cppcode}
struct A {
  void f(int) const;
};

int main() {
  A a;
  A* ptr = &a;
  ptr->f(5, 42.); // compilation error
  int x = 5;
  int* p = &x;
  x->f(5, 42.); // compilation error
  return 0;
}
\end{cppcode}

\item Слева стоит объект класса, у которого есть перегруженный оператор \verb"operator->".
\begin{cppcode}
struct A {
  void f(int, double) const;
};

struct B {
  A* operator->() const;
};

int main() {
  B b;
  b->f(5, 42.);
}
\end{cppcode}
В этом случае для \verb"b" вызывается перегруженный оператор \verb"operator->", а потом к результату применяется рекурсивно вызов оператора стрелка, то есть происходит следующее:
\begin{cppcode}
int main() {
  (b.operator->())->f(5, 42.);
}
\end{cppcode}
В данном случае вместо \verb"b.operator->()" подставляется указатель на \verb"A" и потом по первому правилу зовется метод класса \verb"A".
Оператор \verb"operator->" не обязан возвращать указатель, он может вернуть объект другого класса, у которого все еще перегружен оператор стрелка.
То есть может быть следующая цепочка:
\begin{cppcode}
struct A {
  void f(int, double) const;
};

struct B {
  A* operator->() const;
};

struct C {
  B operator->() const;
};

int main() {
  C c;
  c->f(5, 42.);
}
\end{cppcode}
В этом случае происходит следующее.
В начале для объекта \verb"c" вызывается его перегруженный оператор стрелка, который вернет объект класса \verb"B".
После для него вызовется его перегруженный оператор стрелка и он вернет указатель на \verb"A".
И уже последний вызов позовет по указателю метод \verb"f" с указанными параметрами.
То есть этот вызов будет означать
\begin{cppcode}
int main() {
  ((c.operator->()).operator->())->f(5, 42.);
}
\end{cppcode}
Такие вызовы лево ассоциативны по стрелкам и допускают любую глубину рекурсии.
Главное, чтобы в конце последний оператор \verb"operator->" возвращал указатель.

\item Если же оператор \verb"operator->" возвращает класс, у которого не перегружен оператор стрелка \verb"operator->", то это ошибка компиляции.
\end{enumerate}

\subsection{Измерение времени выполнения метода класса}

Теперь вернемся к нашей задаче по автоматизации измерения времени вызова метода.
Пусть у нас есть следующий класс
\begin{cppcode}
struct A {
  void f(int, double) const;
};
\end{cppcode}
В начале, прежде чем замерять время, создадим следующий вспомогательный класс для получения доступа к методам \verb"A":
\begin{cppcode}
template<class T>
class Ptr {
public:
  Ptr(T* ptr) : ptr_(ptr) {}
  T* operator->() const {
    return ptr_;
  }
private:
  T* ptr_;
};
\end{cppcode}
Теперь мы можем писать следующий код
\begin{cppcode}
A a;
auto ptr = Ptr(&a);
ptr->f(5, 42.);
//or
Ptr(&a)->f(5, 42);
\end{cppcode}
Давайте проанализируем как работает строчка 5.
В ней в начале создается временный объект \verb"Ptr(&a)".
После чего у него вызывается оператор \verb"operator->", который возвращает указатель на объект \verb"a".
После чего у объекта \verb"a" вызывается метод \verb"f(5, 42.)".
И после этого вызова в конце этой строчке вызывается деструктор временного объекта \verb"Ptr(&a)".
Язык гарантирует, что все временные выражения в одной строке живут до конца жизни всего выражения в строке.
Это нужно, чтобы указатель \verb"ptr_", который возвращается перегруженным оператором \verb"operator->", существовал в момент обращения к нему.

Теперь ясно, что до выполнения функции вызывается конструктор временного объекта, а после выполнения -- его деструктор.
И есть соблазн добавить код по измерению времени именно в них, то есть написать следующее
\begin{cppcode}
template<class T>
class Ptr {
public:
  Ptr(T* ptr) : ptr_(ptr), start_(Timer.now()) {}
  ~Ptr() {
    Time elapsed = Timer.now() - start_;
    // print elapsed time
  }
  T* operator->() const {
    return ptr_;
  }
private:
  T* ptr_;
  Time start_;
};
\end{cppcode}
Тогда действительно строчка кода
\begin{cppcode}
Ptr(&a)->f(5, 42.);
\end{cppcode}
замерит время вызова функции \verb"f".
Однако, если вы напишете следующее
\begin{cppcode}
int main() {
  A a;
  auto ptr = Ptr(&a);
  ...
  ptr->f(5, 42.);
  ...
  return 0;
}
\end{cppcode}
то теперь вы измерите время от строчки 3 (создание \verb"ptr") и до выхода из \verb"main", то есть до строчки 8 (где вызовется деструктор \verb"ptr").
И это будет не то, что вы ожидаете.
И ничто не запрещает так использовать этот шаблонный класс обертку.
А раз класс можно использовать неправильно и даже не догадываться об этом, то лучше переделать его дизайн.
Проблема тут в том, что объект \verb"ptr" может жить дольше, чем время вызова метода.
Потому надо вклинить еще один временный прокси-объект, который будет создаваться только в момент обращения к оператору \verb"operator->".
И делается это так, наивную имплементацию выше помещаем в отдельный прокси объект%
\footnote{Тут можно сделать конструктор приватным, а класс \verb"Timed<T>" сделать \verb"friend", чтобы никто не мог просто так создать прокси класс.
Так же его стоит спрятать либо внутрь класса \verb"Timed<T>", либо внутрь служебного \verb"namespace detail".}
\begin{cppcode}
template<class T>
class Proxy {
public:
  Proxy(T* ptr) : ptr_(ptr), start_(Timer.now()) {}
  ~Proxy() {
    Time elapsed = Timer.now() - start_;
    // print time
  }
  T* operator->() const {
    return ptr_;
  }
private:
  T* ptr_;
  Time start_;
};
\end{cppcode}
После чего делаем наш декоратор
\begin{cppcode}
template<class T>
class Timed {
public:
  Timed(T* ptr) : ptr_(ptr) {}
  Proxy<T> operator->() const {
    return Proxy(ptr_);
  }
private:
  T* ptr_;
};
\end{cppcode}
И теперь мы можем написать
\begin{cppcode}
A a;
Timed(&a)->f(5, 42.);
// or
auto ptr = Timed(&a);
ptr->f(5, 42);
...
ptr->f(5, 42);
\end{cppcode}
Давайте разберемся как работает код выше.
В строчке 2 произойдет следующая последовательность действий
\begin{enumerate}
\item В начале создается временный объект \verb"Timed(&a)", который в конструкторе запоминает адрес \verb"a".

\item Теперь вызывается оператор \verb"operator->" для временного объекта, который возвращает временный объект типа \verb"Proxy<A>".
В его конструкторе запоминается адрес хронящийся в \verb"Timed<A>" объекте (то есть адрес \verb"a") и текущее время.

\item Теперь вызывается оператор \verb"operator->" для \verb"Proxy<A>", который просто дергает метод \verb"f(5, 42.)".

\item Теперь разрушается временный объект \verb"Proxy<A>", который в деструкторе замеряет текущее время и высчитывает прошедшее.

\item Теперь умирает временный объект \verb"Timed<A>".
\end{enumerate}

Строчки 5 и 7 работают аналогично за исключением того, что в них не зовутся конструкторы и деструкторы долгоживущего объекта \verb"Timed<A>".
Но при каждом обращении по стрелке у нас создается ровно один вспомогательный прокси объект, который и занимается работой по измерению времени.

Теперь можно обвешивать декоратора функционалом, который нам нужен.
Что можно настроить
\begin{enumerate}
\item Можно передать для исполнения любую функцию для вызова в конструкторе.

\item Можно передать для исполнения любую функцию для вызова в деструкторе.

\item Можно передать любые дополнительные данные.
\end{enumerate}
Например, можно передать метод куда именно печатать сообщение о времени и строку с сообщением, которую надо добавить к измеренному времени.

\subsection{Временные якоря}

Раз уж мы затронули вопрос измерения времени, то давайте обсудим еще одну идею, которую можно использовать для измерения времени.
Например, если вы хотите измерить время работы какого-то scope.
\begin{cppcode}
void f(int x, double y) {
  auto t = TimeAnchor();
  ...
} // ~TimeAnchor() counts the time since the constructor was called
\end{cppcode}
Если вам надо измерить время с какой-то точки времени до момента выхода из scope и таких точек может быть много (например, может быть несколько \verb"return" выражений в теле функции), то можно написать код как выше, который в стиле RAII (смотри~\ref{section::RAII}) захватит время при создании и вычислит прошедшее при разрушении якоря.
Код для якоря выглядит как-то так
\begin{cppcode}
class TimeAnchor {
public:
  TimeAnchor() : start_(Timer.now()) {}
  ~TimeAnchor() {
    Time elapsed = Timer.now() - start_;
    // print elapsed time
  }
private:
  Time start_;
};
\end{cppcode}
Можно добавить функционал для временного якоря, например добавить метод измерения времени до текущего момента.
При этом можно как отключить замер времени при уничтожении, так и настроить его, чтобы он был с текущего момента или с самого начала времени жизни якоря.
Можно добавить разные методы куда выводить результат и кучу других модификаций, какие только захотите.
