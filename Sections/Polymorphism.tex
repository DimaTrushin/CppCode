\ProvidesFile{Polymorphism.tex}[Полиморфизм]


\section{Полиморфизм}
\label{section::Polymorphism}

\subsection{Что это и каким оно бывает}

По определению полиморфизм означает, что один и тот же текст (=код) делает разные вещи.
Например в языке C++ можно написать строчку кода:
\begin{cppcode}
z = x + y;
\end{cppcode}
В зависимости от типа переменных \texttt{x}, \texttt{y} и \texttt{z} эта строчка будет вызывать разные процессорные инструкции даже для встроенных типов \texttt{int}, \texttt{double}, не говоря уже о перегруженных операторах для классов.
Потому технически, это пример полиморфного поведения кода.
Обычно про такие примеры не говорят, но и полиморфизм обычно определяют очень узко, привязывая его только к определенной имплементации или инструменту языка, а не к поведению.
На мой взгляд на языковые вещи надо смотреть не с точки зрения имплементации, а с точки зрения поведения.

Прежде чем двигаться дальше я хочу сделать полезное замечание.
Языки программирования по отношению к типам данных бывают трех типов:
\begin{itemize}
\item Статическая типизация.
Тип переменной не может измениться во время исполнения.

\item Динамическая типизация.
Тип переменной может поменяться во время исполнения.

\item Без типизации.
Понятия типа просто не существует.
\end{itemize}
Язык C++ относится к языкам со статической типизацией.
Чем мы выше в этом списке, тем надежнее механизмы языка, тем больше гарантий вам может теоретически предоставить компилятор и инструменты разработки.
Чем ниже в этом списке, тем более гибким является язык.
Это всегда размен надежности на гибкость.
Если в языке нет типизации или динамическая типизация, то все поведение полиморфно.
Возьмите для примера язык Python с динамической типизацией.
Если у вас есть функция вида
\begin{pythoncode}
def function(a):
  a.f()
\end{pythoncode}
То не важно какого типа аргумент \texttt{a} функции \texttt{function}.
Единственное что нужно для исполнения этого кода, чтобы для \texttt{a} имела смысл строчка вызова \texttt{a.f()} и все.
В эту функцию можно подставлять любой объект, у которого можно вызвать метод \texttt{f} без аргументов.
А потому про полиморфизм имеет смысл говорить только в языках со статической типизацией, где по определению вы не можете подставить вместо переменной одного типа переменную другого типа.
Точнее, в языках со статической типизацией возникает следующий вопрос: <<как добиться полиморфного поведения, не ломая систему типов?>>

\paragraph{Полиморфизм и функции}

Давайте для начала обсудим какие есть механизмы в C++ для полиморфизма.
\begin{enumerate}
\item Перегрузка функций, методов и операторов.
Да, это тоже полиморфизм и именно с этого примера я начал этот раздел.
\begin{cppcode}
void f(int);
void f(double);
void f(A);

int main() {
  int x = 1;
  f(x);
  double y = 2.;
  f(y);
  A a;
  f(a);
 return 0;
}
\end{cppcode}
Как вы видите, функция с именем \texttt{f} может быть вызвана для переменных разных типов.
То есть один и тот же код вида \texttt{f(...)} может выполнять разные действия.

Важно отметить, что в данном случае у нас есть полиморфзим на стороне пользователя функции \texttt{f}, но не на стороне автора функции \texttt{f}.
Действительно, перегрузка требует от вас определить все три вида функции, а потому вы обязаны написать все три имплементации и у вас нет возможности использовать один и тот же код для этого (я не говорю сейчас про баловство с макросами, потому что это в целом издевательство над текстом программы).
\begin{cppcode}
void f(int) {
  std::cout << "f(int);\n";
}
void f(double) {
  std::cout << "f(double);\n";
}
void f(A) {
  std::cout << "f(A);\n";
}
\end{cppcode}

\item Шаблоны функций, переменных и классов.
Этот вид полиморфизма обычно называют compile-time polymorphims.
Благодаря шаблонам вы можете добиться полиморфизма и на стороне пользователя кода и на стороне автора кода, то есть когда и пользователь и автор кода пишет один код, который делает разную работу.
\begin{cppcode}
template<class T>
void f(T);

int main() {
  int x = 1;
  f(x);
  double y = 2.;
  f(y);
  A a;
  f(a);
}
\end{cppcode}
В этом случае программист может написать следующую имплементацию
\begin{cppcode}
template<class T>
void f(T) {
  std::cout << "f(" << ClassPrintName<T> << ");\n";
}
\end{cppcode}
Здесь \texttt{ClassPrintName} -- это вспомогательный шаблон, который перерабатывает класс в читаемое имя класса в формате строки для отображения.
По сути шаблоны -- это умная кодогенерация, которая делается механизмами языка.

\item Run-time polynorphism.
Это вид полиморфизма относится к ситуации, когда вы хотите менять поведение кода во время исполнения, то есть что именно будет исполнено не определяется на этапе компиляции кода.
Например, когда вы хотите поменять поведение кода в зависимости от ввода пользователя или от возможностей железа, на котором исполняется программа.
Если вы думаете, что run-time polymorphism это сугубо фича объектно ориентированных языков программирования, то вы глубоко ошибаетесь.
Даже в языке Си можно добиться полиморфзного поведения во время исполнения и имплементация всех операционных систем использует этот механизм.
Для этого используются указатели на функции (код ниже содержит псевдонимы типов из C++ для удобства чтения кода)
\begin{cppcode}
void f1();
void f2();

using Signature = void();
using FPtr = Signature*;
FPtr f = &f1;

int main() {
  f(); // f1 executes
  f = &f2;
  f(); // f2 executes
  return 0;
}
\end{cppcode}
Обратите внимание, что в коде выше мы подменяем указатель на функцию и в зависимости от этого вызов \texttt{f()} приводит к выполнению разных функций.
\end{enumerate}

\paragraph{Полиморфизм и классы}

Теперь давайте обсудим, что означает полиморфизм на уровне классов, а не функций.
В этом случае есть две задачи:
\begin{enumerate}
\item Мы хотим ссылаться на переменные разных типов и уметь звать у них методы с фиксированными названиями.
Например:
\begin{cppcode}
struct A {
  void f() const;
};

struct B {
  void f() const;
};

void f(Pointer ptr) {
  ptr->f();
}

int main() {
  A a;
  f(&a);
  B b;
  f(&b);
}
\end{cppcode}
Здесь \texttt{Pointer} -- это какой-то пока какой-то нам неизвестно как устроенный класс, который играет роль указателя, но только в него можно положить указатель на любой класс, в котором есть метод \texttt{f}, который можно вызвать без аргументов.
Я не знаю, есть ли у этого подхода стандартное название, но я бы по аналогии со следующим пунктом назвал это <<стирающим указателем>>, потому что мы стираем информацию о типе объекта, на который указывает <<указатель>>, и все что нам доступно -- это вызов методов из поддерживаемого интерфейса стирающего указателя.

\item Мы хотим хранить в переменной объекты разных типов и обращаться к их методам по фиксированным названиям.
Например мы хотим написать что-то в таком духе
\begin{cppcode}
struct A {
  void f() const;
};

struct B {
  void f() const;
};

int main() {
  std::vector<Any> vec;
  vec.push_back(A());
  vec.back().f();
  vec.push_back(B());
  vec.back().f();
}
\end{cppcode}
В этом случае \texttt{Any} -- это тип, в который можно положить любую переменную любого типа, главное, чтобы в ее интерфейсе был метод \texttt{f}, который можно вызвать без аргументов.
Такой подход называется <<стирающим типом>> или по английски <<Type Erasure>>.
В этом случае тип \texttt{Any} как раз является стирающим типом, потому что при присваивании ему, стирается информация о типе исходной переменной, и единственный способ взаимодействовать с ней у нас остается лишь посредством интерфейса, который поддерживает стирающий тип.
При этом статическая типизация языка позволяет проверять во время компиляции, можно ли положить данную переменную внутрь стирающего типа или нет и выдать ошибку компиляции, если нельзя.
\end{enumerate}

\paragraph{Важное замечание}

В этом месте я хочу сделать важное замечание, когда я говорю про <<общий интерфейс>>, я НЕ имею в виду наследование или интерфейсы с виртуальными методами.
Я имею в виду публичные методы класса и все.
То есть стирающие типы и указатели не требуют от вас калечить код всех возможных классов, чтобы они стали используемыми в коде, а наоборот, суть в том, что мы хотим, навесить интерфейс поверх класса неинтрузивно (то есть не вмешиваясь в код класса).
Бывает два вида навешивания интерфейса:
\begin{enumerate}
\item Утиный принцип.
Мы можем присвоить к \texttt{Pointer} из примера выше любой адрес любого объекта, главное, чтобы через этот указатель можно было позвать нужные методы.
То есть если синтаксически использование возможно, то оно разрешено без каких-то дополнительных ограничений.
Этот принцип похож на поведение Python с его динамической типизацией, когда вы можете положить в переменную, что хотите, главное чтобы синтаксически код был корректным.

\item Явное объявление присоединяемого интерфейса.
В этом случае где-то в коде должна быть строчка, которая говорит, что мы разрешаем данному классу присоединяться к данному интерфейсу.
Данное поведение можно встретить в таких языках как Rust, когда вы присоединяете trait-ы к структуре.
\end{enumerate}
Обратим внимание, что имплементация стирающих типов не обязана использовать наследование в каком-либо виде, но так исторически сложилось, что именно наследование с виртуальными методами рассматривается как тот самый настоящий run-time polymoprhism.
Но это просто ошибка.

\subsection{Важный пример}

Я решил, что прежде чем рассказывать про все методы по одиночке, я хочу рассмотреть конкретный пример, на котором буду обсуждать дальнейшее.
Предположим, что у вас есть некоторая функция \texttt{f}, которая внутри себя последовательно вызывает три функции \texttt{f1}, \texttt{f2} и \texttt{f3}.
И предположим, что вы хотите вместо функции \texttt{f2} использовать другие функции.
Вот как бы это решение выглядело на Python:
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{4cm}
\begin{pythoncode}[numbers = none, linewidth=5cm]
## script.py

def f1():
  pass
def f2():
  pass
def f3():
  pass
def g():
  pass
\end{pythoncode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{6cm}
\begin{pythoncode}[numbers = none, linewidth=5.5cm]
def function():
  f1()
  function.f()
  f3()
function.f = f2

def main():
  function()
  funciton.f = g
  function()
\end{pythoncode}
\end{minipage}
}
\end{tabular}
\end{center}
Вот как бы это решение выглядело на Си:
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{5.5cm}
\begin{cppcode}[numbers = none, linewidth=5.5cm]
void f1();
void f3();

using Signature = void();
using FPtr = Signature*;
FPtr f = &f2;

void function() {
    f1();
    f();
    f3();
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{5cm}
\begin{cppcode}[numbers = none, linewidth=5cm]
#include "Function.h"

void g() {
}


int main() {
  function();
  f = &g;
  function();
  return 0;
}
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}
Предыдущее решение вполне подходит и для C++, но если метод \texttt{f} может использовать внутреннее состояние, то есть более удачное решение на C++:
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{5.5cm}
\begin{cppcode}[numbers = none, linewidth=5.5cm]
struct Function {
  static void f1();
  static void f2();
  static void f3();
  void operator()() const {
    f1();
    f();
    f3();
  }
  std::function<void()> f = f2;
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{5cm}
\begin{cppcode}[numbers = none, linewidth=5cm]
#include "Function.h"

void g() {}

int main() {
  Function function;
  function();
  function.f = g;
  function();
  return 0;
}
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}
Ну и конечно же классическое решение на C++, которое вы найдете в любой книжке про полиморфизм:
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{5cm}
\begin{cppcode}[numbers = none, linewidth=5cm]
// Function.h

struct Function {
  static void f1();
  static void f2();
  static void f3();
  void operator()() const {
    f1();
    f();
    f3();
  }
  virtual void f() const {
    f2();
  }
  virtual ~Function();
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{5.5cm}
\begin{cppcode}[numbers = none, linewidth=5.5cm]
struct FunctionG : Function {
  static void g();
  void f() const {
    g();
  }
};

int main() {
  Function* f = new Function();
  (*f)();
  delete f;
  f = new FunctionG();
  (*f)();
  delete f;
  return 0;
}
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}
Уже сейчас вы можете оценить как минимум сложность по количеству написания кода для решения задачи каждым из методом.
Дальнейшее изложение я хочу начать с обсуждения классического решения, как им предполагается пользоваться, как оно работает и почему оно является плохим во всех возможных смыслах.
После я перейду к обсуждению стирающих указателей и типов с объяснением того, как должна выглядеть имплементация.


\subsection{Классический подход и наследование с виртуальными методами}
\label{section::ClassicPolymorphism}

Давайте я начну с описания того, что мы вообще хотим сделать.
Мы хотим добиться полиморфного поведения для классов, а именно, мы хотим, чтобы методы класса с одними и теми же именами во время исполнения могли исполнять разный код.
Для этого в языке C++ предусмотрен специальный механизм -- наследование с виртуальными методами.
В начале мы заводим класс-интерфейс, в котором фиксируем интересующий нас публичный интерфейс
\begin{cppcode}
struct Interface {
  virtual void f() const = 0;
};
\end{cppcode}
После чего, если мы хотим, чтобы класс подходил под этот интерфейс, мы должны прикрепить этот интерфейс к нужному классу.
Происходит это путем наследования ОТ интерфейса вот так:
\begin{cppcode}
struct A : Interface {
  void f() const override { /*implementation*/ }
};

struct B : Interface {
  void f() const override { /*implementation*/ }
};
\end{cppcode}
Тут есть две проблемы.
Это точно не утиный принцип, но это еще не большая беда.
Главная проблема такого соединения -- мы не интерфейс прицепляем к классу, а класс к интерфейсу.
То есть мы делаем зависимость не в ту сторону, в которую хотим.
Проблемы такого соединения интерфейса и класса мы обсудим ниже, а пока логическая диаграмма наследования между классами:
\begin{center}
\[
\xymatrix{
  {}&{\text{Interface}}
   	{\save
   [].[]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}\\
  {\text{A}}\ar[ur]+(-1, -3)
 	{\save
   [].[]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{\text{B}}\ar[ul]+(1, -3)
   {	\save
   [].[]*+[F-:<3pt>]\frm{}
   \restore
	}
}
\]
\end{center}
Теперь, чтобы полиморфизм работал, нам нужно создать объект типа \texttt{A}, но ссылаться на него как на объект типа \texttt{Interface}.
Если нам не надо владеть объектами, то это можно сделать так
\begin{cppcode}
void f(Interface* ptr) {
  ptr->f();
}

int main() {
  A a;
  f(&a); // casts A* to Interface*
  B b;
  f(&b); // casts B* to Interface*
}
\end{cppcode}
Если же мы напишем так
\begin{cppcode}
int main() {
  A a;
  Interface obj = a; // compilation error
}
\end{cppcode}
То так как класс \texttt{Interface} содержит чисто виртуальный метод (тот что равен нулю при объявлении), то невозможно создать объект такого типа и это ошибка компиляции.
Давайте поменяем определение так
\begin{cppcode}
struct Interface {
  virtual void f() const {}
};
\end{cppcode}
Теперь можно написать код вида
\begin{cppcode}
A a;
a.f(); // calls A::f()
Interface obj = a;
obj.f(); // calls Interface::f()
B b;
b.f(); // calls B::f()
obj = b;
obj.f(); // calls Interface::f()
\end{cppcode}
Как мы видим, в этом случае полиморфного поведения нет.
Вся причина в том, что оператор присваивания \texttt{obj = a} строит по объекту типа \texttt{A} объект типа \texttt{Interface}, то есть от класса \texttt{A} отрезается его базовая часть и складывается внутрь \texttt{obj}.
И мы лишаемся таким образом полиморфного поведения.
Обойти эту проблему на уровне value semantics не возможно.
Нам придется работать с голыми указателями.
А именно, нам надо создать где-то объект типа \texttt{A}, и потом кастовать его адрес к адресу на \texttt{Interface}.
И вот в этом случае обращение к методу \texttt{f} через \texttt{Interface} гарантирует вызов \texttt{A::f}.
Теперь пользоваться всем этим можно так
\begin{cppcode}
int main() {
  std::unique_ptr<Interface> ptr = std::make_unique<A>();
  ptr->f(); // calls A::f()
  ptr = std::make_unique<B>(); // calls ~Interface before storing new value
  ptr->f(); // calls B::f()
  return 0;
} // ~ptr calls ~Interface
\end{cppcode}
Однако, в 4-ой строке перед тем, как положить новое значение в \texttt{ptr}, будет уничтожено старое значение, а именно вызывается \texttt{\~{}Interface}.
Но по указателю лежит объект класса \texttt{A}, а значит вызовется не верный деструктор.
Аналогичная проблема есть в 7-ой строке при выходе из \texttt{main} вызывается деструктор для \texttt{ptr}, который опять же вызовет деструктор для \texttt{Interface}.
Для решения этой проблемы надо сделать деструктор в \texttt{Interface} тоже виртуальным, чтобы вызвался нужный деструктор.
\begin{cppcode}
struct Interface {
  virtual void f() const = 0;
  virtual ~Interface() = default;
};
\end{cppcode}
Вот теперь это безобразие заработает как надо.
Но не как мы хотели.
Давайте обсудим, что же не так с этим решением.

\paragraph{Проблемы классического решения}
\begin{enumerate}
\item Первое и самое главное: мы делаем не то, что хотим.
А именно, мы хотим к любому типу привесить интерфейс, но делаем это наоборот, мы к интерфейсу привешиваем тип.
А именно у нас зависимость $\texttt{Interface}\leftarrow\texttt{A}$, а не наоборот.
В частности, класс \texttt{A} начинает зависеть от интерфейса, а не наоборот.
Мы не можем подвесить интерфейс к классу постфактум, если нет доступа к коду класса, то нет возможности к нему подвесить интерфейс.
Для того, чтобы обойти эту проблему придется писать адаптеры.

\item Мы ломаем логику зависимостей в кодовой базе.
Так как у нас класс \texttt{A} зависит от \texttt{Interface}, то мы инклудим в файл с классом \texttt{A} файлы, необходимые для работы интерфейса, а не самого класса.

\item Вместо написания самого класса \texttt{A}, мы теперь должны думать про виртуальные методы.
А именно, мы теперь для каждого интерфейса должны писать лишний код, который делает простой и понятный класс \texttt{A}, который до этого имел простую и понятную структуру, сложным и непонятным.

\item Наличие чистых виртуальных функций не согласовано с оператором присваивания.
А потому нам приходится работать с объектами через указатели.

\item Наличие виртуальных функций -- удар по производительности даже если вы используете класс не полиморфно.
Вы всегда платите цену за наличие интерфейса.

\item Работа с объектами через указатели означает, что мы поменяли семантику кода.
Если до использования интерфейсов мы могли оперировать переменными и вызывать у них методы, то теперь мы оперируем ссылками и указателями.

\item Работа с объектами через указатели означает так же, что мы должны аллоцировать объекты на куче.
А это значит, что пользователь полиморфного класса обязан следить за памятью и lifetime-ом объекта.
Нужно заворачивать объекты в адаптеры вроде \texttt{unique\_ptr}.

\item Потеря value semantics и использование прямых указателей в коде побуждает в объектах ссылаться друг на друга или иметь общее состояние через \texttt{shared\_ptr}.
Это порождает случайные связи между совершенно разными не связанными кусками кода.
Код становится сложно оценивать из локальных соображений.
Код становится сложно поддерживаемым.
Начинаются проблемы с синхронизацией и lifetime-ами.
\end{enumerate}

Если вернуться к примеру из предыдущего раздела
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{5cm}
\begin{cppcode}[numbers = none, linewidth=5cm]
// Function.h

struct Function {
  static void f1();
  static void f2();
  static void f3();
  void operator()() const {
    f1();
    f();
    f3();
  }
  virtual void f() const {
    f2();
  }
  virtual ~Function();
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{5.5cm}
\begin{cppcode}[numbers = none, linewidth=5.5cm]
struct FunctionG : Function {
  static void g();
  void f() const {
    g();
  }
};

int main() {
  Function* f = new Function();
  (*f)();
  delete f;
  f = new FunctionG();
  (*f)();
  delete f;
  return 0;
}
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}
То можно добавить еще одну проблему.
Конкретно в этом случае мы не можем использовать любую функцию \texttt{g}.
Нам приходится заворачивать код этой функции внутрь класса наследника.
Потому что теперь объект -- это то же самое, что наследник.
То есть поведение контролируется НЕ переменной класса, а самим классом.
Все переменные одного класса имеют одинаковое поведение и чтобы поменять поведение, надо писать аж целый новый класс.

\subsection{Стирающие ссылки}
\label{section::RefErasure}

Так получилось, что даже в языке Си есть стирающие указатели.
Это называется \texttt{void*}.
Действительно, вы можете кастануть указатель на любой класс \texttt{A*} в указатель типа \texttt{void*}.
Однако, это стирающий тип с пустым интерфейсом в том смысле, что у вас нет возможности воспользоваться никакими методами этого класса.
Все что вы можете -- это кастануть обратно к исходному типу и лишь после этого воспользоваться данными по указателю.
То есть в языке уже есть стирающий указатель, но с пустым интерфейсом, и теперь наша задача поверх него сделать стирающий указатель но с фиксированным интерфейсом.

\subsubsection{Ожидаемое поведение}

\paragraph{Что мы хотим}

В идеале мы хотим следующее поведение.
\begin{center}
\begin{tabular}{cc}
{
\begin{minipage}[\baselineskip]{9cm}
\begin{cppcode}[numbers = none]
interface A {
public:
  void f(int) const;
};

class B {
public:
   void f(int) const { /*implementation*/ }
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{5cm}
\begin{cppcode}[numbers = none]
void g(A a) {
  a.f(5); // a->f(5);
}

int main() {
  B b;
  g(b); // g(&b);
  return 0;
}
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
То есть мы бы хотели задать интерфейс \texttt{A}, который играет роль указателя, такой, что указатель на любой объект (или ссылка на любой объект), который можно использовать с этим интерфейсом биндилась на объект класса \texttt{A}.
Давайте проговорим все основные пункты этого решения:
\begin{enumerate}
\item Нет синтаксической связи между \texttt{A} и \texttt{B}

\item \texttt{A} и \texttt{B} связаны именем функции и сигнатурой

\item Размер \texttt{A} порядка указателя ($\simeq 1-2$ указателя)
\end{enumerate}
Опционально можно добавить еще несколько фич:
\begin{enumerate}
\item \texttt{A} знает жив ли объект

\item \texttt{A} следит за адресом объекта
\end{enumerate}

\paragraph{Более правдоподобная картина}

Ключевое слово \texttt{interface} мы будем симулирвоать шаблонным классом, а вот интерфейс настраивать шаблонным параметром.
Опять же приблизительное идейное решение выглядит так:
\begin{center}
\begin{tabular}{cc}
{
\begin{minipage}[\baselineskip]{6cm}
\begin{cppcode}[numbers = none]
class A {
public:
  virtual void f(int) const = 0;
};

using C = Interface<A>;

class B {
public:
   void f(int) const;
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{4cm}
\begin{cppcode}[numbers = none]

void g(C a) {
  a->f(5);
}

int main() {
  B b;
  g(&b);
  return 0;
}

\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Таким образом:
\begin{itemize}
\item Шаблонный класс \texttt{Interface} скрывает весь boilerplate code и симулирует поведение ключевого слова \texttt{interface}

\item Интерфейс вычленяется из адреса объекта (можно настроить)

\item К сожалению прям так пока нельзя, но можно почти так.
\end{itemize}

\paragraph{Несколько интерфейсов}

Давайте еще немного помечтаем и поймем, какие интересные штуки можно делать.
Классический подход к получению интерфейса -- взять адрес объекта и кастовать его к адресу базового класса-интерфейса.
Однако, если у нас теперь интерфейс не привязан к наследованию и механизмам языка, то мы можем просто возвращать интерфейс из метода.
Причем можно назвать функции возвращающие интерфейс удобным образом и поддерживать много разных интерфейсов.
\begin{center}
\begin{tabular}{cc}
{
\begin{minipage}[\baselineskip]{6cm}
\begin{cppcode}[numbers = none]
class A {
public:
  virtual void f(int) const = 0;
};

using C = Interface<A>;

class B {
public:
   void f(int) const;
   C interface1() const;
   C interface2() const;
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{4cm}
\begin{cppcode}[numbers = none]
void g(C a) {
  if(!a)
    return;
  a->f(5);
}

int main() {
  B b;
  g(&b);
  g(b.interface1());
  g(b.interface2());
  return 0;
}
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Важные моменты:
\begin{itemize}
\item Объект может сам предоставлять разные интерфейсы с одинаковыми методами.
Наследование напрямую не позволяет поддержку такого механизма, но это тоже реализуемо.

\item Объект может контролировать количество созданных интерфейсов.
Тоже интересная фича, которую можно тут поддержать.

\item Предоставляемый интерфейс $\neq$ Публичный интерфейс.
То есть у класса может быть свой публичный интерфейс (в смысле публичные методы), а интерфейс, который он предоставляет через метод может быть вполне себе адаптером.
\end{itemize}

\subsubsection{Идея имплементации}
\label{section::RefErasureIdea}

Давайте создадим класс \texttt{AnyPtr}, который умеет хранить любой указатель на объект, у которого доступны два метода
\begin{itemize}
\item \texttt{void f() const}

\item \texttt{void g()}
\end{itemize}
Тогда структуру \texttt{AnyPtr} можно графически изобразить так:
\begin{center}
\[
\xymatrix@R10pt{
  {\verb"AnyPtr"}
    {
	\save
   [].[dd]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{\phantom{\verb"Obj"}}
   {
	\save
   [].[]*+[:<3pt>]\frm{}
   \restore
	}
  &{\phantom{\verb"class A"}}
  %\ar@/_10pt/[l]
    {
	\save
   [].[dd]*+[:<3pt>]\frm{}
   \restore
	}
  \\
  {\verb"ptr"}
   {
	\save
   [].[]*+[F-]\frm{}
   \restore
	}
  %\ar[ru]
  &{}&{\phantom{\verb"void f()"}}
  %\ar[ldd]+(10,2)
  \\
  {\verb"vtable"}
    {
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  \ar@(d,l)[rd]&{}&{\phantom{\verb"void g()"}}
  %\ar[ldd]+(10,2)
  \\
  {}&{\verb"Fptr f\_ = nullptr"}
    {
	\save
   [].[d]*[F-:<3pt>]\frm{}
   \restore
	}
  &{}\\
  {}&{\verb"Fptr g\_ = nullptr"}&{}\\
}
\]
\end{center}
Объект \texttt{AnyPtr} будет содержать два указателя:
\begin{enumerate}
\item Указатель \texttt{ptr} в виде \texttt{void*} на объект класса, которым мы хотим пользоваться через указатель.

\item Указатель \texttt{vtable} на таблицу функций, которые мы будем у него вызывать.
\end{enumerate}
Теперь, если у нас есть объект \texttt{Obj} класса \texttt{A}, который содержит нужные методы
\begin{center}
\[
\xymatrix@R10pt{
  {\verb"AnyPtr"}
    {
	\save
   [].[dd]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{{\verb"Obj"}}
   {
	\save
   [].[]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{{\verb"class A"}}
  \ar@{-->}@/_10pt/[l]
    {
	\save
   [].[dd]*+[F-:<3pt>]\frm{}
   \restore
	}
  \\
  {\verb"ptr"}
   {
	\save
   [].[]*+[F-]\frm{}
   \restore
	}
  %\ar[ru]
  &{}&{{\verb"void f()"}}
  %\ar[ldd]+(10,2)
  \\
  {\verb"vtable"}
    {
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  \ar@(d,l)[rd]&{}&{{\verb"void g()"}}
  %\ar[ldd]+(10,2)
  \\
  {}&{\verb"Fptr f\_ = nullptr"}
    {
	\save
   [].[d]*[F-:<3pt>]\frm{}
   \restore
	}
  &{}\\
  {}&{\verb"Fptr g\_ = nullptr"}&{}\\
}
\]
\end{center}
То при присваивании объекта \texttt{Obj} объекту класса \texttt{AnyPtr} надо сделать две вещи:
\begin{enumerate}
\item Присвоить адрес на \texttt{Obj} к указателю \texttt{ptr}.

\item Положить в таблицу \texttt{vtable} указатели на методы \texttt{f} и \texttt{g} из класса \texttt{A}, которому принадлежит объект \texttt{Obj}.
\end{enumerate}
\begin{center}
\[
\xymatrix@R10pt{
  {\verb"AnyPtr"}
    {
	\save
   [].[dd]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{{\verb"Obj"}}
   {
	\save
   [].[]*+[F-:<3pt>]\frm{}
   \restore
	}
	\ar@[red][ld]
  &{{\verb"class A"}}
  %\ar@{-->}@/_10pt/[l]
    {
	\save
   [].[dd]*+[F-:<3pt>]\frm{}
   \restore
	}
  \\
  {\verb"ptr"}
   {
	\save
   [].[]*+[F-]\frm{}
   \restore
	}
  %\ar[ru]
  &{}&{{\verb"void f()"}}
  \ar@[red][ldd]+(10,2)
  \\
  {\verb"vtable"}
    {
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  \ar@(d,l)[rd]&{}&{{\verb"void g()"}}
  \ar@[red][ldd]+(10,2)
  \\
  {}&{\verb"Fptr f\_ = nullptr"}
    {
	\save
   [].[d]*[F-:<3pt>]\frm{}
   \restore
	}
  &{}\\
  {}&{\verb"Fptr g\_ = nullptr"}&{}\\
}
\]
\end{center}
Технически, так как методы \texttt{f} и \texttt{g} зависят от класса \texttt{A} и для всех объектов класса \texttt{A} они будут одинаковые, то нет необходимости для каждого объекта хранить на куче свою таблицу.
Вместо этого для класса \texttt{A} заведем одну статическую таблицу и будем хранить указатель на нее.

\subsubsection{Имплементация}
\label{section::RefErasureImpl}

Давайте разбираться с деталями имплементации.
В начале надо понять, как мы будем работать с таблицами указателей на функцию.
Тут мы по сути повторяем то, как имплементирован механизм с виртуальными функциями.

\paragraph{Виртуальные таблицы}

В начале надо заменить методы на глобальные функции, чтобы у нас не было зависимости от типа \texttt{A}.
Делается это так:
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{5.4cm}
\begin{cppcode}[numbers = none]
struct A {
  void f() const;
  void g();  
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{5.35cm}
\begin{cppcode}[numbers = none]

void f_(const A* self);
void g_(A* self);  

\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Теперь заведем структуру, в которой будут лежать указатели на данные функции:
\begin{center}
\begin{minipage}[\baselineskip]{11.2cm}
\begin{cppcode}
struct VTable {
  using FSignature = void(const void*);
  using GSignature = void(void*);

  FSignature* f_ = nullptr;
  GSignature* g_ = nullptr;
};
\end{cppcode}
\end{minipage}
\end{center}
Обратите внимание, что настоящий тип функции \texttt{f\_} есть \texttt{void(const A*)}.
Однако, в таблице будет лежать функция с сигнатурой \texttt{void(const void*)}.
А значит, нам надо будет сделать несколько вспомогательных действий.
Давайте заведем шаблонный класс, который будет хранить статическую таблицу.
\begin{center}
\begin{minipage}[\baselineskip]{11.2cm}
\begin{cppcode}
template<class T>
struct Bind {
static void f_(const void* self) {
  static_cast<const T*>(self)->f();
}
static void g_(void* self) {
  static_cast<T*>(self)->g();
}

static constexpr VTable vtable{f_, g_};
};

template<>
struct Bind<void> {

static constexpr VTable vtable{nullptr, nullptr};
};
\end{cppcode}
\end{minipage}
\end{center}
Здесь для каждого типа \texttt{T} мы можем создать структуру \texttt{Bind<T>}.%
\footnote{Название пожалуй не лучшее, но я не знаю как его еще назвать.}
Внутри этой структуры мы биндим настоящие методы из класса \texttt{T} (который будет \texttt{A} в нашем примере выше).
Этот бинд делается в строках 3-5 для метода \texttt{T::f()} и в строках 6-8 для метода \texttt{T::g()}.
После чего мы создаем статическую переменную \texttt{vtable} внутри этой структуры, которая будет хранить виртуальную таблицу на забинденные методы.
Таким образом \texttt{Bind<T>::vtable} -- это будет таблица с методами для указателя на объект типа \texttt{T}.
Обратите внимание, что мы принимаем объект \texttt{self} в формате \texttt{void*} или \texttt{const void*}, потому что именно в таком формате он будет лежать внутри \texttt{AnyPtr}.
Но так как таблица с методами и указатель на объект согласованы, мы знаем, что всегда можно кастовать \texttt{self} в тип \texttt{T*} или \texttt{const T*}.
Таким образом мы получаем доступ к настоящим методам \texttt{f} и \texttt{g} из класса \texttt{T}.
И если в классе \texttt{T} нет возможности вызвать эти методы как в строках 4 и 7, то произойдет ошибка компиляции.
Это хорошо, потому что это означает, что мы пытаемся использовать класс \texttt{T} не поддерживающий нужные методы и компилятор нашел нашу ошибку.
После общего определения идет специализация для таблицы для типа \texttt{void}, который используется как sentinel и означает, что эта таблица ни на что не забиндилась.

\paragraph{Имплементация \texttt{AnyPtr}}

Теперь когда мы определились с тем, как устроен вспомогательный класс для работы с таблицами функций, давайте опишем как будет выглядеть основной класс \texttt{AnyPtr}.
В начале опишем его методы и данные, а потом уже напишем имплементацию всех методов:
\begin{cppcode}
class AnyPtr {
public:
  AnyPtr();
  AnyPtr(std::nullptr_t);
  template<NonVoidClass T>
  AnyPtr(T* ptr);

  AnyPtr(const AnyPtr& other);
  AnyPtr& operator=(const AnyPtr& other);

  AnyPtr(AnyPtr&& other) noexcept;
  AnyPtr& operator=(AnyPtr&& other) noexcept;
  ~AnyPtr();

  operator bool() const;

  void f() const;
  void g();

private:
  void clear();

  const VTable* vtable_ = &Bind<void>::vtable;
  void* ptr_ = nullptr;
};
\end{cppcode}
Как мы видим в классе лежат только два указателя:
\begin{enumerate}
\item \texttt{vtable\_} указывает на таблицу функций.
По умолчанию ссылается на пустую таблицу функций определенную для типа \texttt{viod}.

\item \texttt{ptr\_} указывает на объект, у которого мы будем вызывать нужные методы.
По умолчанию ссылается на \texttt{nullptr}.
\end{enumerate}
В начале разберемся с вопросами обеспечения правильной семантики для \texttt{AnyPtr}.
Это означает, что этот класс должен правильно создаваться, копироваться, перемещаться и уничтожаться.
Для этого имплементируем все конструкторы, деструктор и операторы присваивания.
Я в начале сгруппирую дефолтные конструкторы, а уже после них те, что требуют ручной имплементации.
\begin{cppcode}
  AnyPtr() = default;
  AnyPtr(const AnyPtr& other) = default;
  AnyPtr& operator=(const AnyPtr& other) = default;
  ~AnyPtr() = default;

  AnyPtr(AnyPtr&& other) noexcept
      : vtable_(std::exchange(other.vtable_, &Bind<void>::vtable)),
        ptr_(std::exchange(other.ptr_, nullptr)) {
  }
  
  AnyPtr& operator=(AnyPtr&& other) noexcept {
    AnyPtr tmp = std::move(other);
    std::swap(vtable_, tmp.vtable_);
    std::swap(ptr_, tmp.ptr_);
    return *this;
  }
  
  AnyPtr(std::nullptr_t) {
  }
  
  template<NonVoidClass T>
  AnyPtr(T* ptr) : vtable_(&Bind<T>::vtable), ptr_(ptr) {
  }
\end{cppcode}
Дефолтный конструктор настраивается путем инициализации полей класса.
Так как все поля класса -- это встроенные типы, то деструктор, конструктор копирования и копирующее присваивание тоже могут быть дефолтными.
Интерес представляют конструкторы от указателей и мувающие конструкторы.
Так как поля класса встроеенные типы, то мувающие операции по дефолту совпадают с копирующими, а я все же хотел бы, чтобы после мува, мы вынули из старой переменной указатель и перенесли его в новую.
\begin{cppcode}
A a;
AnyPtr ptr1 = &a;
AnyPtr ptr2 = std::move(ptr1);
AnyPtr ptr3;
ptr3 = std::move(ptr2);
\end{cppcode}
Я хочу, чтобы в строке 3 указатель \texttt{ptr1} инвалидировался.
Аналогично в строке 5 хочу, чтобы указатель \texttt{ptr2} инвалидировался.
А для этого нужно сделать очистку данных в старом объекте в мувающем конструкторе и операторе присваивания.
Тут используются стандартные имплементации, которые обсуждались в разделе~\ref{section::siximpl}.

Конструктор от \texttt{std::nullptr\_t} нужен, чтобы можно было написать
\begin{cppcode}
A a;
AnyPtr ptr = &a;
ptr = nullptr;
\end{cppcode}
И таким образом мы  занулили (инвалидировали) указатель.
Конструктор от указателя нужен, чтобы сработала строчка 2 в листинге выше.
Но я не хочу создавать \texttt{AnyPtr} от указателя на \texttt{void*}, а потому мне нужно отключить этот конструктор.
Это делается с помощью \texttt{concept}-а, который я назвал \texttt{NonVoidClass}.
По сути этот концепт лишь проверяет ялвяется ли \texttt{T} типом \texttt{void} или нет.
И если является, то этот конструктор не компилируется, а если не является, то можно создавать такой конструктор.
Если же класс \texttt{T} не предоставляет нужные методы \texttt{f} и \texttt{g}, то в этом конструкторе в момент обращения к таблице \texttt{\&Bind<T>::vtable} произойдет ошибка компиляции.
Можно поиграться и сделать более адекватные сообщения об ошибках, но я стараюсь делать минимальные примеры.

Теперь напишем имплементацию оставшихся методов:
\begin{cppcode}
  operator bool() const {
    return ptr_ != nullptr && vtable_->f_ != nullptr && vtable_->g_ != nullptr;
  }

  void f() const {
    assert(*this);
    vtable_->f_(ptr_);
  }
  void g() {
    assert(*this);
    vtable_->g_(ptr_);
  }

  void clear() {
    vtable_ = &Bind<void>::vtable;
    ptr_ = nullptr;
  }
\end{cppcode}
Оператор \texttt{operator bool() const} нужен, чтобы проверять ссылается ли указатель на кого-то или нет.%
\footnote{Для имплементации достаточно было бы проверить, то \texttt{ptr\_ != nullptr}, но я хотел подчеркнуть, что мне важно, чтобы все указатели были не нулевыми.
В реальном коде, можно оставить лишь одну проверку для \texttt{ptr\_} и сделать инвариантом, что для ненулевого \texttt{ptr\_} указатели на обе функции тоже не нулевые.}
Метод \texttt{clear} просто удобный способ очистки указателя.
И методы \texttt{f} и \texttt{g} являются самым важным элементом публичного интерфейса -- это те методы, которые позволяют вызвать нужные методы \texttt{f} и \texttt{g} на объекте по адресу \texttt{ptr\_}.
Как видите, это происходит через вызов метода по указателю из текущей таблицы.
Теперь можно писать такой код
\begin{cppcode}
A a;
AnyPtr ptr = &a;
ptr.f();
ptr.g();
B b;
ptr = &b;
ptr.f();
ptr.g();
\end{cppcode}

\paragraph{Оператор \texttt{operator->}}
Все бы хорошо, но только мы бы хотели у указателя иметь возможность звать методы по оператору \texttt{operator->()}.
Это можно сделать с помощью простого адаптера поверх \texttt{AnyPtr}.
Вот простое неинтрузивное решение, то есть без изменения \texttt{AnyPtr}.
Мы сделаем старый \texttt{AnyPtr} интерфейсом, который надо вернуть по оператору \texttt{operator->} из нового \texttt{AnyPtr2}:
\begin{cppcode}
class AnyPtr2 : AnyPtr {
public:
  using AnyPtr::operator bool;

  AnyPtr* operator->() {
    return this;
  }
  const AnyPtr* operator->() const {
    return this;
  }
};
\end{cppcode}
Теперь можно писать код следующим образом:
\begin{cppcode}
struct A {
  void f() const;
  void g();
};

struct B {
  void f() const;
  void g();
};

int main() {
  A a;
  B b;
  AnyPtr2 p = &a;
  p->f();
  p = &b;
  p->g();
  return 0;
}
\end{cppcode}
Есть популярное решение использующее UB.
Давайте я его продемонстрирую.
\begin{cppcode}
class AnyPtr {
public:
  Interface* operator->() {
    return static_cast<Interface*>(this);  // UB
  }
  const Interface* operator->() const {
    return static_cast<const Interface*>(this); // UB
  }
protected:
  void f() const;
  void g();
};

class Interface : AnyPtr {
public:
  using AnyPtr::f;
  using AnyPtr::g;
};
\end{cppcode}
В этом решении мы не делаем адаптер вокруг \texttt{AnyPtr}, а добавляем наследника и в операторе \texttt{operator->} кастуем \texttt{this} к производному классу.
Технически это скорее всего будет работать на всех компиляторах, но фактически это UB.
Причина следующая, вы в начале кастуете тип \texttt{AnyPtr} к производному классу \texttt{Interface}.
Это еще пока не UB.
Но если вы после этого обратитесь к любому методу из производного класса, то это будет UB, потому что нельзя обращаться по адресу к объекту, которого там нет.
По адресу \texttt{this} лежит объект типа \texttt{AnyPtr}, а вызов метода через класс \texttt{Interface}, принимает аргумент \texttt{this} типа \texttt{Interface}.
Вот это уже делать нельзя.

\subsubsection{Общее шаблонное решение}

В предыдущих разделах мы построили класс \texttt{AnyPtr}, в который можно складывать указатель на любой объект, у которого можно вызывать два метода \texttt{f} и \texttt{g} без аргументов и без возвращаемого значения.
Однако, мы бы хотели теперь настроить наш тип \texttt{AnyPtr} так, чтобы можно было в него передавать любой интерфейс.
Основная проблема в автоматизации этого процесса заключается в том, что нам надо научиться передавать имена методов.
Но к сожалению в C++ нет способа передавать имя метода в виде параметра.
Это возможно с помощью макросов (как кодогенерация), но не возможно методами языка.
В идеале мы бы хотели следующее решение
\begin{cppcode}
class Interface {
public:
  virtual void f() const = 0;
  virtual void g() = 0;
};

int main() {
  A a;
  AnyPtr<Interface> ptr = &a;
  ptr->f();
  ptr->g();
}
\end{cppcode}
% TO DO

\subsection{Стирающие типы}
\label{section::TypeErasure}

Стирающим типом принято называть тип, который может хранить внутри себя объект любого типа, если у него в интерфейсе есть определенные методы с заданной сигнатурой.
Стирающий тип в отличии от стирающей ссылки (или указателя) владеет объектом, а не просто ссылается на него.
В языке сейчас есть небольшая поддержка стирающих типов.
Вот что нам доступно
\begin{enumerate}
\item \verb"std::any" -- это стирающий тип с пустым интерфейсом.
То есть он умеет в себе хранить объект любого типа.
При этом корректно работают операции копирования и перемещения и уничтожения.
Но положив туда данные вы никак не можете ими воспользоваться.
Точнее вам надо знать что там лежит и после этого вы можете откастовать \verb"std::any" к нужному типу и достать соответствующий объект.

\item \verb"std::function" -- это стирающий тип, который умеет хранить в себе любой объект, для которого определен \verb"operator()" с нужной сигнатурой.
В отличие от указателя на функцию, внутри \verb"std::function" можно хранить функторы содержащие данные.

\item Указатель на функцию.
Так как функции существуют во время выполнения программы и они их код менять нельзя при исполнении.
То указатель на функцию имеет value semantics и ведет себя как будто переменная, в которую вы складываете функцию с указанной сигнатурой.

\item \verb"std::optional" -- это не совсем полноценный стирающий тип.
Он позволяет положить в него любой объект принадлежащий заранее указанному списку типов.
И после этого он предоставляет возможность применения операций к объекту, не вынимая его, с помощью visitor паттерна.
\end{enumerate}

% TO DO
\subsubsection{Ожидаемое поведение}

Давайте опишем, что бы мы хотели иметь.
Прежде всего мы хотим описать требуемый интерфейс как-то так:
\begin{cppcode}
struct Interface {
  virtual void f() const = 0;
  virtual int g(const std::string&) const = 0;
};
\end{cppcode}
Теперь предположим, что у нас есть два класса, которые поддерживают этот интерфейс
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
struct A {
  void f() const;
  int g(const std::string&) const;
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
struct B {
  void f() const;
  int g(const std::string&) const;
};
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Мы хотим уметь хранить объекты обоих классов \verb"A" и \verb"B" в одной и той же переменной и вызывать методы \verb"f" и \verb"g" не зная, какой именно там лежит объект.
Ожидаемое поведение будет таким:
\begin{cppcode}
int main() {
  Any<Interface> x;
  x = A();
  x->f();
  x = B();
  std::cout << x->g("123") << std::endl;
  return 0;
}
\end{cppcode}
Есть два способа имплементировать стирающие типы:
\begin{enumerate}
\item Ручной менеджмент таблицами виртуальных функций

\item Использование наследования с виртуальными функциями с шаблонными адаптерами
\end{enumerate}

Первый способ по сути повторяет идеи описанные в разделе~\ref{section::RefErasure}, где вместо указателя мы будем использовать произвольный класс, а вместо \verb"void*" -- \verb"std::any".
Потому на \verb"std::any" можно смотреть как на владеющий аналог \verb"void*".

\subsubsection{Идея имплементации}
\label{section::TypeErasureIdea}
% TO DO
Давайте создадим класс \verb"Any", который умеет хранить любой объект, у которого доступны два метода
\begin{itemize}
\item \verb"void f() const"

\item \verb"void g(const std::string&) const"
\end{itemize}
Тогда структуру \verb"Any" можно графически изобразить так:
\begin{center}
\[
\xymatrix@R10pt{
  {\verb"Any"}
    {
	\save
   [].[dd]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{\phantom{\verb"Obj"}}
   {
	\save
   [].[]*+[:<3pt>]\frm{}
   \restore
	}
  &{\phantom{\verb"class A"}}
  %\ar@/_10pt/[l]
    {
	\save
   [].[dd]*+[:<3pt>]\frm{}
   \restore
	}
  \\
  {\verb"any"}
   {
	\save
   [].[]*+[F-]\frm{}
   \restore
	}
  %\ar[ru]
  &{}&{\phantom{\verb"void f()"}}
  %\ar[ldd]+(10,2)
  \\
  {\verb"vtable"}
    {
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  \ar@(d,l)[rd]&{}&{\phantom{\verb"void g(...)"}}
  %\ar[ldd]+(10,2)
  \\
  {}&{\verb"Fptr f\_ = nullptr"}
    {
	\save
   [].[d]*[F-:<3pt>]\frm{}
   \restore
	}
  &{}\\
  {}&{\verb"Fptr g\_ = nullptr"}&{}\\
}
\]
\end{center}
Объект \verb"Any" будет содержать два поля:
\begin{enumerate}
\item Переменная типа \verb"std::any", содержащая данный объект.

\item Указатель \verb"vtable" на таблицу функций, которые мы будем у него вызывать.
\end{enumerate}
Теперь если у нас есть объект \verb"Obj" класса \verb"A", который содержит нужные методы
\begin{center}
\[
\xymatrix@R10pt{
  {\verb"Any"}
    {
	\save
   [].[dd]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{{\verb"Obj"}}
   {
	\save
   [].[]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{{\verb"class A"}}
  \ar@{-->}@/_10pt/[l]
    {
	\save
   [].[dd]*+[F-:<3pt>]\frm{}
   \restore
	}
  \\
  {\verb"any"}
   {
	\save
   [].[]*+[F-]\frm{}
   \restore
	}
  %\ar[ru]
  &{}&{{\verb"void f()"}}
  %\ar[ldd]+(10,2)
  \\
  {\verb"vtable"}
    {
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  \ar@(d,l)[rd]&{}&{{\verb"void g(...)"}}
  %\ar[ldd]+(10,2)
  \\
  {}&{\verb"Fptr f\_ = nullptr"}
    {
	\save
   [].[d]*[F-:<3pt>]\frm{}
   \restore
	}
  &{}\\
  {}&{\verb"Fptr g\_ = nullptr"}&{}\\
}
\]
\end{center}
То при присваивании объекта \verb"Obj" объекту класса \verb"Any" надо сделать две вещи:
\begin{enumerate}
\item Положить объект \verb"Obj" или его копию внутрь \verb"std::any" поля внутри \verb"Any".

\item Положить в таблицу \verb"vtable" указатели на методы \verb"f" и \verb"g" из класса \verb"A", которому принадлежит объект \verb"Obj".
\end{enumerate}
\begin{center}
\[
\xymatrix@R10pt{
  {\verb"Any"}
    {
	\save
   [].[dd]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{{\verb"Obj"}}
   {
	\save
   [].[]*+[F-:<3pt>]\frm{}
   \restore
	}
	\ar@[red][ld]
  &{{\verb"class A"}}
  %\ar@{-->}@/_10pt/[l]
    {
	\save
   [].[dd]*+[F-:<3pt>]\frm{}
   \restore
	}
  \\
  {\verb"any"}
   {
	\save
   [].[]*+[F-]\frm{}
   \restore
	}
  %\ar[ru]
  &{}&{{\verb"void f()"}}
  \ar@[red][ldd]+(10,2)
  \\
  {\verb"vtable"}
    {
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  \ar@(d,l)[rd]&{}&{{\verb"void g(...)"}}
  \ar@[red][ldd]+(10,2)
  \\
  {}&{\verb"Fptr f\_ = nullptr"}
    {
	\save
   [].[d]*[F-:<3pt>]\frm{}
   \restore
	}
  &{}\\
  {}&{\verb"Fptr g\_ = nullptr"}&{}\\
}
\]
\end{center}
Технически, так как методы \verb"f" и \verb"g" зависят от класса \verb"A" и для всех объектов класса \verb"A" они будут одинаковые, то нет необходимости для каждого объекта хранить на куче свою таблицу.
Вместо этого для класса \verb"A" заведем одну статическую таблицу и будем хранить указатель на нее.

\subsubsection{Имплементация}
\label{section::TypeErasureImpl}
% TO DO

Здесь мы по сути повторяем то, как имплементирован механизм с виртуальными функциями.
Однако, объект класса будет приниматься не по \verb"void*", а по ссылке на \verb"std::any".

\paragraph{Виртуальные таблицы}

В начале надо заменить методы на глобальные функции, чтобы у нас не было зависимости от типа \texttt{A}.
Делается это так:
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
struct A {
  void f() const;
  void g(const std::string&) const;
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]

void f_(const A* self);
void g_(const A* self, const std::string&);  

\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Теперь заведем структуру, в которой будут лежать указатели на данные функции:
\begin{center}
\begin{minipage}[\baselineskip]{11.2cm}
\begin{cppcode}
struct VTable {
  using FSignature = void(const std::any&);
  using GSignature = void(const std::any&, const std::string&);

  FSignature* f_ = nullptr;
  GSignature* g_ = nullptr;
};
\end{cppcode}
\end{minipage}
\end{center}
Обратите внимание, что настоящий тип функции \texttt{f\_} есть \texttt{void(const A*)}.
Однако, в таблице будет лежать функция с сигнатурой \texttt{void(const std::any\&)}.
А значит, нам надо будет сделать несколько вспомогательных действий.
Давайте заведем шаблонный класс, который будет хранить статическую таблицу.
\begin{center}
\begin{minipage}[\baselineskip]{12cm}
\begin{cppcode}
template<class T>
struct Bind {
static void f_(const std::any& self) {
  std::any_cast<const T&>(self).f();
}
static void g_(const std::any& self, const std::string& str) {
  std::any_cast<T&>(self).g(str);
}

static constexpr VTable vtable{f_, g_};
};

template<>
struct Bind<void> {

static constexpr VTable vtable{nullptr, nullptr};
};
\end{cppcode}
\end{minipage}
\end{center}
Здесь для каждого типа \texttt{T} мы можем создать структуру \texttt{Bind<T>}.%
\footnote{Название пожалуй не лучшее, но я не знаю как его еще назвать.}
Внутри этой структуры мы биндим настоящие методы из класса \texttt{T} (который будет \texttt{A} в нашем примере выше).
Этот бинд делается в строках 3-5 для метода \texttt{T::f()} и в строках 6-8 для метода \texttt{T::g(...)}.
После чего мы создаем статическую переменную \texttt{vtable} внутри этой структуры, которая будет хранить виртуальную таблицу на забинденные методы.
Таким образом \texttt{Bind<T>::vtable} -- это будет таблица с методами для указателя на объект типа \texttt{T}.
Обратите внимание, что мы принимаем объект \texttt{self} в формате \texttt{const std::any\&}, потому что внутри \texttt{Any} он хранится внутри поля типа \texttt{std::any}.
Но так как таблица с методами и указатель на объект согласованы, мы знаем, что всегда можно кастовать с помощью \texttt{any\_cast} переменную \texttt{self} в тип \texttt{T\&} или \texttt{const T\&}.
Таким образом мы получаем доступ к настоящим методам \texttt{f} и \texttt{g} из класса \texttt{T}.
И если в классе \texttt{T} нет возможности вызвать эти методы как в строках 4 и 7, то произойдет ошибка компиляции.
Это хорошо, потому что это означает, что мы пытаемся использовать класс \texttt{T} не поддерживающий нужные методы и компилятор нашел нашу ошибку.
После общего определения идет специализация для таблицы для типа \texttt{void}, который используется как sentinel и означает, что эта таблица ни на что не забиндилась.

\paragraph{Имплементация \texttt{Any}}

Теперь когда мы определились с тем, как устроен вспомогательный класс для работы с таблицами функций, давайте опишем как будет выглядеть основной класс \texttt{Any}.
В начале опишем его методы и данные, а потом уже напишем имплементацию всех методов:
\begin{cppcode}
class Any {
public:
  Any();
  template<class T>
  Any(T&& obj);

  Any(const Any& other);
  Any& operator=(const Any& other);

  Any(Any&& other) noexcept;
  Any& operator=(Any&& other) noexcept;
  ~Any();

  bool has_value() const;

  void f() const;
  void g(const std::string&) const;

private:
  void clear();

  const VTable* vtable_ = &Bind<void>::vtable;
  std::any obj_;
};
\end{cppcode}
Как мы видим в классе лежат только два поля:
\begin{enumerate}
\item \texttt{vtable\_} указывает на таблицу функций.
По умолчанию ссылается на пустую таблицу функций определенную для типа \texttt{viod}.

\item \texttt{obj\_} содержит объект, у которого мы будем вызывать нужные методы.
По умолчанию ничего не содержит, а потому мы поддерживаем метод проверки лежит ли что-либо внутри \texttt{Any}.
\end{enumerate}
В начале разберемся с вопросами обеспечения правильной семантики для \texttt{Any}.
Поле типа \texttt{std::any} уже обладает нужным поведением.
Проблема есть с \texttt{VTable*}.
Оно конечно обладает value semantics, но методы перемещения надо прописать вручную, потому что мы хотим очистить данные из объекта из которого мы проделали мув.
Для этого имплементируем все конструкторы, деструктор и операторы присваивания.
Я в начале сгруппирую дефолтные конструкторы, а уже после них те, что требуют ручной имплементации.
\begin{cppcode}
  Any() = default;
  Any(const Any& other) = default;
  Any& operator=(const Any& other) = default;
  ~Any() = default;

  Any(Any&& other) noexcept
      : vtable_(std::exchange(other.vtable_, &Bind<void>::vtable)),
        obj_(std::exchange(other.obj_, std::any())) {
  }
  
  Any& operator=(Any&& other) noexcept {
    Any tmp = std::move(other);
    std::swap(vtable_, tmp.vtable_);
    std::swap(ptr_, tmp.ptr_);
    return *this;
  }
  
  template<class T>
  Any(T&& obj) : vtable_(&Bind<T>::vtable), obj_(std::forward<T>(obj)) {
  }
\end{cppcode}
Дефолтный конструктор настраивается путем инициализации полей класса.
Как я писал выше деструктор, конструктор копирования и копирующее присваивание подойдут дефолтными.
Мувающие операции вынимают данные из предыдущего \texttt{Any}.
То есть я хочу достичь поведения
\begin{cppcode}
A a;
Any obj1 = a;
Any obj2 = std::move(obj1);
Any obj3;
obj3 = std::move(obj2);
\end{cppcode}
Я хочу, чтобы в строке 3 объект \texttt{obj1} передавал свое содержимое внутрь \texttt{obj2}.
Аналогично в строке 5 хочу, чтобы объект \texttt{obj2} передавал свое содержимое внутрь \texttt{obj3}.
А для этого нужно сделать очистку данных в старом объекте в мувающем конструкторе и операторе присваивания.
Тут используются стандартные имплементации, которые обсуждались в разделе~\ref{section::siximpl}.

И остался последний конструктор -- от произвольного типа объект, чтобы мы могли написать
\begin{cppcode}
Any x = A();
Any y = B();
\end{cppcode}
При этом важное замечание, если мы напишем
\begin{cppcode}
Any x;
Any y = x;
\end{cppcode}
то сработает копирующий конструктор, который мы явно прописали.
В этом случае компилятор всегда отдает приоритет нешаблонному методу по сравнению с шаблонным.
Если бы мы не определили явно копирующий конструктор через \texttt{default} у нас были бы проблемы в этом случае.

Теперь напишем имплементацию оставшихся методов:
\begin{cppcode}
  bool has_value() const {
    return obj_.has_value() && vtable_->f_ != nullptr && vtable_->g_ != nullptr;
  }

  void f() const {
    vtable_->f_(obj_);
  }
  
  void g(const std::string& str) const {
    vtable_->g_(obj_, str);
  }
\end{cppcode}
Метод \texttt{has\_value} нужен, чтобы проверять лежит ли что-то сейчас внутри \texttt{Any} или нет.%
\footnote{Для имплементации достаточно было бы проверить, то \texttt{obj\_.has\_value()}, но я хотел подчеркнуть, что мне важно, чтобы все указатели были не нулевыми.
В реальном коде, можно оставить лишь одну проверку для \texttt{obj\_} потому что у нас есть инвариант, что для не пустого \texttt{obj\_} указатели на обе функции тоже не нулевые и корректные.}
И методы \texttt{f} и \texttt{g} являются самым важным элементом публичного интерфейса -- это те методы, которые позволяют вызвать нужные методы \texttt{f} и \texttt{g} на объекте хранимом внутри \texttt{obj\_}.
Как видите, это происходит через вызов метода по указателю из текущей таблицы.
Теперь можно писать такой код
\begin{cppcode}
A a;
Any obj = a;
obj.f();
obj.g("abc");
B b;
obj = b;
obj.f();
obj.g("123");
\end{cppcode}


\subsubsection{Общее шаблонное решение}
% TO DO

%\subsubsection{SOO}
% TO DO
% Сюда?

\subsubsection{Идея ленивого решения}
% TO DO
Выше я описал имплементацию для стирающих типов, не использующую виртуальные функции и наследование.
По сути мы руками делаем работу, которую за нас может сделать язык и компилятор.
Давайте я опишу здесь альтернативную имплементацию, которая не требует руками возиться с таблицами виртуальных функций.

Давайте начнем со следующего вопроса.
Пусть у нас задан интерфейс  и класс, который удовлетворяет этому интерфейсу, но не унаследованный от него:
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
struct Concept {
  virtual ~Concept() = default;
  virtual void f() const = 0;
  virtual void g(const std::string&) const = 0;
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
class A {
public:
  void f() const;
  void g(const std::string&) const;
};
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Вопрос, как присоединить этот класс к интерфейсу?
Для этого можно воспользоваться адаптером между интерфейсом и нужным классом.
В качестве адаптера будет использоваться вспомогательный класс \verb"Model", который будет унаследован от интерфейса \verb"Concept", будет хранить в себе объект класса \verb"A", и его задача будет организовать проброс вызовов для виртуальных методов.
\[
\xymatrix{
  {\texttt{Concept}}
      {
	\save
   [].[]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}\\
  {\texttt{Model}}\ar[u]+(0,-4)
      {
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}\\
  {\texttt{A}}
    {
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  &{}\\
}
\]
В коде это выглядит так
\begin{cppcode}
struct Concept {
  virtual ~Concept() = default;
  virtual void f() const = 0;
  virtual void g(const std::string&) const = 0;
};

template<class T>
class Model : public Concept {
public:
  Model(const T& data) : data_(data) {}
  Model(T&& data) : data_(std::move(data)) {}
  
  void f() const final {
    data_.f();
  }
  
  void g(const std::string& str) const final {
    data_.g(str);
  }
private:
  T data_;
};
\end{cppcode}
Теперь мы можем следующим образом хранить любые данные в единой переменно
\begin{cppcode}
int main() {
  A a;
  std::unique_ptr<Concept> model = std::make_unique<Model<A>>(std::move(a));
  model->f();
  model->g("abc");
  return 0;
}
\end{cppcode}

\subsubsection{Имплементация ленивого решения}
% TO DO

Теперь опишем, как собрать класс \verb"Any", используя идею из предыдущего раздела.
Опишем его интерфейс
\begin{cppcode}
class Any {
public:
  template<class T>
  Any(T&& object);

  Any() = default;
  Any(const Any&);
  Any(Any&&) = default;
  Any& operator=(const Any&);
  Any& operator=(Any&&) = default;
  ~Any() = default;
  
  const Concept* operator->() const;
  Concept* operator->();
  
  operator bool() const;
private:
  std::unique_ptr<Concept> model_;
};
\end{cppcode}
Теперь напишем, как эти методы имплементируются.
В начале методы публичного интерфейса
\begin{cppcode}
const Concept* operator->() const {
  return model_.get();
}
Concept* operator->() {
  return model_.get();
}
operator bool() const {
  return model_.operator bool();
}
\end{cppcode}
Обратите внимание, что оператор \verb"operator->" пробрасывает константность.
Это связано с тем, что мы хотим, чтобы константность \verb"Any" означало константность данных внутри.

Теперь конструкторы.
В начале конструктор для помещения объекта внутрь \verb"Any"
\begin{cppcode}
template<class T>
Any(T&& object) : model_(std::make_unique<Model<T>>(std::forward<T>(object))) {}
\end{cppcode}
Перемещающие методы и деструктор можно оставить по умолчанию.
А вот копирование придется писать руками, так как по умолчанию \verb"std::unique_ptr" не имеет операции копирования.
Здесь придется виртуализовать копирование.
То есть добавить в интерфейс \verb"Concept" метод копирования.
Давайте начнем с изменения класса \verb"Concept".
\begin{cppcode}
class Concept {
public:
  virtual void f() const = 0;
  virtual void g(const std::string&) const = 0;
protected:
  ~Concept() = default;
private:
  virtual std::unique_ptr<Concept> make_copy_() const = 0;
  friend class Any;
};
\end{cppcode}
Обратите внимание, что у \verb"Any" оператор \verb"operator->" возвращает указатель на \verb"Concept".
А мы не хотим, чтобы пользователь мог воспользоваться служебными методами.
Поэтому все служебные методы такие как копирование и деструктор, мы прячем.
Но с другой стороны, \verb"Any" должен быть способен позвать метод \verb"make_copy_".
А потому его надо сделать \verb"friend" классом.
Это хороший пример, когда нужно ключевое слово \verb"friend".
Дело в том, что два класса тесно взаимодействуют друг с другом и хотя поддерживать один инвариант -- данное внутри \verb"model_" переменной.
При этом \verb"Any" пользуется этим доступом только в копирующем конструкторе и нигде больше.
Теперь опишем как изменится модель
\begin{cppcode}
template<class T>
class Model : public Concept {
  std::unique_ptr<Concept> make_copy_() const final {
    return std::make_unique<Model>(data_);
  }
public:
  Model(consst T& data) : data_(data) {}
  Model(T&& data) : data_(std::move(data)) {}
  void f() const final {
    data_.f();
  }
  void g(const std::string& str) const final {
    data_.g(str);
  }
private:
  T data_;
};
\end{cppcode}
Теперь копирующие операции для \verb"Any" выглядят так
\begin{cppcode}
Any(const Any& other)
  : model_((other ? other->make_copy_() : nullptr)) {}
Any& operator=(const Any& other) {
  return *this = Any(other);
}
\end{cppcode}


\subsubsection{Общая шаблонная версия ленивого решения}
% TO DO
Теперь давайте посмотрим, как сделать предыдущее решение общим, чтобы оно работало для любого интерфейса, а не только для указанных двух методов с указанными именами и сигнатурами.
Давайте поймем, что у нас есть сейчас:
\begin{center}
\[
\xymatrix{
  {\verb"Concept"}
      	{
	\save
   [].[]*+[F-:<3pt>]\frm{}
   \restore
	}
	%\ar[u]
	&{}&{\text{Интерфейс для оператора \verb"->" в Any}}\\
  {{\verb"Model"}\vphantom{\verb"Keeper"}}
      	{
	\save
   [].[]*+[F-:<3pt>]\frm{}
   \restore
	}
	\ar[u]+(0, -4)
	&{}&{\text{Хранит данные и}\text{ биндит метод}}\\
}
\]
\end{center}
Теперь мы распилим этот класс на следующие компоненты
\begin{center}
\[
\xymatrix{
   {{\verb"IEmpty"}}
  	{
	\save
   [].[]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{{\text{Виртуальный деструктор по умолчанию}}}\\
  {{\verb"Interface"}}
      	{
	\save
   [].[]*+[F--:<3pt>]\frm{}
   \restore
	}
	\ar[u]+(0, -4)
	&{}&{{\text{Интерфейс от пользователя}}}\\
  {\verb"Concept"}
      	{
	\save
   [].[]*+[F-:<3pt>]\frm{}
   \restore
	}
	\ar[u]+(0, -3)
	&{}&{\text{Интерфейс для оператора \verb"->" в Any}}\\
  {{\verb"Keeper"}}
      	{
	\save
   [].[]*+[F-:<3pt>]\frm{}
   \restore
	}
	\ar[u]+(0, -4)
	&{}&{\text{Хранит данные и дает доступ}}\\
  {{\verb"Impl"}}
      	{
	\save
   [].[]*+[F--:<3pt>]\frm{}
   \restore
	}
	\ar[u]+(0, -4)
	&{}&{{\text{Бинд интерфейса от пользователя}}}\\
}
\]
\end{center}
На этой диаграмме пунктиром отмечены классы, которые мы будем настраивать.
А сплошными отмечены классы, которые надо будет написать.
Давайте опишем роли этих классов
\begin{enumerate}
\item \verb"IEmpty".
Задача этого класса -- избавить пользователя от необходимости самостоятельно указывать в интерфейсе виртуальный деструктор.
Это позволит не обременять пользователя лишней работой и избежать ошибок в программе, при отсутствии виртуального деструктора.

\item \verb"Interface".
Это шаблон, который предоставляет пользователь, описывающий интерфейс нужного стирающего типа.

\item \verb"Concept".
Это интерфейс, который возвращается по оператору \verb"operator->" в классе \verb"Any".

\item \verb"Keeper".
Данный класс хранит сам объект и дает доступ к нему.

\item \verb"Impl".
Этот шаблон предоставляет пользователь.
Его задача пробросить виртуальные вызовы и назначить их на нужные методы внутри хранимого объекта.
\end{enumerate}
Вот как выглядит имплементация этих классов в коде.
\begin{cppcode}
template<template<class> class IAny, template<class> class Impl>
class Any;

class IEmpty {
protected:
  virtual ~IEmpty() = default;
};

class Concept : public IAny<IEmpty> {
  std::unique_ptr<Concept> make_copy_() const = 0;
  friend class Any;
};

template<class T>
class Keeper : public Concept {
  std::unique_ptr<Concept> make_copy_() const final {
    return std::make_unique<Impl<Keeper<T>>>(data_);
  }
public:
  Keeper(const T& data) : data_(data) {}
  Keeper(T&& data) : data_(std::move(data)) {}
protected:
  T& object() { return data_; }  
  const T& object() const { return data_; }
private:
  T data_;
};
\end{cppcode}
Метод \verb"object" нужен для того, чтобы можно было получить доступ к данным в \verb"Impl", когда мы будем биндить виртуальные методы на методы класса.
Теперь в класс \verb"Any" нужно внести следующие изменения
\begin{cppcode}
template<template<class> class IAny, template<class> class Impl>
class Any {
public:
  template<class T>
  Any(T&& data)
    : model_(std::make_unique<Impl<Keeper<T>>>(std::forward<T>(data))) {}
  /* default methods */
  Concept* operator->();
  const Concept* operator->() const;
  operator bool() const;
private:
  std::unique_ptr<Concept> model_;
};
\end{cppcode}
Теперь пользователь должен предоставить два класса
\begin{cppcode}
template<class IEmpty>
class IAny : public IEmpty {
public:
  virtual void f() const = 0;
  virtual void g(const std::string&) const = 0;
};

template<class Keeper>
class Impl : public Keeper {
public:
  using Keeper::Keeper;
  void f() const final {
    Keeper::object().f();
  }
  void g(const std::string& str) const final {
    Keeper::object.g(str);
  }
};
\end{cppcode}
Тут важно обратить внимание, что надо в классе \verb"Impl" пробросить конструкторы из класса \verb"Keeper", что делается в строчке~11.
Теперь можно пользоваться этим следующим образом
\begin{cppcode}
using AnyFG = Any<IAny, Impl>;

struct A {
  void f() const {}
  void g(const std::string&) const {}
};

struct B {
  void f() const {}
  void g(const std::string&) const {}
};

int main() {
  AnyFG x = A();
  x->f();
  x->g("abc");
  x = B();
  x->f();
  x->g("abc");
  return 0;
}
\end{cppcode}
