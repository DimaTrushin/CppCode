\ProvidesFile{Classes.tex}[Классы]


\section{Классы}

\subsection{Класс или структура}

Технически в языке C++ класс и структура -- это одна и та же сущность, но с разными дефолтными квалификаторами доступа.
В структуре все публично, а в классе все приватно по умолчанию.
Главный вопрос: когда использовать класс, а когда структуру.

\begin{itemize}
\item Структура создается когда вам нужно хранить данные рядом в одной переменной.
\begin{cppcode}
struct Pair {
  int x;
  int y;
};
\end{cppcode}
При этом у структуры НЕ должно быть методов в том числе конструкторов.
Технически любая функция имеет доступ к полям структуры, потому нет необходимости делать методы структуры.
Идейно мы думаем про структуру, как про пассивный объект, хранящий данные вместе и все.
Все манипуляции над данными происходят снаружи.
При этом никаких ограничений на данные внутри структуры нет.

\item Класс создается, когда хранимые данные должны удовлетворять какому-то инварианту и мы не можем просто положить их в структуру, ибо инвариант будет нарушен.
\begin{cppcode}
class OrderedPair {
public:
  ...
private:
  // invariant min <= max
  int min;
  int max;
};
\end{cppcode}
Для сохранения инварианта данные класса делаются приватными (это называется инкапсюляция).
А для взаимодействия с данными создаются публичные методы, задача которых поддерживать класс в корректном состоянии.
\end{itemize}

\subsubsection{Замечания}
\label{section::Class::RawData}

\begin{enumerate}
\item Наличие инварианта не всегда означает, что вам нужно зашивать данные в класс.
Точнее, надо, но вопрос в том на каком уровне.
Давайте я приведу пример, на котором будет понятно, что я имею в виду.
Предположим вам надо создать класс вектор из линейной алгебры и для хранения размера вектора вам нужно хранить положительное число.%
\footnote{Сразу скажу, если вам такое надо, то используйте \verb"std::vector", а не имплементируйте контейнер самостоятельно.
Пример ниже лишь для наглядности.}
\begin{cppcode}
class Vector {
private:
  int size_;
  double* data_;
};
\end{cppcode}
Так вот, вопрос заключается в том какой тип должен быть у \verb"size_".
В STL в \verb"std::vector" используется беззнаковое \verb"size_t" потому что все его значения допустимы для размера вектора.
Казалось бы разумная идея, но позже добавляется метод \verb"ssize()", который возвращает размер в виде знакового типа.
Давайте разберемся в логике этого явления.
При создании класса \verb"Vector" выше, он должен представлять вектор из линейной алгебры и для вектора у нас нет смысла в длине равной нулю или отрицательной.
Это инвариант, который мы хотим гарантировать.
И главный вопрос: кто должен за этот инвариант отвечать.
И тут есть два решения:
\begin{enumerate}
\item За инвариант должен отвечать новый класс \verb"PositiveInt"

\item За инвариант отвечает класс \verb"Vector"
\end{enumerate}
Я утверждаю, что второй подход в данном случае лучше.
Кроме того, второй подход позволяет хранить \verb"size_" в виде знакового типа.
Почему же второй подход на мой взгляд предпочтительнее:
\begin{enumerate}
\item Для написания типа \verb"PositiveInt" нам придется писать новый полноценный класс.
Это лишняя работа.
Кроме того, по умолчанию новый класс ничего не умеет, а значит всю его функциональность надо будет писать с нуля.
И хороший вопрос, что этот класс должен уметь делать.
Можно ли например вычитать из одного числа другое?
Если можно, что делать при вычитании из меньшего большего?
А если нельзя, что делать если хочется все же вычитать?

\item Новый класс никак не совместим со встроенными типами.
Нельзя прибавить к нему \verb"int", нельзя умножить на \verb"int" и т.д.
А это значит, везде, где раньше мы пользовались удобством встроенных типов, наличием операций над ними, нам придется все эти операции дописывать руками, что будет лишней работой.
Вот это особенно плохо, потому что мы по сути выкидываем функциональность, которая нам нужна.

\item Если мы используем \verb"PositiveInt" для указания размера, то мы скорее всего будем аллоцировать память такого размера, а все библиотечные функции принимают сырые встроенные типы.
Мы теряем удобство использования переменной нового отдельного типа.
\end{enumerate}
Куда более правильный подход -- сказать, что размер \verb"size_" будет храниться внутри \verb"Vector" как сырой знаковый тип, а условие, что \verb"size_" обязана быть положительной -- это инвариант класса \verb"Vector".
Это позволит легко составлять любые арифметические выражения, используя \verb"size_" и мы не потеряем в надежности.

\item Еще один пример.
Предположим, вы работаете с геометрией и для этого используете библиотеку, которая предоставляет вам классы для матриц и векторов.
И вам нужны ортогональные матрицы.
Тогда вы можете создать новый класс ортогональных матриц
\begin{cppcode}
class OrthoMatrix {
public:
  ...
private:
  Lib::Matrix A_;
};
\end{cppcode}
Это кажется разумным.
Но, это крайне неудобно.
Ваши ортогональные матрицы теперь тип незнакомый библиотеке, которой вы пользуетесь.
Теперь эти матрицы не знают как умножаться на векторы, к ним не применимы алгоритмы библиотеки, весь функционал придется писать заново.
Это крайне не удобно.
Потому вводить такой класс -- плохая идея.
Если же вам нужны гарантии, что матрица будет ортогональная, то скорее всего это значит, что у вас есть другой класс, который хочет использовать эту матрицу и уже он будет поддерживать инвариант:
\begin{cppcode}
class Camera {
public:
  ...
private:
  // Camera keeps the invariant: LocalBasis_ is orthogonal matrix
  Lib::Matrix LocalBasis_;
  ...
};
\end{cppcode}
\end{enumerate}

\subsection{Структуры}

\begin{enumerate}
\item 
Пусть мы хотим создать структуру вида%
\footnote{Я сейчас игнорирую содержательные названия классов намеренно.}
\begin{cppcode}
struct A {
  int x;
  double y;
  B z;
};
\end{cppcode}
Не надо делать у структур конструкторы.
Вместо этого для структур есть aggregate initialization.
Это работает так
\begin{cppcode}
A a{5, 1.2, B()};
A a{.x = 5, .y = 1.2, .z = B()};
\end{cppcode}
В этом случае поля структуры напрямую инициализируются указанными значениями без вызова конструктора.
Если вам нужны дефолтные значения для переменных, то их можно указать напрямую в структуре
\begin{cppcode}
B getDefault();

struct A {
  int x = 42;
  double y = 1.2;
  B z = getDefault();
};
\end{cppcode}

\item
Не надо добавлять каких суффиксов и префиксов в название полей структуры вида \verb"x_" или \verb"m_x".
Все поля публичные и пользователь будет видеть именно такие имена.
Пусть у них будут нормальные названия.

\item
Если вам нужны методы для работы со структурой, то сделайте либо глобальный метод, либо в можно сделать статический метод
\begin{cppcode}
struct A {
  int x;
  double y;
  B z;
  
  static int f(const A&);
};

double g(const A&);

A a;
int value = A::f(a);
a.y = 2.2;
double c = g(a);
\end{cppcode}
Так как все поля публичные, любой метод может стучаться в структуру.

\item Не надо делать методы доступа к полям структуры.
Вы и так их можете инициализировать напрямую.
Но вот что бывает полезно сделать.
Предположим, что вы собираете дерево на основе нод и указателей и ваша нода выглядит так
\begin{cppcode}
struct Node {
  Data data;
  Node* parent = nullptr;
  Node* left = nullptr;
  Node* right = nullptr;
};
\end{cppcode}
И теперь вы хотите обрабатывать запросы к нодам через указатели на них.
Тогда вам придется обрабатывать случай \verb"nullptr".
Вот что имеется в виду
\begin{cppcode}
Node* node = ...;
if (node)
  node->data = Data{};
\end{cppcode}
Чтобы избежать проверки на \verb"nullptr" можно сделать отдельный метод, который проверяет указатель на вершину на \verb"nullptr" и только если она не нулевая, то меняется поле по указателю.
Это бывает удобно, бывает не удобно.
Но полезно знать, про такую опцию
\begin{cppcode}
void set_data(Node* node, Data data) {
  if (node == nullptr)
    return;
  node->data = std::move(data);
}

Node* node = ...;
set_data(node, Data{});
\end{cppcode}
В последней строчке все равно был ли \verb"node" нулевым или нет.
\end{enumerate}

\subsection{Классы}

\subsubsection{Дефолтные методы}

Как я уже написал выше, главная причина создания класса -- инвариант на данные.
Это не единственная причина (и не всегда достаточная%
\footnote{Всегда есть особые случаи, но это не значит, что у нас нет ориентиров на $99.9999\%$ случаев.}
), но основная.
Что надо понимать: когда мы создаем класс, то у любого класса (в том числе структуры) есть шесть дефолтных методов, которые автоматически генерируются компилятором.
Давайте я их укажу явно
\begin{cppcode}
class A {
public:
  A() = default;
  A(const A&) = default;
  A& operator=(const A&) = default;
  A(A&&) noexcept = default;
  A& operator=(A&&) noexcept = default;
  ~A() = default;
};
\end{cppcode}
Задача этих методов -- обеспечить семантику поведения объекта.
То есть мы хотим, чтобы объекты класса \verb"A" вели себя как переменные-стаканы, хранящие данные.%
\footnote{Это не всегда желаемое поведение, но так надежно по умолчанию.}
Давайте я назову эти методы явно
\begin{enumerate}
\item Конструктор по умолчанию (default constructor)

\item Конструктор копирования (copy constructor)

\item Копирующее присваивание (copy assignment)

\item Конструктор перемещения (move constructor)

\item Перемещающее присваивание (move assignment)

\item Деструктор (destructor)
\end{enumerate}
Запомните важное правило: если все переменные в классе обладают value semantics, то ни один из этих методов НЕ надо явно задавать.
Дефолтные значения сработают прекрасно.
В идеальном мире value semantics все выглядит как-то так:
\begin{cppcode}
class A {
public:
  A() = default;
  A(/*arguments*/);
  /*class public interface*/
private:
  int x_ = /*default value*/;
  std::vector<int> y_ = /*default value*/;
  B z_ = /*default value*/;
};
\end{cppcode}
Так же обратите внимание на правильную сигнатуру move операций.
Они обязательно помечаются \verb"noexcept".
Это делается для лучшей совместимости с алгоритмами STL.
Давайте расскажу про конкретный пример, в котором это важно.
Представьте, что вы имплементируете \verb"std::vector".
И вам надо имплементировать в нем реаллокацию.
Представим себе, что в векторе лежат элементы $a_1,\ldots, a_k$.
Тогда разумно было бы выделит новый сегмент памяти, и потом сделать move данных из $a_1$ в новую ячейку $b_1$ и так далее вплоть до $a_k\mapsto b_k$.
Однако, что если эта операция может кинуть исключение.
Тогда вы можете оказаться в ситуации, что часть данных уже переместилась, а часть еще нет.
И вам надо восстановить инварианты вектора и почистить лишнюю память до отпускания исключения.
Что можно сделать?
Надо бы вернуть данные из $b_1$ обратно в $a_1$ и т.д.
Но если move операции могут кидать исключение, то у нас опять может быть брошено исключение.
И тогда программа падает по \verb"terminate" ибо нельзя кидать два исключения за раз.
Потому, чтобы обработать корректно такую ситуацию, если move операции не помечены \verb"noexcept", то \verb"std::vector" при реаллокации будет использовать копирование вместо move!
И вы низачто не заметите где же у вас все время идут лишние копирования.

\subsubsection{Структура класса}

Я предпочитаю следующую структуру
\begin{cppcode}
class A {
  using Type0 = double;
public:
  using Type1 = int;

  A();
  A(Type1);
  A(const A&);
  A(A&&) noexcept;
  A& operator=(const A&);
  A& operator=(A&&) noexcept;
  ~A();
  
  void make_something() const;
  
  static  void do_something();
  
  static constexpr const Type1 default_value = 0;

protected:
  void do_protected_stuff();
private:
  void do_private_stuff();

  static Type0 private_static_data_;
  
  Type1 private_data_ = default_value;
};
\end{cppcode}
Из важного тут следующее.
Все переменные класса идут в конце в приватной части.
Так их легче найти.
перед ними идут статические переменные, чтобы их тоже было легко искать.
Публичный интерфейс идет в самом начале класса, потому что это та часть класса, через которую с ним будут взаимодействовать.
Перед публичным интерфейсом идут псевдонимы для удобства работы с классами.
Не перемешивайте между собой методы и статические методы.
Не перемешивайте между собой переменные класса, статические переменные и методы.
В начале публичного интерфейса если нужно явно определить находятся шесть методов обеспечивающих семантику класса.

\subsubsection{Как инициализировать классы}

Для инициализации классов используются конструкторы.
Конструктор по умолчанию инициализирует все поля, вызывая у них конструктор по умолчанию если такой есть (у встроенных типов его нет и ничего не вызывается).
\begin{center}
\begin{tabular}{ccc}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}
class A {
public:
  A()
   : x_(0), y_({1, 2}), z_(B(42)) {}
  // inconsistent value of y_
  A(int x)
   : x_(x), y_({1, 2, 3}), z_(B(42)) {}
private:
  int x_;
  std::vector<int> y_;
  B z_;
};
\end{cppcode}
\end{minipage}
}&{}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}
class A {
public:
  A() = default;
  // values of y_ and z_ are the same
  // for both constructors
  A(int x)
   : x_(x) {}
private:
  int x_ = 0;
  std::vector<int> y_ = {1, 2};
  B z_ = B(42);
};
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}
Если вы хотите задать дефолтные значения, то лучше задавать их при объявлении переменных, а дефолтный конструктор задать через \verb"=default".
Кроме того, в примере выше присутствуют три магические константы -- значения инициализации переменных.
Я предпочитаю либо заводить \verb"constexpr" дефолтные значения, либо методы для инициализации:
\begin{cppcode}
class A {
public:
  A() = default;
  A(int x) : x_(x) {}
private:
  static constexpr k_x_default_ = 0;
  static std::vector<int> makeStartingVector();
  static B makeDefault();
  
  int x_ = k_x_default_;
  std::vector<int> y_ = makeStartingVector();
  B z_ = makeDefault();
};
\end{cppcode}
Так же обратите внимание, если вы задали хотя бы один не дефолтный конструктор \verb"A(int)", то дефолтный не будет сгенерирован.
Это сделано намерено, потому что раз у вас объект конструируется из каких-то данных, то наверное нет способа построить корректно дефолтный объект и компилятор специально не генерирует дефолтный конструктор, чтобы у вас случайно не было ошибки.
Если вам он все же нужен и его дефолтная имплементация вам подходит, то надо лишь написать \verb"A() = default".
Не пишите \verb"A() {}" или другие версии.

Теперь поговорим о конструировании объектов из данных.
Давайте начнем со следующего примера
\begin{cppcode}
class A {
public:
  A(const B& b, const std::vector<int>& v)
   : b_(b), v_(v) {}
private:
  B b_;
  std::vector<int> v_;
};
\end{cppcode}
Я часто вижу такой код и его основная мотивация -- передаем по константной ссылке аргументы, чтобы избежать лишнего копирования.
Давайте обсудим, какие есть проблемы с таким конструктором, и как их решать.
Давайте разберем как это работает на примере кода
\begin{cppcode}
A a(B(3), {1, 2});
\end{cppcode}
Первый вопрос: сколько конструкторов будет вызывано кроме конструктора \verb"A"?
Оказывается тут будет аж $5$ конструкторов.
Давайте проанализируем как приблизительно это работает.
Код выше можно условно заменить на следующий фрагмент:
\begin{cppcode}
const B& b = B(3);
const std::vector<int>& v = {1, 2};
B b_(b);
std::vector<int> v_(v);
\end{cppcode}
В начале создастся временный объект \verb"B(3)" и он забиндится на константную ссылку \verb"b".
После чего создастся временный объект \verb"{1, 2}".
Но этот объект имеет тип \verb"std::initializer_list<int>".
После этого, чтобы можно было забиньдить \verb"v" на этот объект временный объект \verb"{1, 2}" конвертируется в \verb"std::vector<int>" (это еще один конструктор).
И уже после этого \verb"v" биндится на этот временный вектор.
После чего в третьей строчке содержимое \verb"b" копируется в \verb"b_" (еще один конструктор).
И аналогично в последней строчке содержимое \verb"v" копируется в \verb"v_".
То есть реально происходит следующее%
\footnote{Здесь последние две строчки хоть и изменились, но делают то же самое, это эквивалентный синтаксис.
Добро пожаловать в мир плюсов, где один и тот же вызов копирующего конструктора может быть вызван разным синтаксисом.}
\begin{cppcode}
B tmp = B(3); // ctor
const B& b = tmp;
std::initializer_list<int> list = {1, 2}; // ctor
std::vector<int> vec = list; //ctor
const std::vector<int>& v = vec;
B b_ = b; // copy ctor
std::vector<int> v_ = v; // copy ctor
\end{cppcode}
Конечно, можно надеяться, что компилятор что-нибудь из этого оптимизирует, но есть вещи, которые он обойти не сможет.
Давайте поговорим, что тут плохо, почему и как это исправлять:
\begin{enumerate}
\item Первое, что сразу бросается в глаза -- плохая идея принимать аргумент в виде ссылки на контейнер.
Так как в C++ разрешена одна конвертация для каждого аргумента функции, то происходит следующее, мы вместо \verb"std::vector<int>" передали объект, который является типом \verb"std::initializer_list<int>" и чтобы он забиндился на ссылку на константный вектор, приходится явно строить временный вектор.
Такую проблему с контейнерами можно решить, принимая явно список инициализации
\begin{cppcode}
A(const B& b, std::initializer_list<int> list)
  : b_(b), v_(list) {}
\end{cppcode}
Так мы избавляемся от одного лишнего конструктора построения временного вектора.
Обратите внимание, что \verb"std::initializer_list<int>" всегда передается by value.
Так как он не хранит данные, а сам он лишь является умной оберткой вокруг указателя на данные и потому передавать его по копии дешево, и работа с ним через указатель или ссылку стоит дороже за счет одного дополнительного разыменования указателя.
Тем не менее, такой подход тоже не является наилучшим, об этом ниже.

\item Другая проблема заключается в том, что мы в каждый аргумент конструктора передаем временный объект и потом копируем из него данные.
А именно
\begin{cppcode}
A a(B(3), {1, 2});
\end{cppcode}
Объект \verb"B(3)" создается в памяти и мы бы хотели своровать его содержимое, а не копировать внутрь \verb"b_", потому что временный объект все равно уничтожится.
И давайте сразу обсужу плохое решение, которое никогда не стоит применять -- передать по не константной ссылке данные
\begin{cppcode}
A(B& b, std::vector<int>& v)
 : b_(std::move(b)), v_(std::move(v)) {}
\end{cppcode}
Проблема в том, что такая не константная ссылка не биндится на все что угодно, как константная ссылка (это особенности языка).
Например, она никогда не биндится на временные объекты (потому что она не продлевает их время жизни).
Так же она не биндится на объекты другого типа (и не делает конвертации).
То есть
\begin{cppcode}
class A {
public:
  A(B& b, std::vector<int>& v)
   : b_(std::move(b)), v_(std::move(v)) {}
};

B b = B(3);
std::vector<int> v = {1, 2};
// OK
A a(b, v);
// compilation error, B(3) is temporary
A a(B(3), v);
// compilation error, {1, 2} has wrong type and temporary
A a(b, {1, 2});
// compilation error, both
A a(B(3), {1, 2});
\end{cppcode}

\item При использовании \verb"std::initializer_list" имейте в виду следующую особенность: он всегда хранит константные данные.
То есть данные из него никогда нельзя своровать и переместить внутрь.
Из него данные всегда копируются.
Это может быть очень неприятно и дорого для тяжелых объектов.
К сожалению это никак не обходится.

\item Обратим внимание, что мы принимаем аргументы в конструкторе ровно того типа, что мы храним внутри и мы хотим просто поглотить аргументы конструктора.
Такие аргументы называются sink arguments.
Sink argoments можно принимать by value, а именно
\begin{cppcode}
class A {
public:
  A(B b, std::vector<int> v)
   : b_(std::move(b)), v_(std::move(v)) {}
private:
  B b_;
  std::vector<int> v_;
};

B z = B(3);
std::vector<int> w = {1, 2};
// OK
A a(z, w);
// OK
A a(B(3), w);
// OK
A a(z, {1, 2});
// OK
A a(B(3), {1, 2});
\end{cppcode}
Давайте посмотрим, как работает первый вызов.
\begin{cppcode}
B b = z; // copy constructor
std::vector<int> v = w; // copy constructor
B b_ = std::move(b); // move constructor
std::vector<int> v_ = std::move(v); // move constructor
\end{cppcode}
Как мы видим в этом случае аргументы конструктора снимают копии с переданных \verb"z" и \verb"w", а потом содержимое аргументов мувается внутрь локальных переменных класса.
Теперь давайте посмотрим, как работает последний вызов.
Код можно условно заменить следующим
\begin{cppcode}
B b = B(3); // argument initialization
std::vector<int> v = {1, 2}; // argument initialization
B b_ = std::move(b); // move constructor
std::vector<int> v_ = std::move(v); // move constructor
\end{cppcode}
Как вы видите, в этом случае аргументы конструктора напрямую иницилизируются временными объектами, а потом их содержимое перемещается внутрь переменных класса.
Главный плюс этого метода -- мы можем передавать в конструктор как временные объекты, так и переменные.
Содержимое временных объектов воруется мувом, а с переменных мы снимаем копию.
И вот бывает, что мы не всегда хотим эту копию делать.
Этому посвящен следующий метод.

\item Еще один вариант для конструктора -- передавать данные по rvalue ссылке:
\begin{cppcode}
class A {
public:
  A(B&& b, std::vector<int>&& v)
   : b_(std::move(b)), v_(std::move(v)) {}
private:
  B b_;
  std::vector<int> v_;
};

B z = B(3);
std::vector<int> w = {1, 2};
// OK
A a(B(3), {1, 2});
// OK
A a(std::move(z), std::move(w));
// compilation error
A a(z, std::move(w));
// compilation error
A a(std::move(z), w);
\end{cppcode}
Этот метод работает так же как предыдущий, только он запрещает передавать <<не временные объекты>> в качестве аргументов.
То есть временные объекты передаются так же, как и выше, а вот переменные без \verb"std::move" передать внутрь такого конструктора не получится.
То есть такой конструктор используется, когда надо гарантировать, что данные всегда воруются.
А не снимаются копии.
Я обычно такие конструкторы делаю приватными и оборачиваю их в named constructor idiom, о которой речь пойдет ниже.

Еще одно отличие этого метода заключается вот в чем.
Давайте рассмотрим две имплементации и два вызова
\begin{center}
\begin{tabular}{ccc}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}
class A {
public:
  A(B b, std::vector<int> v)
    : b_(std::move(b)), v_(std::move(v)) {}
private:
  B b_;
  std::vector<int> v_;
};

B z = B(3);

A a(std::move(z), {1, 2});
\end{cppcode}
\end{minipage}
}&{}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}
class A {
public:
  A(B&& b, std::vector<int>&& v)
    : b_(std::move(b)), v_(std::move(v)) {}
private:
  B b_;
  std::vector<int> v_;
};

B z = B(3);

A a(std::move(z), {1, 2});
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}
В обоих случаях содержимое \verb"z" будет поглощено, но стоимость поглощения разная.
В первом случае это стоит два мува, первый мув -- из \verb"z" в аргумент конструктора \verb"b", а второй мув -- из \verb"b" в член класса \verb"b_".
Во втором случае в конструктор передается ссылка -- это копирование адреса объекта и остается один мув -- из \verb"b" в член класса \verb"b_".
Если мувы могут быть дорогими, то второй подход работает чуть лучше, ибо использует всего два мува против одного.
Имейте в виду это отличие.

\item Главный недостаток подхода со ссылками -- что если вы хотите часть аргументов копировать, а часть воровать?
Тогда вам придется делать $2^n$ конструкторов, где $n$ -- количество аргументов.
Действительно, сравните
\begin{center}
\begin{tabular}{ccc}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}
class A {
public:
  A(B  b, std::vector<int> v)
    : b_(std::move(b)), v_(std::move(v)) {}
    
    
        
    
    
private:
  B b_;
  std::vector<int> v_;
};

B z = B(3);
std::vector<int> w = {1, 2};
A a(z, w);
A a(std::move(z), w);
A a(z, std::move(w));
A a(std::move(z), std::move(w));
\end{cppcode}
\end{minipage}
}&{}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}
class A {
  A(const B&  b, const std::vector<int>& v)
    : b_(b), v_(v) {}
  A(const B&  b, std::vector<int>&& v)
    : b_(b), v_(std::move(v)) {}
  A(B&&  b, const std::vector<int>& v)
    : b_(std::move(b)), v_(v) {}
  A(B&&  b, std::vector<int>&& v)
    : b_(std::move(b)), v_(std::move(v)) {}
private:
  B b_;
  std::vector<int> v_;
};

B z = B(3);
std::vector<int> w = {1, 2};
A a(z, w);
A a(std::move(z), w);
A a(z, std::move(w));
A a(std::move(z), std::move(w));
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}

\item Последняя проблема обычно адресуется с помощью шаблонов и техники perfect forwarding так
\begin{cppcode}
class A {
public:
  template<class TB, class TV>
  A(TB&& b, TV&& v)
   : b_(std::forward<TB>(b)),
     v_(std::forward<TV>(v)) {}
private:
  B b_;
  std::vector<int> v_;
};

std::vector<int> w = {1, 2};
A a(z, w);
A a(std::move(z), w);
A a(z, std::move(w));
A a(std::move(z), std::move(w));
\end{cppcode}
Когда \verb"&&" применяется в аргументе функции к чистому шаблонному параметру (имеется в виду, нельзя написать \verb"std::vector<TB>&&", надо именно \verb"TB&&"), то она может трактоваться и как lvalue ссылка и как rvalue ссылка.
А std::forward либо ничего не делает (в случае lvalue ссылки), либо делает std::move (в случае rvalue ссылки).

\item Главный недостаток этого подхода в том, что все данные передаются по ссылке.
Это хорошо для тяжелых объектов, но не очень эффективно для встроенных типов.
В целом это можно игнорировать, либо если вы знаете, что вы передаете встроенные типы, то передавайте их по значению, а не по ссылке там, где справитесь это сделать.
\end{enumerate}


\subsubsection{Инициализация шаблонных классов}

Предположим у вас есть шаблонный класс
\begin{cppcode}
template<class T, class B>
class A {
public:
  ...
private:
  T b_;
  std::vector<B> v_;
};
\end{cppcode}
И мы так же хотим написать конструктор для этого класса, который бы эффективно принимал данные.
Мы можем обойтись подходом с sink arguments и сделать так
\begin{cppcode}
template<class T, class B>
class A {
public:
  A(T b, std::vector<B> v)
   : b_(std::move(b)), v_(std::move(v)) {}
private:
  T b_;
  std::vector<B> v_;
};
\end{cppcode}
Либо если мы хотим гарантировать, что данные обязательно будут сворованы написать
\begin{cppcode}
template<class T, class B>
class A {
public:
  A(T&& b, std::vector<B>&& v)
   : b_(std::move(b)), v_(std::move(v)) {}
private:
  T b_;
  std::vector<B> v_;
};
\end{cppcode}
Обратите внимание, что тут \verb"T&&" это только rvalue ссылка, так как \verb"T" это НЕ шаблонный аргумент конструктора, для конструктора это уже вполне определенный известный тип.
А теперь вопрос, что если тип \verb"T = int", тогда в этом подходе мы будем передавать встроенный тип по ссылке.
А ссылка -- это все равно что указатель.
То есть мало того, что вместо 4 байт мы теперь передаем 8, так еще и для обращения к данным надо пройти по указателю.
В целом плохая идея встроенные типы передавать не by value.
В этом случае можно завести вспомогательный тип, который решает, как именно принимать аргумент
\begin{cppcode}
template<class T, class B>
class A {
  template<class X>
  using Arg = If</*type X is small*/>::Then<X>::Else<X&&>;
  using TArg = Arg<T>;
public:
  A(TArg b, std::vector<B>&& v)
   : b_(std::move(b)), v_(std::move(v)) {}
private:
  T b_;
  std::vector<B> v_;
};
\end{cppcode}
Здесь в 3-4 строчках описан шаблон, который решает в зависимости от условия на тип \verb"X" какой тип использовать \verb"X" или \verb"X&&".
Для имплементации можно воспользоваться стандартными шаблонами, например так:
\begin{cppcode}
template<class X>
using Arg = std::conditional_t<std::is_arithmetic_v<X>, X, X&&>;
\end{cppcode}
Тогда \verb"Arg<X>" будет \verb"X" для всех арифметических типов C++, и \verb"X&&" для всех остальных типов.
Но можно настроить условие более тонко в зависимости от того, чего вы хотите.
В целом передавать данные размером в 3-4 указателя можно считать дешево.
И потому \verb"std::pair<int, int>" тоже можно передавать by value.

\subsubsection{Пример имплементации всех шести и RAII}
\label{section::siximpl}

Предположим я хочу написать класс, который умеет хранить \verb"int" на куче.
Тогда мне надо написать
\begin{cppcode}
class IntOnHeap {
public:
  IntOnHeap();
  IntOnHeap(int);
  IntOnHeap(const IntOnHeap&);
  IntOnHeap& operator=(const IntOnHeap&);
  IntOnHeap(IntOnHeap&&) noexcept;
  IntOnHeap& operator=(IntOnHeap&&) noexcept;
  ~IntOnHeap();
private:
  int* value_;
};
\end{cppcode}
Таким образом мы хотим написать класс, который будет сам менеджерить ресурс.
Это значит, что класс больше ничего не должен делать кроме этого.
Техника использования подобных менеджерящих классов называется Resource Acquisition Is Initialization (RAII, смотри раздел~\ref{section::RAII}).%
\footnote{На самом деле более обще так называют любую технику, когда надо захватить какой-то ресурс в конструкторе и освободить его автоматически в деструкторе.}
Давайте напишем имплементации для всех этих методов.

\paragraph{Конструктор по умолчанию}

Начнем с самого простого -- создание объекта по умолчанию.
В этом случае полезно инициализировать все поля класса при объявлении и дать дефолтную имплементацию.
\begin{cppcode}
class IntOnHeap {
public:
  IntOnHeap() = default;
  ...
private:
  int* value_ = nullptr;
};
\end{cppcode}
Такой подход предполагает, что у нас объект \verb"IntOnHeap" может ничего внутри не содержать.
Это разумно, если мы сделали мув данных из него.
Так что мы поддерживаем дефолтный конструктор, который не выделяет ресурсы.

\paragraph{Конструктор от данных и деструктор}

Теперь чтобы продемонстрировать как писать деструктор, мы дополнительно напишем конструктор от данных.
Он формально не входит в шесть автоматически генерируемых методов, но я предпочитаю их писать парой.
\begin{cppcode}
class IntOnHeap {
public:
  IntOnHeap(int value) : value_(new int(value)) {}
  ~IntOnHeap() {
    delete value_;
  }
private:
  int* value_ = nullptr;
};
\end{cppcode}
В конструкторе и деструкторе мы просто создаем и чистим ресурс.
Теперь надо заняться копированием и перемещением данных.

\paragraph{Перемещающий конструктор}

Перемещающий конструктор перемещает данные в еще не созданный объект.
То есть поля класса для \verb"this" уже аллоцированы, но объект мы должны все еще построить.
\begin{cppcode}
class IntOnHeap {
public:
  IntOnHeap(IntOnHeap&& other) noexcept
   : value_(std::exchange(other.value_, nullptr)) {}
  ...
private:
  int* value_ = nullptr;
};
\end{cppcode}
С конструктором все просто -- надо переместить указатель из \verb"other" в \verb"this", а потом указатель в \verb"other" надо заменить на \verb"nullptr".
Для удобства мы воспользовались функцией \verb"std::exchange", которая сохраняет содержимое первого аргумента, потом заменяет значение первого аргумента вторым, и после возвращает старое значение первого аргумента.

Обратите внимание, что перемещающий конструктор (как и перемещающее присваивание) помечено как \verb"noexcept".
Это важная часть сигнатуры перемещаюищих конструктора и присваивания.
Дело в том, что многие шаблонные классы проверяют можно ли объект переместить без исключений и в зависимости от этого меняется их поведение.
Самый яркий пример -- \verb"std::vector".
Если нужно при реаллокации переместить данные из одного буффера в другой, то используется перемещающий конструктор только если он помечен \verb"noexcept".
Если же перемещающие операции могут кинуть исключения, то \verb"std::vector" использует копирующий конструктор.
Это может очень сильно ударить по производительности и обнаружить такую проблему очень не просто.

\paragraph{Перемещающее присваивание}

Принципиальное отличие перемещающего конструктора от перемещающего присваивания в том, что у конструктора объект \verb"this" строится прямо сейчас и потому в нем, во-первых, нет никаких данных и их не надо чистить, а во-вторых, он не может совпасть с \verb"other".
В операторе присваивания придется обработать эти случаи.
Существует подход, в котором вам не придется проверять равенство \verb"this" и \verb"other".
Например так:
\begin{cppcode}
class IntOnHeap {
public:
  IntOnHeap& operator=(IntOnHeap&& other) noexcept {
    IntOnHeap tmp = std::move(other);
    std::swap(value_, tmp.value_);
    return *this;
  }
  ...
private:
  int* value_ = nullptr;
};
\end{cppcode}
Первая строчка оператора создает временый объект \verb"tmp" и перемещает в него содержимое \verb"other".
Это всего лишь три присваивания указателей.%
\footnote{Если вы думаете почему 3, а не 1, то вспомните, что мы используем \verb"std::exchange".}
После этой строчки нам надо выполнить перемещение данных из \verb"tmp" в \verb"this".
Но теперь заметьте, что \verb"tmp" и \verb"this" гарантированно будут разными объектами, значит мы избавились от проверки на самопроисваивание.%
\footnote{В целом плохая идея проверять на самоприсваивание, так как вы вставляете оператор условного перехода в каждой процедуре присваивания.
Но при этом самоприсваивание почти никогда не происходит в коде.
То есть вы ставите защиту от случая, которого почти нет и при этом бьете по производительности во всех остальных случаях.
Так лучше не делать.
Справедливости ради, надо сказать, что в этом решении мы все же платим цену за обработку самоприсваивания.
Но эта стоимость -- один лишний мув конструктор, а это всего лишь несколько лишних присваиваний указателя, что сильно лучше, наличия условного перехода.}
Если \verb"this" не был равен \verb"other", то мы просто сделали лишнее перемещение данных.
Если же \verb"this" совпадал с \verb"other", то мы переместили данные из \verb"this" в \verb"tmp" и теперь их надо вернуть обратно.
Вторая строчка меняет содержимое \verb"tmp" и \verb"this".
Уничтожение данных, которые находились в \verb"this" будет произведено деструктором \verb"tmp".%
\footnote{Обратите, что тут нельзя вызвать \verb"std::swap(*this, tmp)", потому что эта функция будет вызывать оператор присваивающего перемещения, который мы и имплементируем, то есть мы вызовем бесконечную рекурсию.}

\paragraph{Копирующий конструктор}
Тут ситуация похожа на перемещающий конструктор, только обычно мы выделяем ресурсы под копию и копирующий конструктор не обязан быть \verb"noexcept".
\begin{cppcode}
class IntOnHeap {
public:
  IntOnHeap(const IntOnHeap& other)
   : value_((other.value_ ? new int(*other.value_) : nullptr)) {}
  ...
private:
  int* value_ = nullptr;
};
\end{cppcode}
В копирующем конструкторе главное -- не забыть обработать случай \verb"nullptr" в \verb"other.value_".
Вообще каждый раз когда вы разыменовываете указатель полезно вспоминать о проверке, что это не всегда можно сделать.

\paragraph{Копирующее присваивание}
Теперь можно написать копирующее присваивание.
Оказывается, что он полностью выражается через предыдущие методы.
\begin{cppcode}
class IntOnHeap {
public:
  IntOnHeap& operator=(const IntOnHeap& other) {
    return *this = IntOnHeap(other);
  }
  ...
private:
  int* value_ = nullptr;
};
\end{cppcode}
Обратите внимание, что мы имплементируем копирующее присваивание через копирующий конструктор и перемещающее присваивание.
Такой подход не требует проверки на самоприсваивание, однако, при самоприсваивании, мы перезапимываем в\verb"this" его копию.
Такое поведение бывает неприемлемым (например, потому что оно не корректно, если мы хотим в точности сохранить те данные, что были).
В таком случае приходится добавлять проверку на самоприсваивание, тут ничего не поделаешь:
\begin{cppcode}
class IntOnHeap {
public:
  IntOnHeap& operator=(const IntOnHeap& other) {
    if (this == &other)
      return *this;
    return *this = IntOnHeap(other);
  }
  ...
private:
  int* value_ = nullptr;
};
\end{cppcode}
Тут надо смотреть по ситуации, какое поведение вам подходит.
Бывают разные случаи.

\paragraph{Слияние операторов присваивания}
Если вам не важна проблема при самоприсваивании, то можно слить копирующий конструктор и перемещающий конструктор в один метод.
Хотя я лично не люблю заигрывать с компилятором.
\begin{cppcode}
class IntOnHeap {
public:
  IntOnHeap& operator=(IntOnHeap other) noexcept {
    return *this = std::move(other);
  }
  ...
private:
  int* value_ = nullptr;
};
\end{cppcode}
При такой имплементации при выполнении присваивания
\begin{cppcode}
IntOnHeap a;
IntOnHeap b;
a = b;
a = std::move(b);
\end{cppcode}
В строчке $3$ происходит копирование данных из \verb"b" в аргумент конструктора \verb"other" и потом мув данных в \verb"a".
В $3$ происходит мув данных из \verb"b" в аргумент конструктора \verb"other" и потом мув данных из него в \verb"a".

\paragraph{Особенности генерации методов по умолчанию}

Теперь сделаем важное замечание.
Если вы определяете свой move constructor, но не определяете move assignment (или наоборот).
То компилятор НЕ сгенерирует move assignment по умолчанию.
Сделано это для того, чтобы избежать рассинхрона между вашей операцией перемещения данных и дефолтной.
Однако, если вы определите свой copy constructor, но не определите copy assignment (или наоборот), то компилятор сгеренрирует copy assignment по дефолту.
Я не знаю зачем так сделали, видимо для того, чтобы компилировался код времен Кеннеди.
Но это один из источников проблем.
Так как компилятору разрешается подменять copy constructor и copy assignment друг другом, то это один из источников UB.
Потому если вы пишете один из этих четырех операторов, то определяйте все четыре.
Так же бывают ситуации, когда вам нужно явно удалить возможность копировать или перемещать.
Это делается так
\begin{cppcode}
class A {
public:
 A() = default;
 A(const A&) = delete;
 A& operator=(const A&) = delete;
 A(A&&) noexcept = delete;
 A&operator=(A&&) noexcept = delete;
 ~A() = default;
};
\end{cppcode}
В целом хорошо взять за правило, что если вы определяете что-то из дефолтных методов (кроме дефолтного конструктора), то определите все пять (кроме быть может дефолтного конструктора).
При этом если вам надо взять имплементацию по умолчанию, используйте \verb"=default", а если вы хотите убрать соответствующий метод, то значение \verb"delete".

\subsubsection{Аргументы конструктора и Strong Type Aliases}
\label{section::CtorArgs}

Часто бывает, что конструктор принимает аргументы одинакового типа.
Пусть у нас есть класс, для работы с мономами, то есть выражениями вида $x_0^{k_0}\cdot \ldots \cdot x_n^{k_n}$.
И пусть его можно построить по индексу переменной и ее степени.
\begin{cppcode}
class Monomial {
public:
  Monomial(size_t index, size_t degree);
  size_t degree_of(size_t index) const;
private:
  ...
};
\end{cppcode}
Здесь есть несколько вещей, которые мне не нравятся.
\begin{enumerate}
\item Во-первых, беззнаковый тип.
Это я обсуждал в разделе~\ref{section::Class::RawData}.

\item Но даже, если переделать все в знаковый тип, то становится не лучше, так как тип \verb"int" будет представлять две разные вещи: одна -- индекс переменной, другая -- степень переменной.
Для повышения читаемости стоит ввести локальный псевдоним:
\begin{cppcode}
class Monomial {
  using Index = int;
  using Degree = int;
public:
  Monomial(Index index, Degree degree);
  Degree degree_of(Index index) const;
private:
  ...
};
\end{cppcode}
Это не позволяет избавиться от ошибок, если вы перепутаете аргументы, но повысит читаемость и поддерживаемость кода.
Например, если вы решили, что \verb"Index" занимает слишком много места и вам достаточно одного байта.
То вам не придется менять во всех методах сырые типы, вы просто напишете
\begin{cppcode}
class Monomial {
  using Index = char;
  using Degree = int;
public:
  Monomial(Index index, Degree degree);
  Degree degree_of(Index index) const;
private:
  ...
};
\end{cppcode}
То есть сырые типы, это то же самое, что магические константы, только на уровне типов.
Если вы хотите быстро менять подлежащий тип внутри класса, то заводите для всех вспомогательных типов псевдонимы.
Так как это не глобальные, а локальные псевдонимы внутри класса, то нет ничего страшного в том, что для компилятора они одинаковые.
Ибо в рамках класса мы можем довериться, что программист рассмотрел и проверил все случаи использования.
Однако, в публичном интерфейсе все еще могут происходить ошибки.
Например, мы можем перепутать индекс переменной и степень местами и компилятор нам не поможет.

\item
\label{item::CtorArgs}
Давайте посмотрим на вызов конструктора нашего класса
\begin{cppcode}
Monomial m(1, 3);
\end{cppcode}
В этом случае не понятно, что вообще происходит.
Читаемость кода на уровне пользователя никакая.
Кроме того, мы не застрахованы от ошибки перепутать аргументы местами.
Это частая беда, когда аргументы одного типа идут вместе.
Тут можно применить технику strongly typed alias-ов, то есть псевдонимов, которые будет различать компилятор.
Для встроенных целочисленных типов это делается очень легко.
\begin{cppcode}
enum Index : char;

class Monomial {
  using Degree = int;
public:
  Monomial(Index index, Degree degree);
  ...
};
\end{cppcode}
Тогда на стороне пользователя можно написать
\begin{cppcode}
Monomial m(Index{1}, 3);
\end{cppcode}
Теперь аргументы точно не перепутаешь.
Если подставить в первый аргумент целочисленный тип -- ошибка компиляции.
Однако, название типа \verb"Index" ничего не говорит нам о назначении константы и смысл второго числа не ясен.
Тем не менее, я специально остановился на этом решении, чтобы вы имели в виду, что иногда бывает, что не надо делать псевдонимы для всех аргументов, иногда достаточно для части.
Но можно сделать и так.
\begin{cppcode}
enum Variable : char;
enum Degree : int;

class Monomial {
public:
  Monomial(Variable index, Degree degree);
  ...
};

Monomial m(Variable{1}, Degree{3});
\end{cppcode}
Другой пример, когда это бывает полезно.
Сравните
\begin{cppcode}
class Picture {
public:
  Picture(size_t width, size_t height);
};

Picture p(300, 400);
\end{cppcode}
и имплементацию со строгими псевдонимами
\begin{cppcode}
enum Width : size_t;
enum Height : size_t;

class Picture {
public:
  Picture(Width width, Height height);
};

Picture p(Width{300}, Height{400});
\end{cppcode}

\item Если же надо проделать такую же штуку с числами с плавающей запятой, то это к сожалению не сработает.
Так как нельзя создать \verb"enum" с таким подлежащим типом.
Придется создавать целую структуру.
\begin{cppcode}
class Scale {
public:
  explicit Scale(double value) : value_(value) {
  }
  operator double() const {
    return value_;
  }
private:
  double value_;
};

enum Width : size_t;

class Picture {
public:
  Picture(Width width, Scale scale);
};
\end{cppcode}
Давайте отмечу пару важных моментов
\begin{enumerate}
\item Конструктор \verb"Scale" специально сделан \verb"explicit", чтобы избежать неявной конвертации от \verb"double" к \verb"Scale".

\item Нельзя сделать \verb"Scale" структурой с публичным полем \verb"value".
Потому что в этом случае \verb"Scale" можно инициализировать с помощью aggregate initialization, а именно
\begin{cppcode}
struct Scale {
  explicit Scale(double value) : value_(value) {
  }
  double value_;
};

void f(Scale x);

f({1.2});
\end{cppcode}
В последней строчке не требуется указывать имя класса.
Потому приватность \verb"value" запрещает такой механизм.
\end{enumerate}

\item Оба подхода можно завернуть в шаблоны.
В случае целых чисел
\begin{cppcode}
namespace detail {
template<class T, class Tag>
struct Enum {
  enum type : T;
};
}
template<class T, class Tag>
using AliasE = typename detail::Enum<T, Tag>::type;
\end{cppcode}
И использовать так
\begin{cppcode}
using Width = AliasE<int, struct width_tag>;
using Height = AliasE<int, struct height_tag>;
\end{cppcode}
Для чисел с плавающей запятой можно сделать так
\begin{cppcode}
template<class T, class Tag>
struct Alias {
  explicit Alias(T value) : value_(value) {
  }
  operator T() const {
    return value_;
  }

private:
  T value_;
};
\end{cppcode}
И используется так
\begin{cppcode}
using Scale = Alias<double, struct scale_tag>;
\end{cppcode}
В обоих случаях второй аргумент используется для того, чтобы сделать разные типы с подлежащим типом \verb"T".
Если не использовать \verb"Tag", то все псевдонимы с типом \verb"double" окажутся одним и тем же типом.
Это отличает этот тип от \verb"double", но не отличает их между собой.
\end{enumerate}

\subsubsection{Named Constructor Idiom и RVO/NRVO}

Предположим, что мы хотим написать класс комплексных чисел и сделать в нем два конструктора.
Один создает комплексное число по вещественной и мнимой части, другой по радиусу и аргументу.
Тогда мы бы могли написать так
\begin{cppcode}
class Complex {
public:
  Complex(double re, double im);
  Complex(double r, double phi);
  ...
};
\end{cppcode}
Однако, это ошибка компиляции, потому что мы только что объявили одну и ту же функцию.
В плюсах имена аргументов не отличают функции, только их типы.
Потому в точности так сделать нельзя.
В этом случае можно завести специальную функцию, которая будет строить комплексные числа.
\begin{cppcode}
class Complex {
  Complex(double re, double im);
public:
  static Complex FromReIm(double re, double im) {
    return Complex(re, im);
  }
  static Complex FromRadArg(double r, double phi) {
    return Complex(r * cos(phi), r * sin(phi));
  }
  ...
};
\end{cppcode}
В этом случае на стороне пользователя код выглядит так
\begin{cppcode}
Complex z = Complex::FromReIm(1, 2); // z = 1 + 2i
auto w = Complex::FromRadArg(1, 90); // z = i
\end{cppcode}
Тут я предполагаю, что аргумент в градусах, а не радианах.
Можно использовать для аргумента комплексного числа два разных псевдонима для работы с радианами или градусами.
В этом случае будет две статические функции строящие число по радиусу и аргументу.
Обратите внимание, что при вызове функции \verb"FromReIm" в первой строчке тригерится RVO и комплексное число создается конструктором сразу по адресу \verb"z".
Никаких лишних копий создаваться не будет.

У данного метода есть неожиданный плюс.
Кроме говорящего имени для конструктора и возможности использовать auto, возникает еще техническое удобство, которое я хочу обсудить.
Предположим, мы хотим создать класс
\begin{cppcode}
class A {
public:
  A(const char * str) : a_(strlen(str)), b_(strlen(str)), str_(str) {}
private:
  std::vector<int> a_;
  std::vector<int> b_;
  std::string str_;
};
\end{cppcode}
Смотреть надо на эту операцию так.
У нас есть одна дорогая операция -- вычисление \verb"strlen(str)", которую надо выполнить для обоих аргументов.
В этом случае синтаксис списка инициализации просто не дает возможности сохранять промежуточные вычисления.
Конкретно в этом примере, можно передать длину вместе со строкой, но тогда нет гарантии, что пользователь снаружи подставит честную длину строки, а не случайное число, что не надежно.
Да и бывает, что мы не хотим менять интерфейс конструктора и принимать не то, что мы хотим.
Тогда можно поступить так.
Правильный, но ненадежный конструктор делаем приватным, и потом дергаем его либо в другом конструкторе, либо в статической функции.
\begin{cppcode}
class A {
  A(const char * str, size_t len) : a_(len), b_(len), str_(str) {}
public:
  A(const char * str) : A(str, strlen(str)) {} // delegates
  static A FromStr(const char * str) {
    size_t len = strlen(str);
    return A(str, len); // here it is safe to call
  }
private:
  std::vector<int> a_;
  std::vector<int> b_;
  std::string str_;
};
\end{cppcode}

%\subsubsection{Конструирование сложных объектов и Builder Pattern}
%\label{section::Builder}

\subsubsection{Приведение типов и ADL}

\paragraph{Обычные функции}

Есть еще одна деталь, которую я хочу обсудить.
И связана она с приведением типов друг к другу и на что это влияет.
Самый важный элемент языка -- ADL или argument dependent lookup.
Это механизм, который отвечает за то, какая именно функция будет вызвана для написанного выражения.
А именно, предположим что у нас есть две функции:
\begin{cppcode}
void f(A);
void f(B);
\end{cppcode}
И мы хотим позвать функцию так
\begin{cppcode}
A a;
f(a);
\end{cppcode}
Компилятор видит, что используется имя \verb"f" вместе с оператором скобки и ищет все сущности языка, которые сюда могут подойти (это могут быть функции, это могут быть функторы (объект класса с перегруженным оператором скобки), это может быть шаблон функции).
Он видит два варианта выше.
Теперь ему надо выбрать.
В данном случае тип предаваемого выражения совпадает с типом аргумента и компилятор выбирает первую функцию.
Однако, если у нас будет вызов вид
\begin{cppcode}
C c;
f(c);
\end{cppcode}
То точного совпадения типов нет.
Компилятор на этом не останавливается.
Он смотрит, есть ли какой нибудь способ за один шаг сконвертировать передаваемое выражение \verb"c" к типу \verb"A".
За конвертацию типов в языке отвечают два вида функций:
\begin{enumerate}
\item Конструкторы от одного аргумента

\item Операторы конвертации типов
\end{enumerate}
Например тип \verb"C" можно конвертировать к \verb"A" в одном из следующих двух случаев
\begin{center}
\begin{tabular}{cc}
{
\begin{minipage}[\baselineskip]{5.5cm}
\begin{cppcode}[numbers = none]
class C {};
class A {
public:
  A(C);
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{5.5cm}
\begin{cppcode}[numbers = none]
class A {};
class C {
public:
  operator A() const;
};
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}
Если компилятор не находит способ неявно сконвертировать \verb"C" к \verb"A" или \verb"B", то это ошибка компиляции, нет нужного метода.
Если находит несколько способов сконвертировать -- это тоже ошибка компиляции (неоднозначность).
В противном случае компилятор делает одну конвертацию.
Например, если доступна конвертация \verb"C" к \verb"A", то
\begin{cppcode}
C c;
f(c);
// replaces with
f(A(c));
\end{cppcode}
и тут используется либо конструктор \verb"A", либо оператор приведения типа из \verb"C".
Чтобы подавить неявную конвертацию, можно обозначить указанные выше функции методом \verb"explicit" и тогда компилятору будет запрещено вызывать их неявно.
\begin{center}
\begin{tabular}{cc}
{
\begin{minipage}[\baselineskip]{5.5cm}
\begin{cppcode}[numbers = none]
class C {};
class A {
public:
  explicit A(C);
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{5.5cm}
\begin{cppcode}[numbers = none]
class A {};
class C {
public:
  explicit operator A() const;
};
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}
Бывают разные ситуации, хотим ли мы неявную конвертацию или не хотим.
Потому полезно знать на какие механизмы наличие этой операции может повлиять.

\paragraph{Шаблонные функции}

Кроме обычных функций в плюсах есть еще шаблонные функции.
Важно запомнить, что для шаблонных функций никогда не рассматривается конвертация типов.
Потому что компилятор по аргументу пытается подобрать лучший вид шаблонного параметра.
Например
\begin{cppcode}
struct C {
};

template<class T>
struct D {
  D(C) {}
};

template<class T>
void f(D<T>) {}
\end{cppcode}
В этом случае вызов
\begin{cppcode}
C c;
f(c); // compilation error
\end{cppcode}
Будет ошибкой компиляции, так как нет шаблонного аргумента \verb"T" для которого \verb"D<T>" в точности совпал с \verb"C".
Но по простому можно запомнить, что для шаблонных функций конвертация типов никогда не происходит.

\subsubsection{Делегирование при инициализации}

Частой проблемой является написание огромного количества конструкторов от кучи разных данных, например что-то в духе
\begin{cppcode}
class A {
public:
  A() = default;
  A(int);
  A(double);
  A(Matrix);
  ...
  A(File);
  A(Stream);
  ...
};
\end{cppcode}
Проблема такого подхода не только в раздутом интерфейсе, а в том, что класс начинает заниматься вещами, которыми он заниматься не должен.
Например, если вы конструируете объект из файла, то вы этот файл должны парсить в зависимости от формата, потому вы начинаете писать вспомогательные функции для парсинга файла внутри класса \verb"A" и вот теперь вы уже не можете отследить, что относится к классу, а что к вспомогательным иррелевантным для класса функциям.
Вместо того, чтобы заниматься такой ерундой, стоит делегировать всю нетривиальную работу другим классам.
Давайте разберем пример чтения из файла.
\begin{cppcode}
class Picture {
public:
  Picture() = default;
  Picture(std::filesystem::path file);
  ...
};
\end{cppcode}
Во-первых, можно избавиться от конструктора и заменить его по named constructor idiom статической функцией с говорящим названием.
\begin{cppcode}
class Picture {
public:
  Picture() = default;
  
  static Picture FromFile(std::filesystem::path file);
  ...
};
\end{cppcode}
А уже внутри метода \verb"FromFile" делегировать работу по чтению и открытию файла специальному объекту, например \verb"ifsream", работу по парсингу файла специальному классу \verb"Parser".
И уже после того как вы извлечете данные из файла можно создать соответствующий объект \verb"Picture".
Тогда имплементация выглядит как-то так:
\begin{cppcode}
Picture Picture::FromFile(std::filesystem::path file) {
  std::ifstream stream(file);
  Parser parser;
  Data data = parser(stream);
  return Picture(std::move(Data));
}
\end{cppcode}

\subsubsection{Сериализация}
\label{section::Serialization}
\paragraph{Что такое сериализация}

Вопрос чтения и записи в файл или из файла тесно связан с таким вопросом как сериализация данных.
По сути сериализация данных -- это запись данных в поток, а десериализация -- это чтение данных из потока.
Есть два синтаксических подхода для сериализации и десериализации:
\begin{enumerate}
\item Перегрузка потоковых операторов \verb"operator<<" и \verb"operator>>".

\item Написание специальных функций чтения и записи.
\end{enumerate}
И тут я хочу сразу начать с предосторожности.
Дело в том, что у оператора вывода \verb"operator<<" есть два смысла, а у оператора \verb"operator>>" только один и это приводит к путанице.
Давайте поясню на примере.
Пусть у нас есть класс
\begin{cppcode}
class A {
public:
private:
  int x_;
  std::vector<double> vec_;
};
\end{cppcode}
И мы для удобства хотим вывести пользователю на печать содержимое данных \verb"A", например ради дебага.
Тогда бы мы написали что-то вроде
\begin{cppcode}
std::ostream& operator<<(std::ostream& out, const A& a) {
  out << "x = " << a.x_ << '\n';
  out << "vec: ";
  for(double element : a.vec_)
    out << element << ", ";
  return out;
}
\end{cppcode}
Смысл этого оператора -- вывести данные в поток для чтения человеком, а не для хранения этих данных в потоке.
Если же мы хотим записать этот же объект в файловый поток для хранения, мы бы написали
\begin{cppcode}
std::ofstream& operator<<(std::ofstream& out, const A& a) {
  out << a.x_;
  out << a.vec_.size();
  for(double element : a.vec_)
    out << element;
  return out;
}
\end{cppcode}
Так вот, оператор чтения из потока \verb"operator>>" является дополнительным ко второй версии оператора \verb"operator<<", а у первой версии его просто нет.
То есть для чтения из потока мы бы сделали что-то такое
\begin{cppcode}
std::ifstream& operator<<(std::ifstream& in, A& a) {
  in >> a.x_;
  size_t size;
  in >> size;
  a.vec_.reserve(size);
  double element;
  for(size_t i = 0; i < size; ++i) {
    in >> element;
    a.vec_.push_back(element);
  }
  return in;
}
\end{cppcode}
Тут же скажу, что обозначенный выше подход не совсем грамотный, как именно писать имплементацию обоих операторов я скажу ниже.
Сейчас важно лишь, что для оператора записи в поток есть две версии: для человека и для хранения, а для чтения только одна.
Запись и чтение из потока для сохранения состояния объекта и его восстановление -- это две взаимно обратные процедуры и они и называются сериализацией и десериализацией.
Именно их я буду обсуждать ниже.
Важно отметить, что сериализовать и десериализовать намного легче, если объекты обладают value semantics.
В этом случае задача сериализации и десериализации может решаться локально (это может быть не самое эффективное, но в то же время самое простое решение).
Под локально я имею в виду, что каждый класс для своей сериализации и десериализации не должен будет знать никакой глобальной информации или контекста.

\paragraph{Как правильно писать сериализацию}

Будем считать, что мы работаем с классом
\begin{cppcode}
class Picture {
  ...
private:
  Header header_;
  std::vector<Pixel> data_;
};
\end{cppcode}
За чтение и запись в поток должен отвечать отдельный класс.
Можно сделать единый класс для чтения и записи, а можно сделать отдельные.
Например так
\begin{cppcode}
class PicReader {};
class PicWriter {};
// or
class PicSerializer {};
\end{cppcode}

\paragraph{Потоковые операторы}
Давайте я выберу первую версию из двух классов.
Начнем с синтаксического подхода с операторами \verb"operator<<" и \verb"operator>>".
В начале вам надо перегрузить эти операторы для всех встроенных типов
\begin{cppcode}
PicWriter& operator<<(PicWriter& out, int x) {
  out << x;
  return out;
}
PicReader& operator>>(PicReader& in, int& x) {
  in >> x;
  return in;
}
\end{cppcode}
Всю эту рутинную работу можно сделать с помощью шаблонов и проверки того, что типы удовлетворяют \verb"std::is_arithmetic_v".
После этого надо перегрузить оператор для всех контейнеров, которые вы хотите использовать
\begin{cppcode}
template<class T, class A>
PicWriter& operator<<(PicWriter& out, const std::vector<T, A>& vec) {
  out << vec.size();
  for(const auto& element : vec)
    out << element;
  return out;
}
PicReader& operator>>(PicReader& in, std::vector<T, A>& vec) {
  vec.clear();
  size_t size;
  in >> size;
  vec.reserve(size);
  T element;
  for(size_t i = 0; i < size; ++i) {
    in >> element;
    vec.push_back(std::move(element));
  }
  return in;
}
\end{cppcode}
То есть теперь вы умеете сериализовать и десериализовать все встроенные типы и стандартные контейнеры (если вы все это имплементировали).
Теперь, чтобы можно было сделать всю работу рекурсивно, все поля класса должны обладать value semantics (что это такое можно глянуть в разделе~\ref{section::Semantics}).
Это необходимое, но не достаточное условие.
Проблемы могут быть со всякими полиморфными объектами, про которые мы поговорим в разделе~\ref{section::Polymorphism}.
Сериализация класса должна выполняться по правилу:
\begin{enumerate}
\item Если класс хочет уметь сериализоваться и десериализоваться, то все его поля должны уметь сериализоваться и десериализоваться.

\item Каждый класс должен делегировать свою сериализацию и десериализацию каждому своему полю.
\end{enumerate}
Тогда оператор для класса \verb"Picture" выше будет выглядеть так
\begin{cppcode}
template<class T, class A>
PicWriter& operator<<(PicWriter& out, const Picture& picture) {
  out << picture.header_;
  out << picture.data_;
  return out;
}
PicReader& operator>>(PicReader& in, Picture& picture) {
  in >> picture.header_;
  in >> picture.data_;
  return in;
}
\end{cppcode}
Вот и все.
Только для этого надо, чтобы классы \verb"Pixel" и \verb"Header" тоже были сериализуемыми.
Но эти классы тоже лишь сериализуют и десериализуют свои поля в нужном порядке.
Теперь все используется максимально просто
\begin{cppcode}
// writing to file
Picture pic = /*initialization*/;
PicWriter w(/*file*/);
w << pic;
// reading from file
Picture pic;
PicReader r(/*file*/);
r >> pic;
\end{cppcode}
И добавление новых полей в класс не усложняет задачу серизализации или десериализации.

Обратите внимание, что если внутри класса нет value semantics, то такая простая схема уже не подойдет.
Например, если класс -- это бинарное дерево собранное на указателях.
В этом случае решение выше дословно не подходит и нужно писать какое-то отдельное решение.
В этом случае сложность написания сериализации пропорциональна сложности устройства класса.

\paragraph{Функции чтения и записи}
Главный недостаток предыдущего способа заключается в том, что невозможно считать из потока объект, который не default constructible.
А такое быть может.
Тогда можно прибегнуть к написанию специальных функций, которые сразу возвращают значение объекта, а именно.
\begin{cppcode}
class PicReader {
public:
  template<class T>
  T read();
};
class PicWriter {
public:
  template<class T>
  void write(const T&);
};
\end{cppcode}
Эти функции идейно выполняют ту же самую работу как и потоковые операторы, то есть надо реализовать их для встроенных типов и стандартных контейнеров, а потом рекурсивно делегировать всю работу для каждого поля в нужном порядке.
Тем не менее, давайте я напишу.
Для встроенных типов будет что-то вроде
\begin{cppcode}
class PicReader {
public:
  template<>
  int read() {
    return /*implementation*/;
  }
};
class PicWriter {
public:
  template<>
  void write(int x) {
    /*implementation*/
  }
};
\end{cppcode}
Технически в 11 строке надо передавать \verb"const int&", но можно докрутить, чтобы встроенные типы передавались по значению, а остальные по ссылке и тому подобные вещи.
Я на это закрываю глаза здесь.
Теперь стандартные контейнеры обрабатываются так.
\begin{cppcode}
class PicReader {
public:
  template<class T, class A>
  std::vector<T, A> read() {
    size_t size = read<size_t>();
    std::vector<T, A> vec;
    vec.reserve(size);
    for(size_t i = 0; i < size; ++i)
      vec.push_back(read<T>());
    return vec;
  }
};
class PicWriter {
public:
  template<class T, class A>
  void write(std::vector<T, A>& vec) {
    write(vec.size());
    for(const auto& element : vec)
      write(element);
  }
};
\end{cppcode}
И тогда можно использовать код так
\begin{cppcode}
PicReader r(/*file*/);
Picture picture = r.read<Picture>();
PicWriter w(/*file*/);
w.write(picture);
\end{cppcode}
Все отличие между двумя методами чисто синтаксическое.
Но при этом принципиальное отличие этого метода в том, что не надо заводить неинициализированную переменную в дефолтном состоянии и потом перезаписывать поверх ее данными, можно сразу инициализировать нужный объект из потока при конструировании.

Завершить я хочу замечанием, что на сегодняшний день есть много фреймворков умеющих выполнять сериализацию данных.
Наверное самый популярный -- google protobuf.

\subsubsection{Как писать операторы}

Операторы можно поделить на $4$ класса
\begin{center}
\begin{tabular}{ccc}
{}&{in place}&{out of place}\\
{in class}&{
\begin{minipage}[\baselineskip]{6cm}
\begin{cppcode}[numbers=none]
A& operator+=(const A&);
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{6cm}
\begin{cppcode}[numbers=none]
A operator+(const A&) const;
\end{cppcode}
\end{minipage}
}\\
{out of class}&{
\begin{minipage}[\baselineskip]{6cm}
\begin{cppcode}[numbers=none]
A& operator+=(A&, const A&);
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{6cm}
\begin{cppcode}[numbers=none]
A operator+(const A&, const A&);
\end{cppcode}
\end{minipage}
}\\
{uses}&{
\begin{minipage}[\baselineskip]{6cm}
\begin{cppcode}[numbers=none]
a += b;
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{6cm}
\begin{cppcode}[numbers=none]
c = a + b;
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}
Оператор \verb"a += b" обычно используется для модификации объекта \verb"a".
И часто его можно сделать эффективно без переаллокации внутренних ресурсов (но не всегда).
Оператор же \verb"a + b" используется для построения нового объекта, для которого нужно аллоцировать ресурсы.
Сразу скажу, я предпочитаю для in place оператора in class имплементацию, а для out of place оператора out of class имплементацию.
Давайте я напишу все $4$ и объясню чем они отличаются друг от друга.

Имплементация внутри класса
\begin{cppcode}
class A {
public:
  A& operator+=(const A&) {
    // do something
    return *this;
  }
  A operator+(const A& other) const {
    A tmp = *this;
    tmp += other;
    return tmp;
  }
};
\end{cppcode}
Имплементация снаружи
\begin{cppcode}
class A {
public:
};
A& operator+(A& left, const A& right) {
  // do something, requires access to A, should be friend
  return left;
}
A operator+(const A& left, const A& right) {
  A tmp = left;
  tmp += right;
  return tmp;
}
\end{cppcode}
Обратите внимание, выше приведена стандартная имплементация для out of place оператора через in place оператор.
Типичная ошибка в имплементации такая
\begin{cppcode}
class A {
public:
  A operator+(const A& other) const {
    return A(other) += other;
  }
};

class A {
public:
};
A operator+(const A& left, const A& right) {
  A tmp = left;
  return tmp += right;
}
\end{cppcode}
В исходной версии, когда написано \verb"return tmp" тригерится NRVO.
То есть при выполнении операции
\begin{cppcode}
A x;
A y;
A z = x + y;
\end{cppcode}
В третьей строчке сумма \verb"x + y" строится сразу по адресу объекта \verb"z".
Однако, в последних двух версиях этого не просходит.
Вместо этого сумма строится во временном объекте \verb"tmp" и потом результат мувается в \verb"z".
Причина этого в следующем.
В двух последних имплементациях тип возвращаемый функцией не совпадает с типом выражения в \verb"return".
Действительно, в \verb"return" в обоих случаях последняя операция -- применение оператора \verb"+=", который возвращает \verb"A&", что отличается от \verb"A".
А это мешает выполнить NRVO и компилятор откатывается до мува.
Потому желание сократить в количестве строчек кода, может негативно сказаться на качестве программы.

\paragraph{In class vs.
Out of class}

Давайте поймем разницу между этими подходами.
Очевидная разница в том, что операторы вне класса можно добавлять к типам неинтрузивно.
То есть не меняя код самого класса, при условии, что у вас есть достаточный уровень доступа.
Однако, есть одно содержательное отличие именно для out of place оператора.
Рассмотрим следующий код
\begin{center}
\begin{tabular}{cc}
{
\begin{minipage}[\baselineskip]{7cm}
\begin{cppcode}
class A {
public:
  A(int);
  A operator+(const A&) const;
};

int main() {
  A x;
  A y;
  y = x + 1; // same as y = x + A(1);
  y = 1 + x; // compilation error
  return 0;
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{7cm}
\begin{cppcode}
class A {
public:
  A(int);
};
A operator+(const A&, const A&);

int main() {
  A x;
  A y;
  y = x + 1; // same as y = x + A(1);
  y = 1 + x; // same as y = A(1) + x;
  return 0;
}
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}
То есть для in class оператора сложения конвертация типов возможна только по второму аргументу, в то время как для out of class оператора сложения она доступна по обоим аргументам.
Вопрос позволять или не позволять неявную конвертацию -- это уже ваш выбор.
Но при этом важно понимать, что если вы позволили конвертацию, второй способ просто универсальнее.
Это первая причина, почему я стараюсь определять out of place операторы снаружи и делать их \verb"friend".
То есть мой выбор будет следующая пара
\begin{cppcode}
class A {
public:
  A& operator+=(const A&);
  friend A operator+(const A&, const A&);
};
A operator+(const A&, const A&);
\end{cppcode}

\paragraph{Шаблоны и друзья}

В начале начнем с описания четырех случаев взаимодействия классов и их друзей.
\begin{enumerate}
\item \textbf{Ont-to-Many} Не шаблонная функция друг для всех шаблонных классов.
\begin{cppcode}
template<class T>
class A {
  friend void f();
};
\end{cppcode}
Здесь функция \verb"f" умеет получать доступ к внутренностям всех классов вида \verb"A<T>".

\item \textbf{Many-to-One} Все версии шаблонной функции друзья не шаблонного класса.
\begin{cppcode}
class A {
  template<class T>
  friend void f();
};
\end{cppcode}
Каждая функция вида \verb"f<T>" имеет доступ к внутренностям класса \verb"A".

\item \textbf{One-to-One} Одна версия шаблонной функции является другом одной версии шаблонного класса (с теми же параметрами).
\begin{cppcode}
template<class T>
void f();

template<class T>
class A {
  friend void f<T>();
};
\end{cppcode}
В этом случае \verb"f<T>" имеет доступ только к внутренностям \verb"A<T>", но не имеет доступ к внутренностям \verb"A<U>" для \verb"U" отличного от \verb"T".
Обратите внимание, что в этом случае вы обязаны сделать forward declaration для \verb"f" перед классом, иначе компилятор не распознает, что написано в строке 6 (он не поймет, что \verb"f" это было имя шаблона, а не просто имя функции и какой-то оператор сравнения потом).

\item \textbf{Many-to-Many} Все версии шаблонной функции друзья для всех версий шаблонного класса.
\begin{cppcode}
template<class T>
class A {
  template<class U>
  friend void f();
};
\end{cppcode}
Здесь любая \verb"f<U>" может получить доступ к внутренностям любого \verb"A<T>".

\item \textbf{One-to-One*} Теперь неочевидный случай.
Давайте попробуем написать первый случай, но добавим класс как аргумент функции.
\begin{cppcode}
template<class T>
class A {
  friend void f(const A&);
};
\end{cppcode}
В этом случае мы объявляем для класса \verb"A<T>" другом функцию \verb"f(const A<T>&)".
То есть мы объявляем, не одну функцию для всех шаблонных классов, а для каждого шаблонного класса одну уникальную функцию.
Потому это отношение \textbf{Ont-to-One}, несмотря на то, что синтаксически это очень похоже с первым случаем.
\end{enumerate}

\paragraph{Шаблоны и операторы}

Теперь поговорим про случай операторов и шаблонов.
Мы хотим объявить оператор сложения вне класса шаблона и сделать его другом.
Есть принципиально два разных случая.
\begin{enumerate}
\item Сделать оператор не шаблонной функцией как в пятом разделе из предыдущего раздела.
\begin{cppcode}
template<class T>
class A {
public:
  friend A operator+(const A&, const A&) {
    /*implementation*/
  }
};
\end{cppcode}
Обратите внимание, что в этом случае мы вынуждены написать определение оператора непосредственно внутри шаблонного класса, так как плюсы не предоставляют возможности дать определение каким-либо другим образом для подобного случая.

\item Сделать оператор шаблонной функцией как в третьем случае из предыдущего раздела.
\begin{cppcode}
template<class T>
class A;

template<class U>
A<U> operator+(const A<U>&, const A<U>&);

template<class T>
class A {
public:
  friend A operator+<T>(const A&, const A&);
};

template<class U>
A<U> operator+(const A<U>&, const A<U>&) {
  /*implementation*/
}
\end{cppcode}
Обратите, что мы вынуждены добавить forward declaration для оператора сложения в строках 4-5.
Однако, в этом месте мы используем тип \verb"A<U>", который в 5-ой строке не виден, ибо имя \verb"A" еще не объявлено.
Потому надо добавить forward declaration в строках 1-2.
Еще из неочевидного -- куда пихать \verb"<T>" для оператора?
Надо думать так, для оператора \verb"operator+" -- это имя функции.
А шаблонные параметры надо ставить после имени функции.
\end{enumerate}
Так как в первом решении у нас оператор не шаблонный, а во втором шаблонный.
То в первом решении разрешена неявная конвертация аргументов, а во втором нет.
Кроме того, во втором случае у нас намного больше шума по отношению к реальному коду.
Я в целом предпочитаю случай первый и предпочитаю всегда писать определения шаблонов in place, чтобы не плодить количество шума в коде.

\paragraph{Популярная ошибка с шаблонами и операторами}
Если написать код
\begin{cppcode}
template<class T>
class A {
public:
  friend A operator+(const A&, const A&);
};

template<class U>
A<U> operator+(const A<U>&, const A<U>&) {
  /*implementation*/
}
\end{cppcode}
То при исполнении
\begin{cppcode}
A<int> x;
A<int> y;
A<int> z = x + y;
\end{cppcode}
У вас вылезет ошибка линковки.
Проблема заключается в том, что мы сделали не то, что хотели.
А именно, внутри класса в строке 4 мы объявили другом не того оператора, который объявили в строках 6-9.
Действительно, когда компилятор видит, что шаблон \verb"A" используется с параметром \verb"int", он генерирует следующий код
\begin{cppcode}
class A<int> {
public:
  friend A<int> operator+(const A<int>&, const A<int>&);
};
\end{cppcode}
Теперь относитесь к \verb"A<int>" как к просто имени конкретного класса.
Но теперь внутри говорится, что объявлен другом не шаблонный оператор.
Потому что перед ним нет определяющего шаблон ключевого слова \verb"template".
Проверьте это, написав
\begin{cppcode}
template<class T>
class A {
public:
  friend A operator+(const A&, const A&);
};

A<int> operator+(const A<int>&, const A<int>&) {
  return A<int>();
}

A<int> x;
A<int> y;
A<int> z = x + y;
\end{cppcode}
Теперь все скомпилируется.
Если же написать
\begin{cppcode}
template<class T>
class A {
public:
  template<class U>
  friend A<U> operator+(const A<U>&, const A<U>&);
};

template<class U>
A<U> operator+(const A<U>&, const A<U>&) {
  /*implementation*/
}
\end{cppcode}
то вы сделаете все операторы сложения \verb"operator+<U>" друзьями всех классов \verb"A<T>".
А это не очень хорошо, не стоит так делать.

\subsubsection{Контроль доступа Safe/Unsafe}

Очень часто бывает так, что в интерфейсе вашего класса есть опасные и безопасные операции.
Что это значит?
Это значит, что какие-то функции работают что бы ни произошло, их вызов всегда корректный и никаких условий на их вызов нет.
А не безопасные операции требуют специального состояния объекта, чтобы их можно было вызвать.
Например, если мы берем \verb"std::vector", то метод \verb"size" можно звать у любого состояния вектора, метод \verb"push_back" можно звать на любом векторе.
Но методы \verb"front" или \verb"pop_back" требуют, чтобы вектор был не пуст.
Как попытаться обезопасить себя и добавить дополнительную проверку, которая бы гарантировала, что вы случайно не вызываете небезопасный метод?
В таком языке как Rust есть ключевое слово \verb"unsafe", без которого просто нельзя позвать небезопасную операцию.
Мы можем симулировать этот механизм и в C++.
На всякий случай поясню, что я не утверждаю, что это надо делать для \verb"std::vector".
Я лишь хочу рассказать как это можно сделать, и делается это в том случае, когда это действительно вам понадобится для организации надежных интерфейсов.

\paragraph{Доступ к глобальным методам}

Давайте начнем со случая функций а не класса.
Предположим, что у нас есть функции, где часть безопасная и их можно звать всегда, а часть не безопасная.
\begin{cppcode}
int compute(int data); // safe
bool has_connection(); // safe
void upload(int data); // unsafe
\end{cppcode}
Тогда можно в начале закрыть эти функции внутри класса в виде статических методов.
В этом случае название класса придаст дополнительный контекст выполняемым функциям.
\begin{cppcode}
class A {
public:
  static int compute(int data);
  static bool has_connection();
protected:
  static void upload(int data);
};
\end{cppcode}
А теперь добавим шаблон
\begin{cppcode}
template<class T>
class Unsafe;

template<>
class Unsafe : A {
  ~A() = delete;
public:
  using A::upload;
};
\end{cppcode}
Удаленный деструктор не позволит нам создать объект такого типа.
Теперь работа с функциями выглядит так
\begin{cppcode}
int value = A::compute(3);
if(A::has_connection())
  Unsafe<A>::upload(value);
\end{cppcode}

\paragraph{Доступ к методам класса}

Просто так повторить такой же трюк с объектами класса не получится.
Обратите внимание, что с помощью наследования мы можем получить доступ к методу, но нельзя кастовать объект к наследнику.
Давайте я начну с корректного решения, а потом приведу пример простого и не корректного (но при этом часто используемого).
Пусть у нас есть класс:
\begin{cppcode}
class A {
public:
  int compute(int data);
  bool has_connection() const;
protected:
  void upload(int data);
};
\end{cppcode}
Теперь сделаем вспомогательный класс для доступа к методу
\begin{cppcode}
template<class T>
class Access;

template<>
class Access<A> : A {
  ~Access() = delete;
public:
  using A::upload;
};
\end{cppcode}
Как и раньше, удаленный конструктор не позволит нам создавать объекты такого класса.
И вот теперь делаем нужный класс
\begin{cppcode}
template<class T>
class unsafe;

template<>
class unsafe<A> {
  using AccessT = Access<A>;
  static constexpr auto func = &Access<A>::upload;

public:
  explicit unsafe(A& obj) : obj_(&obj) {
  }
  void upload(int x) {
    (obj_->*func)(x);
  }

private:
  A* obj_;
};
\end{cppcode}
После чего мы можем написать
\begin{cppcode}
A a;
int value = a.compute(5);
if (a.has_connection())
  unsafe(a)->upload(value);
\end{cppcode}
Вот подход, который опирается на UB
\begin{cppcode}
template<class T>
class unsafe_instance;

template<>
class unsafe_instance<A> : A {
public:
  using A::upload;
};

unsafe_instance<A>& unsafe(A& x) {
  return static_cast<unsafe_instance<A>&>(x);
}
// using
A a;
int value = a.compute(5);
if (a.has_connection())
  unsafe(a).upload(value); // UB
\end{cppcode}
Причина почему тут UB заключается в том, что мы кастуем ссылку на \verb"A" к ссылке на производный класс \verb"unsafe_instance<A>".
Это пока еще не UB, такое не запрещено.
Но в последней строчке мы обращаемся по адресу памяти объекта \verb"A", как будто там лежит объект типа \verb"unsafe_instance<A>".
Но его там нет, а это UB.

\subsubsection{Обработка некорректных данных}

Главная задача конструктора -- построить объект в корректном состоянии.
Потому очень важно проверять переданные пользователем данные и не надеяться ни на что, что не может быть проверено автоматически.
Помните, нарушение инварианта класса -- это ошибка программиста, которую надо исправлять.
Такие ошибки надо проверять через \verb"assert".
Я очень рекомендую завести в классе функцию проверяющую инвариант класса, и после этого делать проверку состояния класса через \verb"assert".
По-хорошему \verb"assert" надо ставить в каждом конструкторе, для проверки, что состояние класса корректно, в начале каждого метода для проверки условий на аргументы.
И в конце каждого мутирующего метода для проверки, что метод отработал корректно.
Вот пример для хранения упорядоченной пары.
\begin{cppcode}
class A {
public:
  A(int a, int b) : min_(a), max_(b) {
    assert(min_ <= max_ && "First argument must be not greater than the second.");
  }
private:
  int min_;
  int max_;
};
\end{cppcode}
Другой подход при построении упорядоченной пары -- восстановить инвариант.
Например можно присвоить их в другом порядке
\begin{cppcode}
class A {
public:
  A(int a, int b) : min_(std::min(a, b)), max_(std::max(a, b)) {
    assert(min_ <= max_);
  }
private:
  int min_;
  int max_;
};
\end{cppcode}
Для сложного класса, например если мы делаем дерево поиска, стоит выделить отдельную функцию для проверки инварианта
\begin{cppcode}
class BTree {
public:
  void method() {
    /*mutate this*/
    assert(is_in_correct_state_(root));
  }
private:
  static bool is_in_correct_state_(Node* node) {
    // Must not use asserts inside to avoid infinite recursion
    return /*condition*/;
  }

  Node* root_;
};
\end{cppcode}
Для удобства можно сделать много разных функций, проверяющих необходимые условия.
Это сделает проверяемое условие более читаемым, так как название функции скажет, что именно мы проверяем.
Если вы беспокоитесь, что такая проверка дорогая, то вы не зря беспокоитесь.
Она может быть дорогой.
Но, все \verb"assert"-ы отключаются макросом \verb"NDEBUG".
Потому к нему можно относиться как к автокомментируемому коду.
Так же можно сделать свои различные кастомные \verb"assert"-ы так, чтобы их можно было включать и отключать частями.

Бывает, что данные от пользователя нужно предварительно почистить.
Например мы хотим хранить внутри класса вектор из положительных чисел, в конструкторе принимаем \verb"std::vector<int>" и пользователь может передать нам вектор содержащий нули и отрицательные числа, тогда стоит вставлять в конструктор методы очистки данных.
Причем есть два подхода:
\begin{enumerate}
\item сначала вставить грязные данные и потом их почистить

\item сначала почистить и потом уже вставить грязные данные
\end{enumerate}
Давайте покажу, что я имею в виду на примере.
Первый подход:
\begin{cppcode}
class A {
public:
  A(std::vector<int> values)
   : values_(std::move(values)) {
    auto delete_from =
        std::remove(values_.begin(), values_.end(), is_non_positive);
    values_.erase(delete_from, values_.end());
  }
private:
  std::vector<int> values_;
};
\end{cppcode}
Второй подход:
\begin{cppcode}
class A {
public:
  A(std::vector<int> values)
   : values_(clear_non_positive(std::move(values))) {}
private:
  static std::vector<int> clear_non_positive(std::vector<int>&& values) {
    auto delete_from = std::remove(values.begin(), values.end(), is_non_positive);
    values.erase(delete_from, values_.end());
    return values;
  }

  std::vector<int> values_;
};
\end{cppcode}
Мне лично импонирует второй подход, где мы сначала данные приводим в порядок и уже корректные данные записываем внутрь класса.
Так получается всю инициализацию провести в списке инициализации.
Так же работа по очистке вектора выполняется функцией с говорящим названием и лучше читается, что именно мы сделали в конструкторе.
Так же видны зависимости данных: из каких данных какие получаются в результате каких действий.
Первый подход можно чуть улучшить, завернув метод очистки в приватную функцию, но тогда есть следующая проблема
\begin{cppcode}
class A {
public:
  A(std::vector<int> values)
   : values_(std::move(values)) {
    clear_values();
  }
private:
  void clear_values() {
    auto delete_from =
        std::remove(values_.begin(), values_.end(), is_non_positive);
    values_.erase(delete_from, values_.end());
  }

  std::vector<int> values_;
};
\end{cppcode}
В такой имплементации метод \verb"clear_values()" не принимает ничего и не возвращает ничего.
Это не очень хорошо.
Мы неявно манипулируем состоянием объекта.
В таком случае чуть лучше будет явно передать данные
\begin{cppcode}
class A {
public:
  A(std::vector<int> values)
   : values_(std::move(values)) {
    clear(&values_);
  }
private:
  static void clear(std::vector<int>* values) {
    assert(values);
    auto delete_from =
        std::remove(values->begin(), values->end(), is_non_positive);
    values->erase(delete_from, values->end());
  }

  std::vector<int> values_;
};
\end{cppcode}
Так будет хотя бы видно, что именно вы чистите в вашем классе и не надо будет искать определение метода, чтобы понять на что именно в классе он влияет.
Объект передается по указателю, чтобы подчеркнуть, что это out аргумент, который будет меняться.
В целом проверку на \verb"nullptr" тут можно не бояться, так как метод приватный и его никто из публичного интерфейса не будет дергать.
Потому он не должен обрабатывать случай \verb"nullptr", этот случай означает ошибку программиста.
Потому достаточно поставить \verb"assert", чтобы случайно не забыть это ожидание для функции очистки.

\subsubsection{Хрупкие объекты}
\label{section::fragile}

Хрупкими я буду называть объекты, которые по тем или иным причинам нарушают поведение value semantics.
Давайте я приведу конкретные примеры и объясню, что с этим делать.
\begin{enumerate}
\item\label{section::fragile::nocopymove} Объект нельзя перемещать и нельзя копировать.
Есть несколько причин, почему объект может обладать этим свойством:
\begin{enumerate}
\item Это сторонний класс, у которого просто удалены все четыре оператора для копирования и перемещения.
Например \verb"std::mutex".
\begin{cppcode}
std::mutex m; // non-copyable, non-movable

struct B { // non-copyable, non-movable
  int x;
  double y;
  std::mutex m;
};

std::vector<std::mutex> ms; // does not work
\end{cppcode}
Проблема полностью решается заворачиванием в \verb"std::unique_ptr".
\begin{cppcode}
using MutexMovable = std::unique_ptr<std::mutex>;

MutexMovable m; // non-copyable, movable
// copy does not make sense

struct B { // non-copyable, movable
  int x;
  double y;
  MutexMovable m;
}; // copy does not make sense

std::vector<MutexMovable> ms; // does work
\end{cppcode}
Обратите внимание, что копирование приобрести не получится, так как для мьютекса это просто не имеет смысла.

\item Объект является адресуемым.
Это значит, что в течение работы программы вы будете обращаться к этому объекту по его адресу и потому он должен лежать в точности по одному адресу и никогда не менять его.
Это может требоваться для имплементации паттернов взаимодействия между объектов таких как observer-observable.
\begin{cppcode}
class B {};
class A {
public:
  void send_to(B* address, Message m);
};

A a;
std::vector<B> vec(1);
B* address = &vec[0];
a.send_to(&address, Message());
vec.push_back(B()); // reallocates
a.send_to(&address, Message()); // ups
\end{cppcode}
Все опять решается \verb"std::unique_ptr".
Надо заменить старый класс \verb"B" на \verb"B_Impl", а в качестве \verb"B" сделать обертку.
\begin{cppcode}
class B_Impl { /*Old class B*/ };
class B {
public:
  B_Impl* operator->() {return impl_.get();}
  const B_Impl* operator->() const {return impl_.get();}
  B_Impl* address {return impl_.get();}
  const B_Impl* address const {return impl_.get();}
private:
  std::unique_ptr<TImpl> impl_;
};
class A {
public:
  void send_to(B* address, Message m);
};

A a;
std::vector<B> vec(1);
auto* address = vec[0].address();
a.send_to(&address, Message());
vec.push_back(B()); // reallocates
a.send_to(&address, Message()); // still good
\end{cppcode}

\item Объект просто развалится, если его скопировать или переместить.
Например внутри объекта переменные хранят указатели или ссылки друг на друга (это уже плохой признак, но есть ситуации когда приходится так делать и обычно только для адресуемых объектов).
\begin{cppcode}
class A {
  void function() const;
  std::function<void()> call_ = [this]() {function();};
};
\end{cppcode}
В этом случае поступаем так же, как и в предыдущем случае.
Заменяем \verb"A" на \verb"A_Impl", а вместо \verb"A" пишем обертку.
Тут видно, что можно сделать шаблонную обертку для всех трех случаев.
\begin{cppcode}
template<class TImpl>
class Wrapper {
public:
  TImpl* operator->() {return impl_.get();}
  const TImpl* operator->() const {return impl_.get();}
  TImpl* address {return impl_.get();}
  const TImpl* address const {return impl_.get();}
private:
  std::unique_ptr<TImpl> impl_;
};

using MutexMovable = Wrapper<std::mutex>;
using B = Wrapper<B_Impl>;
using A = Wrapper<A_Impl>;
\end{cppcode}
В случае мьютекса такая обертка лучше тем, что не позволяет сделать \verb"reset" на мьютексе.
В целом закрывать ненужный функционал -- хорошая идея.
\end{enumerate}

\item\label{section::fragile::const} Константные поля в класса или структуре.
\begin{cppcode}
struct A {
  const int x;
};
\end{cppcode}
В этом случае стоит перейти от структуры к классу, закрыть переменную \verb"x", убрать \verb"const" модификатор, а условие, что переменная \verb"x" не меняет свое значение сделать инвариантом класса.
\begin{cppcode}
class A {
public:
  A(int x) : x_(x) {}
  int x() const {return x_;}
private:
  int x_; // x = const is class invariant
};
\end{cppcode}

\item\label{section::fragile::reference} Класс содержит ссылку на данные.
\begin{cppcode}
struct A {
  const int& data;
};
\end{cppcode}
В целом это плохой признак, потому что данные по ссылке могли умереть или переехать в другое место.
Тем не менее, такая ситуация бывает встречается.
Например, если у вас есть механизм обеспечения, что данные точно живы и данные тяжелые и вы хотите передавать их дешево между функциями.
Первый вариант решения проблемы -- перейти на указатели
\begin{cppcode}
struct A {
  const int* data;
};
\end{cppcode}
Вы тут же приобретаете value semantics.
Однако, теперь вам надо обрабатывать случай \verb"nullptr".
Если это проблема, то можно воспользоваться специальным библиотечным классом.
\begin{cppcode}
struct A {
  std::reference_wrapper<const int> data;
};
\end{cppcode}
Эта штука ведет себя как указатель, но при этом не бывает \verb"nullptr".
Кроме-того, он неявно кастуется к ссылке.
Тем не менее, это все еще плохо из-за наличия ссылки, для которой вам нужны глобальные гарантии существования.
Это делает ваш код хрупким и ломает local reasoning.
Вам надо не забывать про гарантии существования объекта, на который вы ссылаетесь.

\item Класс собран внутри на указателях и процедура копирования -- дорогая операция.
Например дерево или граф собранный на нодах с указателями.
Если при этом вы хотите построить такой объект один раз и потом никогда не будете его менять, но его надо активно копировать и передавать между потоками, то есть дешевый способ сделать объект легко копируемым, заплатив цену невозможности его менять никогда.
\begin{cppcode}
struct Node {
  Node* parent;
  Node* left;
  Node* right;
};

class Tree {
public:
  ...
private:
  Node* root_;
};

const Tree t;
\end{cppcode}
В этом случае можно завернуть объект в \verb"std::shared_ptr<const Tree>".
В этом случае вы можете задешево копировать и даже передавать объект между thread-ами безболезненно.
Однако, тут есть одно предостережение.
Если вы хотите получить доступ к вершинам этого дерева, то нельзя пользователю выдавать указатель на \verb"Node".
Даже указатель на \verb"const Node" выдавать -- плохая идея.
Действительно, пусть у вас есть
\begin{cppcode}
class Tree {
public:
  ...
  const Node* root() const {
    return root_;
  }
private:
  Node* root_;
};

std::shared_ptr<const Tree> t = /*initialization*/;
const Node* croot = t->root();
Node* root = croot->left->parent;
// now you can modify t via root
\end{cppcode}
Проблема в том, что \verb"const" не проносится сквозь указатели.
Потому для корректной поддержания константности вам надо написать аналог константных итераторов для доступа к элементам такой структуры, чтобы избежать подобных проблем.
В целом, для работы с такой структурой и корректного поведения константности вам придется написать аналоги таких итераторов.
\end{enumerate}

\subsubsection{Менеджмент ресурсов и RAII}
\label{section::RAII}
% TO DO
% один реурс
% вектор и разделение ролей
% зависимые ресурсы

<<Resource Acquisition is Initialization>> -- это волшебная фраза, которая говорит о том, как заворачивать ресурсы в обертки в системе с поддержкой исключений.
В разделе~\ref{section::Dangerous} мы уже обсуждали зачем нужно заворачивать парные операции в обертки.
Напомню, что есть две основные причины:
\begin{enumerate}
\item Из-за наличия исключений вы можете выйти из любого scope в неожиданном месте и только выполнение деструкторов локальных объектов гарантируется для исполнения.

\item Автоматизация исполнения парных операций.
\end{enumerate}
Вот соответствующий пример:
\begin{cppcode}
void g() {
  throw std::runtime_error("Ups!");
}

void f() {
  int* x = new(0);
  g();
  delete x;
}
\end{cppcode}
В строчке 6 вы явно выделяете память, а в строчке 7 бросается исключение и 8-я строчка никогда не вызовется.
Как вообще работает код в функции \verb"f".
Давайте опишу по строчкам
\begin{enumerate}
\item В строчке 6 происходит сразу несколько вещей.

\begin{enumerate}
\item Выделение памяти на стеке для указателя \verb"x".

\item Вызов оператора \verb"new" для выделения памяти под переменную типа \verb"int", помещаем туда значение \verb"0".

\item Пишем адрес памяти в переменную \verb"x".
\end{enumerate}

\item Вызываем функцию \verb"g".

\item Функция \verb"g" бросает исключение.
В этом месте мы вываливаемся из функции \verb"g" в строчку 7 из функции \verb"f".

\item В строчке 7 после исключения мы должны выйти из функции \verb"f" и будем так выходить до тех пор, пока не встретим \verb"catch", который поймает исключение.
Но чтобы выйти мы должны почистить стек от функции \verb"f".
Это называется stack unwinding.
Надо удалить все локальные переменные и аргументы функции \verb"f".
Для этого после строчки 7 вызывается деструктор \verb"x", а так как это встроенный тип, то никакого деструктора нет и мы просто уменьшаем стек и выкидываем переменную \verb"x" со стека.

\item Почистив стек мы выходим в больший scope из которого вызвана \verb"f" и продолжаем вываливаться дальше.
\end{enumerate}
У этого процесса есть две вещи, о которых надо обязательно поговорить.
\begin{enumerate}
\item Безопасное выделение ресурсов.
Чтобы безопасно выделить и удалить память, или любой другой ресурс, выделение ресурса надо оборачивать в специальные обертки.
Для памяти такой wrapper называется \verb"std::unique_ptr".
Но есть и другие версии.
Идея его в следующем.
\begin{cppcode}
struct IntPtr {
  IntPtr(int value) : ptr_(new int(value)) {}
  ~IntPtr() { delete ptr_;}
  int* ptr_;
};

void f() {
  IntPtr x(0);
  throw std::runtime_error("Exception");
}
\end{cppcode}
Теперь в строчке 8 происходит выделение памяти в конструкторе \verb"IntPtr".
А при выходе из \verb"f" по исключению, во время stack unwinding вызовется деструктор для \verb"x" и удалится выделенная память.
Такой механизм позволяет гарантированно выполнять действия при выходе из любого scope.

\item Обратите внимание на тонкий момент в предыдущей схеме.
А что если во время stack unwinding вы бросите исключение?
По стандарту -- это недопустимо.
Программа упадет в run-time вызовом \verb"terminate".
Потому никогда не бросайте исключения в деструкторах.
Это чревато и не работает.
У вас нет шансов сообщить об ошибке в деструкторе безопасно.
Их надо обрабатывать внутри самого деструктора.
Но лучше не кидать никогда.
\end{enumerate}

\paragraph{Несколько ресурсов}

Теперь, что делать, если вам надо выделить память для двух указателей?
Тупой вариант такой
\begin{cppcode}
struct IntPtrPair {
  IntPtrPair(int x, int y) : ptr1_(new int(x)), ptr2_(new int(y)) {}
  ~IntPtrPair() {
    delete ptr1_;
    delete ptr2_;
  }
  int* ptr1_;
  int* ptr2_;
};

IntPtrPair x(1, 2);
\end{cppcode}
Беда этого подхода вот в чем.
Когда вы в строчке 11 вызываете конструктор, то сначала выделяется память под \verb"ptr1_", а потом под \verb"ptr2_".
И если при первом вызове память выделится, а во втором нет и будет брошено исключение.
То конструктор не завершит работу, а значит объект не будет считаться построенным, а значит и не вызовется деструктор для него во время stack unwinding.
А это значит, что память потечет.
Есть много костылей для этой проблемы, но правильное решение -- обернуть каждый указатель в свой wrapper.
Например так
\begin{cppcode}
struct IntPtrPair {
  IntPtrPair(int x, int y) : ptr1_(x), ptr2_(y) {}

  IntPtr ptr1_;
  IntPtr ptr2_;
};

IntPtrPair x(1, 2);
\end{cppcode}
И теперь вам вообще не надо беспокоиться о деструкторах и прочих радостях.
Все это за вас для каждого ресурса делает wrapper для работы с одним указателем.
На практике, конечно, надо пользоваться библиотечными опциями, тут подойдет \verb"std::unique_ptr".

\paragraph{Несколько зависимых ресурсов}

Существует еще одна ситуация, о которой стоит рассказать.
А что если у нас данные зависимы?
Например, я должен сначала выделить память под \verb"x", а потом, выделяя память под \verb"y", я должен туда положить информацию про \verb"x"?
То есть у вас есть естественная зависимость порядка конструирования данных.
А для конструирования по частям как раз и создано наследование.
Оно собирает объект в определенном порядке.
Давайте приведу такой пример
\begin{cppcode}
struct A {
  A(int x) : ptr_(std::make_unique<int>(x)) {}
  std::unique_ptr<int> ptr_;
};

struct B : A {
  A(int x)
   : A(x),
     ptr_(std::make_unique<int*>(A::ptr_.get()) {}
   std::unique_ptr<int*> ptr_;
};

B x(1);
\end{cppcode}
В таком случае у вас в строчке 13 сначала создается базовая часть объекта, то есть выделяется память под \verb"x" и кладется адрес в \verb"A::ptr_".
А потом вы выделяете память под \verb"B::ptr_" и кладете туда адрес \verb"A::ptr_" из базовой части.
Понятно, что это бессмысленная деятельность, но демонстрирует зависимость данных.
Тут прошу обратить внимание на несколько вещей:
\begin{enumerate}
\item Я везде пользуюсь wrapper-ами для указателей и мне вообще не надо задумываться про деструкторы.

\item Обратите внимание, что нигде не пользуюсь \verb"new" явно, вместо этого пользуюсь \verb"std::make_unique" функцией.

\item Если честно, то \verb"std::unique_ptr" не самая высоко оптимизированная вещь.%
\footnote{Кто-то, читая это, сейчас должен был брызнуть слезами смеха и отчаяния от моей аккуратности в формулировках.}
Но для большинства ситуаций этой обертки хватает на ура.
Правда деревья я бы на ее основе не собирал, как минимум убьете стэк в деструкторе или получите неописуемые тормоза.
\end{enumerate}

Все что я написал про память релевантно и для выделения других ресурсов.
Например для мьютексов используются \verb"std::lock_guard" или похожие механизмы.
Любой запрос к операционной системе, который требует освобождения своих ресурсов, должен выполняться через wrapper, где в конструкторе вы запрашиваете ресурс, а в деструкторе освобождаете.
Если вы используете наследование для последовательного выделения ресурсов, то вы можете спокойно бросать исключения в конструкторах, ибо деструкторы всех базовых классов отработают как надо.
%Вот \href{https://github.com/DimaTrushin/TypingAnalysisQt/blob/master/ThreadPool.h}{тут} я могу привести пример того, как я оборачивал Windows нативный thread pool в exception safe обертку.
Это уже не искусственный пример, где много разных взаимозависимых ресурсов требуют своего последовательного выделения или освобождения.
Наследование позволяет это сделать удобным и контролируемым.
Но надо пописать какой-то код.
Обратите внимание, что в \href{https://github.com/DimaTrushin/TypingAnalysisQt/blob/master/ThreadPool.cpp}{имплементации} методов я даже позволяю себе бросать исключения в конструкторах, при наличии ошибки.
Тогда все выделенные ресурсы в базовой части автоматом почистятся и не надо переживать на эту тему.
Напоследок хочу сказать еще одно замечание про реализацию выделения памяти под зависимые данные.
Есть другая альтернатива
\begin{cppcode}
struct A {
  A(int x)
   : ptr1_(std::make_unique<int>(x)),
     ptr2_(std::make_unique<int*>(ptr1_.get()) {}
  
  std::unique_ptr<int> ptr1_;
  std::unique_ptr<int*> ptr2_;
};

A x(1);
\end{cppcode}
Плюс такого подхода -- не вызываются лишние конструкторы, все делается в одном.
При сложной цепочке вложенных конструкторов гипотетически можно потратить много на накладные расходы.
Опять же, это все нужно измерять и я никогда не испытывал с этим проблемы, но быть они могут.
Минус в том, что этот код хрупкий.
Вы опираетесь на порядок расположения данных в коде.
А именно, вариант ниже
\begin{cppcode}
struct A {
  A(int x)
   : ptr1_(std::make_unique<int>(x)),
     ptr2_(std::make_unique<int*>(ptr1_.get())) {}
  
  std::unique_ptr<int*> ptr2_;
  std::unique_ptr<int> ptr1_;
};

A x(1); // incorrect object state
\end{cppcode}
порадует вас ошибкой в run-time.
Ваш объект будет находиться в некорректном состоянии.
Дело в том, что данные конструируются не в том порядке, в каком они идут в списке инициализации (строки 3 и 4), а в каком они объявлены в классе (строки 6 и 7).
Так что у вас сначала выполнится строка для инициализации \verb"ptr2_" и в ней вы обратитесь к функции \verb"get" неинициализированной \verb"ptr1_" и получите \verb"nullptr".
И только потом инициализируете \verb"ptr1_".
Как вы видите, после отработы конструктора \verb"ptr2_" не будет содержать адрес данных из \verb"ptr1_".
И такие ошибки хрен найдешь.
Причем совершить их очень легко -- достаточно переставить данные.
А со временем вы попросту забудете, что ваши данные были зависимы, ваш код обрастет дополнительными костылями и вы просто не заметите, что это именно эта ситуация.
Причем, код скомпилируется, запустится и даже отработает, пока вы не упадете на каком-нибудь тонком тесте.

\subsubsection{Наследование и композиция}
\label{section::Composition}

Давайте сразу посмотрим на следующие два примера:
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{7cm}
\begin{cppcode}[numbers = none]
struct A {
  int x;
  double y;
};

struct B {
  A a;
  char z;
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{7cm}
\begin{cppcode}[numbers = none]
struct A {
  int x;
  double y;
};

struct B : A {

  char z;
};
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
В обоих случаях класс \verb"B" содержит внутри себя данные класса \verb"A".
Давайте обсудим разницу между этими двумя подходами и как она проявляется в имплементации и при использования.
Если говорить про имплементацию (на сколько это возможно при условии, что в плюсах все аксиоматически определено), то конкретно в этих примерах представление класса \verb"B" в памяти будет одинаковым.
Однако, важным отличием будет использование объекта класса снаружи.
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{7cm}
\begin{cppcode}[numbers = none]
B b;
b.a.x = 1;
b.a.y = 2.;
b.z = 'c';
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{7cm}
\begin{cppcode}[numbers = none]
B b;
b.x = 1;
b.y = 2.;
b.z = 'c';
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Как мы видим, в обоих случаях мы складываем данные вместе в одну структуру, но только в первом примере данные структуры \verb"A" группируются внутри отдельной сущности \verb"b.a", а во втором случае данные структуры \verb"A" напрямую помещаются внутрь \verb"B" вместе с ее данными.
То же самое происходит и при использовании методов.
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{7cm}
\begin{cppcode}[numbers = none]
struct A {
  void f() const;
};

struct B {
  A a;
  void g() const;
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{7cm}
\begin{cppcode}[numbers = none]
struct A {
  void f() const;
};

struct B : A {

  void g() const;
};
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
При использовании вы получите
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{7cm}
\begin{cppcode}[numbers = none]
B b;
b.a.f();
b.g();
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{7cm}
\begin{cppcode}[numbers = none]
B b;
b.f();
b.g();
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Получается, что первый метод объединяет данные и методы двух классов \verb"A" и \verb"B" с наличием иерархии, то есть для доступа к методам \verb"A" надо использовать дополнительное промежуточное имя (имя переменной).
А во втором методе, мы просто скидываем все данные и методы в одну кучу и сливаем интерфейсы классов.
Обычно принято первый подход называть композицией.
Я бы сказал, что оба подхода являются композицией, но просто первый подход -- это вертикальная композиция, когда вы создаете иерархию на интерфейсах, а второй подход -- горизонтальная композиция, когда вы сливаете интерфейсы.

Важная тонкость -- вы не можете унаследоваться дважды от одного и того же класса, то есть вот так написать нельзя
\begin{cppcode}
struct A {
  void f() const;
};

struct B : A, A {
  void g() const;
};
\end{cppcode}
В этом случае при обращении
\begin{cppcode}
B b;
b.f(); // an issue
\end{cppcode}
не ясно к какому из двух базовых классов вы пытаетесь обратиться.
В языке нет никакого дополнительного механизма тут для различения базовых классов кроме их имени.
Потому использование одного и того же имени создает нерешаемую проблему идентификации.
Потому такое запрещено.
В случае же вертикальной композиции, у вас есть дополнительный параметр -- имя переменной класса \verb"A", что позволяет помещать в класс много переменных одного и того же типа.
\begin{cppcode}
struct A {
  void f() const;
};

struct B {
  void g() const;
  A a1;
  A a2;
};
\end{cppcode}
В этом случае при обращении
\begin{cppcode}
B b;
b.a1.f(); // resolved
b.a2.f(); // resolved
\end{cppcode}
На самом деле можно обойти косвенно ограничение на наследование.
Для этого надо просто добавить в имя класса некоторый тег, что делается с помощью шаблонных адаптеров.
\begin{cppcode}
template<class T, class Tag>
struct Base : T {};

struct B : Base<A, struct First>, Base<A, struct Second> {};
\end{cppcode}
В этом случае иерархия наследования выглядит так
\begin{center}
\[
\xymatrix{
  {\texttt{A}}
  	{\save
   [].[]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{\texttt{A}}
   	{\save
   [].[]*+[F-:<3pt>]\frm{}
   \restore
	}
  \\
  {\texttt{Base<A, First>}}\ar[u]
   	{\save
   [].[]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{\texttt{Base<A, Second>}}\ar[u]
   	{\save
   [].[]*+[F-:<3pt>]\frm{}
   \restore
	}
  \\
  {}&{B}\ar[ul]\ar[ur]
   	{\save
   [].[]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}\\
}
\]
\end{center}
В любом случае пользоваться потом этим не очень круто, только если это не библиотечный код спрятанный от программиста.

\paragraph{Сравнение}

Обычно принято противопоставлять <<композицию>> и <<наследование>>, потому что под <<наследованием>> подразумевается наследование с виртуальными методами (подробнее стоит посмотреть раздел~\ref{section::ClassicPolymorphism}).
Однако, если вы не используете базовый класс как интерфейс, то это та же самая композиция, при которой вы просто сливаете интерфейсы вместе.
Такая техника использования наследования хорошо описана в книге Alexandrescu Modern Design of C++ в первой главе названной Policy Based Design.
Другое название у этого подхода Mixings, когда базовые классы используются как компоненты наследника, то базовые классы называются Mixings.
Обычно принято говорить, что композиция лучше наследования.
Последнее правильнее с моей точки зрения выразить по-другому: композиции (вертикальная и горизонтальная) лучше наследования с виртуальными методами.
После такой переформулировки на самом деле видно, что это странное утверждение, потому что они используются для разных целей.
А как только вы сравниваете инструменты для разных задач, то ответ будет все время варьироваться от выбора задачи.
Тем не менее, композиция в моем смысле (обе версии) обладают value semantics и safe by default.
С помощью Policy Based Design можно легко собирать классы из настраиваемых компонент.

У обоих видов композиции есть свои достоинства и недостатки.
Мы уже отмечали, что в случае горизонтальной композиции (то есть наследования) сложно слить два одинаковых интерфейса напрямую.
С другой стороны, у наследования есть одно важное преимущество, которое делает Policy Based Design таким востребованным.
Я говорю про доступ к производному классу.
В случае вертикальной композиции это аналогично доступу к классу из его поля.
Чтобы было понятно, что имеется в виду, рассмотрим следующие два примера:
\begin{center}
\begin{tabular}{c|c}
\multicolumn{2}{c}{Виды композиции}\\
\hline
{Вертикальная}&{Горизонтальная}\\
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
struct A {
  void g() const;
  B b
  int y;
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
struct A : B {
  void g() const;

  int y;
};
\end{cppcode}
\end{minipage}
}\\
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
struct B {
  void f() const {
    const A* host =
      /*how to get the host?*/
    /*using the host*/
  }
  int x;
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
struct B {
  void f() const {
    const A* derived =
      static_cast<const A*>(this);
    /* using derived */
  }
  int x;
};
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Обратите внимание, что в случае наследования (горизонтальной композиции), на уровне языка можно получить адрес производного класса, который включает в себя базовый класс.
Ровно для этих целей в языке и существует конструкция \verb"static_cast".
А вот в случае вертикальной композиции в языке просто нет поддержки получения адреса хозяина.
Точнее есть один пережиток из Си, которым можно было бы заменить подобный механизм и называется он \verb"offsetof".
Можно попытаться сделать что-то вроде
\begin{cppcode}
struct B {
  void f() const {
    const A* host = this - offsetof(A, b);
    /*using the host*/
  }
  int x;
};

struct A {
  void g() const;
  B b;
  int y;
};
\end{cppcode}
Однако у этой конструкции есть некоторые проблемы.
Вот что об этом говорит нам информация с cppreference:
\begin{itemize}
\item \textbf{until c++11} If \verb"A" is not a POD the result is undefined

\item \textbf{until c++17} If \verb"A" is not a standard-layout the result is undefined

\item \textbf{since c++17} If \verb"A" is not a standard-layout use of the offsetof macro is conditionally-supported.
Прекрасно...
\end{itemize}
То есть эта операция нужна в Си чтобы двигаться от поля структуры к базовой структуре и ни для чего больше она не годится.
В остальных случаях она может быть даже сработает.
Но все приличные компиляторы будут вам пилить глаза предупреждениями при любом использовании.
В итоге язык просто не предоставляет возможность из поля класса достучаться в родителя.
Эта проблема будет еще часто возникать.
Мы ее еще увидим при имплементации observer pattern.
Но самое смешное ничего не мешает поддержать эту операцию, потому что у компилятора достаточно информации, для того чтобы решить эту задачу.
Эта задача ничего не отличается от downcast-а при наследовании.
Ровно с теми же самыми ограничениями и опасностями.

\subsubsection{Policy Based Design}

Давайте посмотрим на пример использования вертикальной композиции для сборки разных классов из компонент, чтобы избежать повторения кода.
Предположим у вас есть структура данных -- бинарное дерево и мы хотим для него сделать итератор.
У нас есть несколько выборов:
\begin{enumerate}
\item Обращение к данным константное или нет.

\item Какой порядок обхода по элементам.
\end{enumerate}
В таком случае можно распилить класс итератора на части и собирать разные виды итераторов без дублирования кода.
Прежде всего отметим, что константный или не константный итератор отличаются только типами данных.
А вот за навигацию по дереву отвечают разные методы.
Предположим, что мы реализовали константный итератор для какого-то фиксироанного метода обхода дерева и пусть он выглядит так:%
\footnote{Скорее всего тут будет лежать указатель на вершину дерева, а не на данные в вершине дерева.
Но эту мелочь я предлагаю игнорировать сейчас, как неважную деталь.}
\begin{cppcode}
template<class T>
class ConstIterator {
public:
  using value_type = const T;
  using difference_type = ptrdiff_t;
  using pointer = const T*;
  using reference = const T&;
  ...
  pointer operator->() const;
  reference operator*() const;
  ConstIterator& operator++();
  ...
private:
  void move_to_next();
  pointer ptr_;
};
\end{cppcode}
Чтобы не дублировать код для константного и не константного итератора можно выделить все псевдонимы в базовый класс.
И сделать два базовых класса: для константной и не константной версии.%
\footnote{По-хорошему надо удалять с типа \texttt{T} все модификаторы и квалификаторы и прочие трюки, но я это здесь игнорирую.}
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{9cm}
\begin{cppcode}[numbers = none]
template<class T>
struct ConstDefines {
  using value_type = const T;
  using difference_type = ptrdiff_t;
  using pointer = const T*;
  using reference = const T&;
};

template<class T>
struct NonConstDefines {
  using value_type = T;
  using difference_type = ptrdiff_t;
  using pointer = T*;
  using reference = T&;
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{9cm}
\begin{cppcode}[numbers = none]
template<class Defines>
class Iterator : Defines {
public:
  ...
  pointer operator->() const;
  reference operator*() const;
  Iterator& operator++() {
    move_to_next();
    return *this;
  }
  ...
private:
  void move_to_next();
  pointer ptr_;
};
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Еще по хорошему справа понадобится переопределить все псевдонимы внутри самого класса.
В любом случае это позволяет писать один и тот же код для константной и не константной версии итератора.
Чтобы настроить метод обхода дерева, то надо распилить итератор следующим образом.
\[
\xymatrix@R=10pt{
  {\texttt{Defines}}
     	{\save
   [].[]*+[F--:<3pt>]\frm{}
   \restore
	}
  &{\texttt{Base}}\ar[l]
     	{\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{\texttt{Navigation}}\ar[l]
     	{\save
   [].[d]*+[F--:<3pt>]\frm{}
   \restore
	}
  &{\texttt{Iterator}}\ar[l]
     	{\save
   [].[]*+[F-:<3pt>]\frm{}
   \restore
	}
  \\
  {}&{\texttt{pointer ptr\_}}
       	{\save
   [].[]*[F-]\frm{}
   \restore
	}
  &{\texttt{move\_to\_next}}
         	{\save
   [].[]*[F-]\frm{}
   \restore
	}
  &{}\\
}
\]
Здесь на стрелка ведет от наследника к базовому классу.
Пунктиром отмечены настраиваемые блоки.
\begin{enumerate}
\item \texttt{Defines} как и прежде содержит псевдонимы типов для итератора.
Этим можно влиять на константность или не константность итератора.

\item \texttt{Base} содержит данные итератора, в нашем случае мы предположили, что это всего лишь указатель, но это не принципиально.

\item \texttt{Navigation} содержит метод для навигации, который будет вызываться в \verb"operator++".

\item \texttt{Iterator} это финальный класс собранного итератора.
\end{enumerate}
В коде это все может выглядеть так
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]

template<class Defines>
class Base : Defines {
public:
  pointer operator->() const;
  reference operator*() const;
protected:
  pointer ptr() const;
private:
  pointer ptr_;
};

template<class Navigation>
class Iterator : Navigation {
public:
  ...
  Iterator& operator++() {
    Navigation::move_to_next();
    return *this;  
  }
  ...
};

\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
template<class Base>
class Navigation1 : Base {
protected:
  void move_to_next() {
    /*Implementation*/
  }
};

template<class Base>
class Navigation2 : Base {
protected:
  void move_to_next() {
    /*Implementation*/
  }
};

template<class Base>
class Navigation3 : Base {
protected:
  void move_to_next() {
    /*Implementation*/
  }
};
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Тогда создание конкретного итератора выглядит так
\begin{cppcode}
template<class T>
using ConstIterator1 = Iterator<Navigation1<Base<ConstDefines<T>>>>;

template<class T>
using Iterator1 = Iterator<Navigation1<Base<Defines<T>>>>;
\end{cppcode}
Такой подход лучше использования указателей на функцию, так как использует прямой вызов метода по имени, а не по его адресу.

\subsubsection{Зависимости класса и Pimpl}
\label{section::Pimpl}

Начнем со следующего примера класса
\begin{cppcode}
// file.h

class A {
public:
  void f(int) const {
    /*Implementation*/
  }
protected:
  void g(double) const {
    /*Implementation*/
  }
private:
  void h(char) const {
    /*Implementation*/
  }
};
\end{cppcode}
Теперь давайте подумаем, какие есть зависимости у пользователя этого класса, при его использовании.
Есть два вида зависимостей
\begin{enumerate}
\item Прежде всего есть синтаксическая зависимость, которая означает, что если я захочу поменять класс \verb"A", то пользователю этого класса придется что-то менять у себя в коде.

\item Кроме того, есть еще зависимость при компиляции, а именно, если я внесу изменения в класс \verb"A", то пользователю класса нужно: перекомпилировать свой код, перелинковать свой код.
\end{enumerate}
С перелинковкой мы ничего сделать не сможем.
Если уж данные поменяли формат или метод изменил набор инструкций для исполнения, нам надо будет подтянуть новые данные из бинарного файла.
А вот перекомпиляции хотелось бы часто избежать, учитывая, что сама модель плюсов рассчитана на минимизацию вызова компилятора и перелинковку изменившихся частей кода.
Давайте для определенности напишем какой-то пользовательский код
\begin{cppcode}
#include<file.h>

class B : protected A {
public:
  void g(double value) const {
    A::g(value);
  }
};

int main() {
  A a;
  a.f(1);
  return 0;
}
\end{cppcode}
В начале проигнорируем вопрос компиляции и линковки и посмотрим на синтаксическую зависимость.
Если в строчке~5 в листинке класса \verb"A" интерфейс функции не меняется на более узкий, то пользователю класса не надо будет ничего менять в своем коде.
Например такое изменение
\begin{cppcode}
void f(int, int z = 1) const { /*Implementation*/ }
\end{cppcode}
не изменит код пользователя, не надо будет ничего переписывать в \verb"main.cpp".
Аналогично обстоят дела с методом \verb"A::g".
Только при изменении его сигнатуры придется вносить изменения не всюду, а только в классах наследниках.
Изменение приватной части класса \verb"A" вообще не влияет на пользовательский код, это и есть сила инкапсюляции, которая ставит четкие границы.

А теперь обратим внимание на то, что если весь класс \verb"A" объявлен в заголовочном файле \verb"file.h", то любые изменения в этом файле приведут к перекомпиляции всех, кто его инклудит.
Первый механизм, который приходит на ум -- выделение h и cpp файлов так:
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
// file.h

class A {
public:
  void f(int) const;
protected:
  void g(double) const;
private:
  void h(char) const;
};

\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
// file.cpp

void A::f(int) const {
  /*Implementation*/
}
void A::g(double) const {
  /*Implementation*/
}
void A::h(char) const {
  /*Implementation*/
}
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Теперь внесение изменений в имплементацию любого метода не вызовет перекомпиляцию на стороне пользователя.
Однако, если я добавлю в класс приватный метод, то он вызовет изменение файла \texttt{file.h}, а потому автоматически вызовет перекомпиляцию всех пользователей.
\begin{cppcode}
class A {
public:
  void f(int) const;
protected:
  void g(double) const;
private:
  void h(char) const;
  int w(int) const; // recompilation of users
};
\end{cppcode}
Несмотря на то, что добавление или удаление приватных методов не меняет код пользователя, он заставляет его перекомпилироваться.
Проблему добавления методов можно решить следующим образом.
В начале надо метод переделать в статический
\begin{cppcode}
class A {
public:
  void f(int) const;
protected:
  void g(double) const;
private:
  void h(char) const;
  static int w(const A*, int); // recompilation of users
};
\end{cppcode}
А теперь надо вынести его и спрятать в \texttt{file.cpp} в anonymous namespace.
\begin{cppcode}
// file.cpp

namespace {
int w(const A*, int) {
  /*Implementation*/
}
}

void A::f(int) const {
  /*Implementation*/
}
void A::g(double) const {
  /*Implementation*/
}
void A::h(char) const {
  /*Implementation*/
}
\end{cppcode}
И так можно прятать все вспомогательные функции.
Однако, есть еще одна проблема.
Что если мы добавим приватное данное в класс \verb"A"?
\begin{cppcode}
class A {
public:
  void f(int) const;
protected:
  void g(double) const;
private:
  void h(char) const;
  int data_; // recompilation of users
};
\end{cppcode}
В этом случае пользователю все равно придется перекомпилироваться, ибо это внесение изменения в файл, который инклудится пользователем.
Чтобы избежать перекомпиляции в этом случае можно воспользоваться так называемой Pimpl idiom.
Расшифровывается это так -- pointer implementation.
Как понятно из названия, нужно всего лишь спрятать приватную имплементацию класса внутри указателя.
Идейно мы бы хотели написать следующий код:
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}
// file.h
#include<memory>

namespace detail {
class ImplA; // forward declaration
}

class A {
public:
  void f(int) const;
protected:
  void g(double) const;
private:
  std::unique_ptr<ImplA> impl_;
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
// file.cpp
#include<file.h>

namespace detail {
class ImplA {
  /*Implementation*/
};
}

void A::f(int) const {
  /*Implementation*/
}
void A::g(double) const {
  /*Implementation*/
}
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Это решение хорошо всем кроме одного -- оно не будет компилироваться.
Давайте я объясню, что пойдет не так и как это надо исправлять.
Давайте напишем код
\begin{cppcode}
#include<file.h>

int main() {
  A a;
  return 0;
} // compilation error
\end{cppcode}
Обратите внимание, где происходит ошибка компиляции.
Причина в том, что мы используем \verb"std::unique_ptr" на \verb"ImplA"  внутри класса \verb"A".
Однако, класс \verb"ImplA" объявлено, но не определен в строке~5 в \verb"file.h".
Теперь вспомним, что компилятор для каждого класса должен сгенерировать его деструктор.
При компиляции файла \verb"file.cpp" сгенерировать деструктор не получится, потому что компилятор C++ смотрит только в прошлое.
Так как \verb"ImplA" определен после \verb"A", то при генерации деструктора для \verb"A", компилятор еще не знает, как устроен класс \verb"ImplA" и не знает как его создавать и разрушать.
Теперь при компиляции файла \verb"main.cpp" при выходе из функции \verb"main" должен быть вызван деструктор для \verb"A" и в этот момент компилятор скажет вам, что у данного класса нет деструктора.
Решается эта проблема следующим образом.
Надо объявить дефолтный деструктор после имплементации класса \verb"ImplA" вот так
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
// file.h
#include<memory>

namespace detail {
class ImplA; // forward declaration
}

class A {
public:
  ~A();  // declaration
  void f(int) const;
protected:
  void g(double) const;
private:
  std::unique_ptr<ImplA> impl_;
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
// file.cpp
#include<file.h>

namespace detail {
class ImplA {
  /*Implementation*/
};
}
A::~A() = default;  // definition

void A::f(int) const {
  /*Implementation*/
}
void A::g(double) const {
  /*Implementation*/
}
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Вот теперь это решение работает.
Мы можем вносить любые изменения в \verb"ImplA" и это никак не отразится на пользователе класса \verb"A".
Так как в \verb"file.h" остался по сути только интерфейс для \verb"A": публичный и защищенный, то если вы не собираетесь менять интерфейс, то и перекомпилировать ничего не придется.
Обратите внимание, что класс \verb"A" становится легко перемещаемым и даже адресуемым.
Однако, его нельзя копироваться.
Если такая операция нужна, то придется имплементировать копирующие операции вручную.
Не забудьте, что в этом случае нужно определять все дефолтные методы.

\subsubsection{Признаки плохого класса}

\begin{enumerate}
\item Класс содержит указатель на ресурс и занимается чем-то кроме менеджмента ресурса.
\begin{cppcode}
class A {
public:
  double compute_something() const {
    /*some algorithm with data_*/
  }
private:
  Data* data_;
};
\end{cppcode}
Вы либо менеджерите ресурс, либо имплементируете бизнес логику.
В данном случае можно ввести промежуточный класс для менеджмента данных.
\begin{cppcode}
class A {
public:
  double compute_something() const {
    /*some algorithm with data_*/
  }
private:
  std::unique_ptr<Data> data_;
};
\end{cppcode}
Либо если вам нужна возможность копировать данные, вам придется написать свою обертку аналогичную \verb"std::unique_ptr", которая будет не только мувать, но и копировать данные.

Обратите внимание, что бывают исключения из этого правила в следующем смысле.
Если вы реализуете структуру данных на указателях, то не всегда хорошая идея отдавать вопрос владения узлам.
Давайте я приведу пример.
Пусть вы хотите написать бинарное дерево с корнем и не мучиться с владением ресурсами, то можно сделать так
\begin{cppcode}
struct Node {
  Node* parent;
  std::unique_ptr<Node> left;
  std::unique_ptr<Node> right;
};

class Tree {
public:
  ...
private:
  std::unique_ptr<Node> root_;
};
\end{cppcode}
Вы действительно избавились от необходимости заниматься менеджментом ресурсов в дереве.
Однако, вы приобрели две проблемы:
\begin{enumerate}
\item При вызове деструктора \verb"Tree", вы должны будете уничтожить \verb"root_".
Внутри деструктор вызовет деструкторы своих детей, они деструкторы свдоих детей и т.д.
При большой глубине дерева это может вызвать переполнение стека.

\item Производительность.
Да, я попадал в ситуации, когда замена сырых указателей на \verb"std::unique_ptr" прям кардинально бьет по производительности.
Но это вопрос измерений в вашей конкретной ситуации.
\end{enumerate}
Если такое решение вам не подходит, то тогда можно перенести ответственность за менеджмент памяти уже на саму структуру данных \verb"Tree".
В таком случае можно очистить дерево в цикле за $O(n)$.

\item Класс содержит указатель на несколько ресурсов и ведет их менеджмент.
\begin{cppcode}
class A {
public:
  A();
  A(const A&);
  A(A&&) noexcept;
  A& operator=(const A&);
  A& operator=(A&&) noexcept;
  ~A();
private:
  B* b;
  C* c;
};
\end{cppcode}
Плохая идея менеджерить два ресурса.
Ибо вам будет очень больно и сложно написать корректный код, устойчивый к исключениям.
Для этого напишите два вспомогательных класса для менеджмента ресурсов, либо используйте \verb"std::unique_ptr" или его налоги, если они подходят.
\begin{cppcode}
class A {
public:
  A() = default;
private:
  std::unique_ptr<B> b;
  std::unique_ptr<C> c;
};
\end{cppcode}
Бывают исключения из этой ситуации, вроде \verb"std::vector", когда задача менеджерить все объекты одновременно в одной области памяти, но даже в этом случае можно сделать имплементацию грамотно, а можно нет.% (cм.~\ref{}).

\item Класс содержит хрупкий объект.
Если написание хрупкого объекта -- это часть имплементации какого-то шаблона проектирования или структуры, то это не страшно, но снаружи класс должен обладать value semantics.
Это значит, что вы должны принять меры, чтобы обеспечить value semantics, как минимум не забыть заняться этим вопросом.
В остальных же случаях, вы должны избавиться от проблемы.
Как это сделать, можно посмотреть в разделе~\ref{section::fragile}.
\begin{enumerate}
\item Класс содержит неперемещаемый и некопируемый объект.
\begin{cppcode}
class A {
  std::mutex m;
};
\end{cppcode}
Как решать описано в разделе~\ref{section::fragile} пункт~\ref{section::fragile::nocopymove};

\item Класс содержит константные данные.
\begin{cppcode}
class A {
  const int x;
};
\end{cppcode}
Как решать описано в разделе~\ref{section::fragile} пункт~\ref{section::fragile::const};

\item Класс содержит ссылку на данные.
\begin{cppcode}
class A {
  const int& x;
};
\end{cppcode}
Для начала посмотрите в разделе~\ref{section::fragile} пункт~\ref{section::fragile::reference}, чтобы понять как топорно получить value semantics.
Однако, надо понимать, что наличие ссылок на какие-то внешние объекты -- это всегда плохой признак.
Это скорее всего означает, что ваши объекты должны уметь коммуницировать на расстоянии не видя друг друга.
В таком случае обычно нужно использовать подходящий паттерн для общения объектов.
Самый популярный является observer pattern.
Он как раз гарантирует надежное общение между объектами.
\end{enumerate}

\item Класс содержит \verb"shared_ptr" на неконстантный объект.
\begin{cppcode}
class A {
  std::shared_ptr<B> b;
};
\end{cppcode}
Эта ситуация обычно означает, что вы вообще не понимаете, что вы делаете.
Вы по сути говорите в коде, что понятия не имеете кто и когда владеет объектом \verb"b" и черт его знает когда он живет.
В большинстве случаев можно просто перейти на \verb"std::unique_ptr", либо написать аналог, который еще умеет копировать данные (как это делать можно посмотреть в разделе~\ref{section::siximpl}).
Другая ситуация -- заменить на \verb"std::shared<const B>".
Ситуации, когда же надо действительно использовать \verb"std::shared_ptr" очень редкие и если вы про них не знаете, то это признак того, что вы его точно используете не по назначению (см. раздел~\ref{section::SharedPtr}).
\end{enumerate}
