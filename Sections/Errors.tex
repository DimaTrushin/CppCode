\ProvidesFile{Errors.tex}[Ошибки]


\section{Обработка ошибок}
% TO DO

\subsection{Виды ошибок и доступные средства}

\paragraph{Виды ошибок}

\begin{enumerate}
\item \textbf{Ошибка программиста.}
Это bug-и программы, которых в коде быть не должно.
Такие ошибки надо исправлять.

\item \textbf{Ошибка при обращении к ресурсам среды исполнения.}
Например вы пытаетесь выделить память, получить доступ на чтение или запись файла, получаете доступ на прослушивание клавиатуры, получаете доступ к вычислению на видеокарте и так далее.
Бывают разные причины, почему такие операции могут быть не успешными.
В любом случае это ошибки, которые могут встретиться в  программе и которые не связаны с некорректностью кода.
\end{enumerate}

\paragraph{Обработка ошибок}

Теперь давайте обсудим какие есть механизмы в языке для работы с ошибками.
Существуют следующие механизмы:
\begin{enumerate}
\item Макрос \verb"assert".
Технически \verb"assert" это макрос, которые ведет себя следующим образом:
\begin{itemize}
\item Если определен макрос \verb"NDEBUG"%
\footnote{Компилятор от Microsoft автоматически определяет этот макрос в релизе, а gcc и clang нет.
Бывает полезно проверить условия в релизе, потому что пути оптимизации компилятора неисповедимы.
Тогда в msvc вам надо убрать при компиляции в релизе объявление макроса \verb"NDEBUG".} , то он не дает никакого кода.

\item Если не определен макрос \verb"NDEBUG", он делает проверку условия внутри макроса и если оно ложно, то валит программу с сообщением об ошибке и указанием строчки кода, на которой все упало.
\end{itemize}
Вот как выглядит его использование
\begin{cppcode}
int f(int* x) {
  assert(x != nullptr && "The argument must not be nullptr!");
  return *x;
}

int main() {
  int x = 1;
  assert(x == 1 && "x must be 1!");
  return 0;
}
\end{cppcode}

\item Конструкция \verb"static_assert".
Это по сути то же самое, что и просто \verb"assert", только данная конструкция выполняет проверки во время компиляции, а не во время исполнения.
Все проверки условий известных на этапе компиляции должны выполняться этой функцией, а не просто \verb"assert"-ом.
Вот как выглядит его использование
\begin{cppcode}
template<class T>
class A {
  static_assert(std::is_arithmetic_v<T>, "The type T must be arithmetic!");
  ...
};
\end{cppcode}
Строчка в начале класса будет проверяться при компиляции для каждого типа \verb"T".
И если тип \verb"T" не является арифметическим, то компиляция будет падать с ошибкой, где будет указана строчка, где она произошла, и сообщение.

\item Error codes или коды ошибок.
Данный подход часто применяется в Си для обработки ошибок.
Суть его в том, что мы используем возвращаемое значение функции для указания статуса операции, а для возвращения данных используем out аргументы (см.~\ref{}).
Вот как это выглядит
\begin{cppcode}
enum class Status {
  OK, Error
};

Status algorithm(const Data& input, Result* output);

int main() {
  Data data = ...;
  Result result;
  Status status = algorithm(data, &result);
  if (status == Status::OK) {
    ...
  } else {
    ...
  }
}
\end{cppcode}


\item \verb"std::expected".
Начиная с C++23 вам наконец-то доступна возможность возвращать из функции желаемое значение или ошибку.
По сути это \verb"std::variant<ValueType, ErrorType>" но только с приятным интерфейсом.
Суть его в том, чтобы использовать коды ошибок, но при этом и ошибку и результат возвращать через \verb"return".
В коде это выглядит как-то так
\begin{cppcode}
class Error {
  ...
};

std::expected<Result, Error> algorithm(const Data& data);

int main() {
  Data data = ... ;
  auto result = algorithm(data);
  if (result.has_value()) {
    Result r = std::move(result).value();
    ...
  } else {
    ...
  }
}
\end{cppcode}

\item Исключения -- Exceptions.
Это специальная фича языка, которая позволяет генерировать исключения с помощью ключевого слова \verb"throw".
Перехватывать их можно внутри блока \verb"try" и реагировать на них внутри блока \verb"catch".
Исключения являются опасным механизмом языка, потому что они могут выйти не только из текущего scope, но и в целом подниматься по стеку до тех пор, пока их не поймают или пока исключение не улетит в операционную систему.
Из-за исключений вы должны всегда думать, что вы можете выйти из любого scope в любой точке.
Из-за этого весь менеджмент ресурсов доложен быть автоматизирован с помощью RAII (см.~раздел~\ref{section::RAII}).
В коде это выглядит как-то так
\begin{cppcode}
Result algorithm(const Data& data) {
  ...
  if (/*some error*/)
    throw std::runtime_error(/*error information*/);
  ...
  return result;
}

int main() {
  Data data = ... ;
  Result result;
  try {
    result = algorithm(data);
  } catch (std::exception& e) {
    /*handle known exceptions*/
  } catch (...) {
    /*handle unknown exceptions*/
  }
  return 0;
}
\end{cppcode}
\end{enumerate}
Методы выше можно сгруппировать так:
\begin{enumerate}
\item Задача \verb"assert" и \verb"static_assert" уронить программу на первой же ошибке.
Программа не должна продолжать работу в некорректном состоянии.
Предполагается, что вы как раз ищете ошибку в коде и это должно помочь ее найти.
Эти методы для дебага.

\item Все остальные методы: коды ошибок, \verb"std::expected" и исключения, предполагают, что вы хотите как-то отреагировать на ошибку при исполнении.
Самое главное, что вы хотите и можете продолжить исполнение дальше (возможно вы все равно хотите выйти по \verb"terminate", но у вас есть возможность не падать).
Эти методы предполагают штатное исполнение программы.
\end{enumerate}

Давайте оценим методы по информативности.
\begin{enumerate}
\item \verb"assert" и \verb"static_assert" по умолчанию сообщают вам информацию о строчке кода, на которой произошла ошибка.
У вас так же есть возможность сообщить любую другую информацию (хотя у \verb"assert" добавление информации делается костылями).
По умолчанию, нет информации о стеке вызовов для \verb"assert" (для \verb"static_assert" это не имеет смысла, так как она вызывается при компиляции, а не при исполнении).
Однако начиная с C++23 появилась возможность использовать \verb"std::stacktrace".
Он, правда, не на столько хорошо отображает информацию, как привычные для нас компиляторы.

\item Коды ошибок и \verb"std::expected".
Так как и коды ошибок и тип ошибок внутри \verb"std::expected" пишите вы сами, то тут нет информации, которая будет доступна по умолчанию.
Получить информацию о стеке вызовов вы также можете с помощью \verb"std::stacktrace".
Начиная с C++20 информацию о строчке кода, где произошла ошибка можно получить с помощью \verb"std::source_location".

\item Исключения.
По умолчанию класс для исключения пишите вы сами.
Потому вы можете поместить в него все ту же самую информацию, которая доступна и другими методами, а именно: \verb"std::stacktrace" и \verb"std::source_location".
Однако, если вы используете дебагер, то при падении на исключении, которое не было поймано, вам дебагер сообщит информацию о стеке вызовов и текущее состояние вашей программы в памяти.
Это может быть удобно, но это по сути фича дебагера, а не возможности исключений.
\end{enumerate}

\paragraph{Ожидаемое поведение}

Давайте поймем, какое поведение от программы мы ожидаем при возникновении ошибок.
Можно выделить следующие случаи:
\begin{enumerate}
\item Программа падает с сообщением об ошибке.

\item Программа сообщает об ошибке, корректно ее обрабатывает, продолжает находиться в корректном состоянии и корректно работает дальше.
\end{enumerate}
Первое поведение хорошо подходит для разработки приложения, потому что вы хотите найти ошибку как можно раньше, упасть как можно ближе к ней, чтобы найти ее и исправить.
Нет необходимости работать дальше.
Второе же поведение желательно на машине пользователя.
Какой бы ни была ошибка, пользователь не ждет, что программа упадет.
В худшем случае он ждет информации, что что-то пошло не так.
В связи с этим \verb"assert" и \verb"static_assert" подходят только для первого поведения и совсем не подходят для второго.
Их суть ровно в том, чтобы уронить программу как можно раньше.
В свою очередь коды ошибок, \verb"std::expected" и исключения технически могут быть использованы для обеих ситуаций.
Это может быть не очень разумно, но никто вам не мешает это сделать.

\subsection{Доступные инструменты}

Давайте поговорим об инструментах, которые позволяют искать ошибки программиста.
Тут обычно вспоминают два:
\begin{enumerate}
\item Дебагер.
Это специальная программа, которая позволяет позволяет следить за выполнением программы.
При этом вам обычно доступна следующая информация
\begin{enumerate}
\item Текущий стек вызовов

\item Текущие переменные и присвоенные им значения.
При этом доступна информация о типе переменной и ее адрес (если это класс, то какие поля у переменной и их значения).

\item Текущая команда в программе.
\end{enumerate}
При этом дебагер позволяет поставить точку в коде на которой вы хотите остановить исполнение.
Позволяет делать пошаговое исполнение с возможностью проваливаться внутрь функций или выполнять их как единое действие.

\item Санитайзеры.
Сразу оговорюсь это все инструменты доступные под Linux и MacOS и не доступные под Windows.
Санитайзеры -- это специальные внешние инструменты, которые следят за исполнением программы и выявляют в ней ошибки.
Например для проверки корректности работы с памятью, вся выделяемая память в вашей программе имеет специальные служебные блоки памяти вокруг каждого вызова \verb"new".
И если ваша программа обращается к служебным блокам, значит вы не верно обратились к данным.
\end{enumerate}
Хочу сказать несколько важных вещей по поводу этих инструментов.
Давайте посмотрим на диаграмму экосистемы C++ еще разок (см.~раздел~\ref{section::EcoSystem}).
Обратите внимание, что дебагер и санитайзеры находятся в самом конце пайплайна по работе с кодом.
То есть дебагер -- это ваша последняя линия обороны.
На этом этапе вы работаете напрямую с бинарным кодом.
И для того, чтобы дебагер мог делать свою работу, вам приходится компилировать программу в специальном режиме, в котором становятся доступны имена и типы объектов, расположенных в памяти.
Обычно убираются разные оптимизации, чтобы бинарный код лучше сопоставлялся с исходным кодом.
Как бы то ни было, если вы пользуетесь только дебагером и санитайзерами -- вы совершаете большую ошибку, потому что на уровне исходного кода у вас куда больше возможностей предотвратить свои ошибки и получить помощь со стороны компилятора.

\subsection{Ошибки программиста}

\subsubsection{Информация об ошибке}
% TO DO
% Есть доклад от чувака, который сделал хороший доклад про  синглтон и как его убрать из кода. Там много хорошей информации по тому, что должно быть в ошибке
TO DO

\subsubsection{\texttt{assert}}

\paragraph{Как использовать}

К этому макросу можно относиться как к автоматически комментируемым проверкам.
Работает это так
\begin{cppcode}
void f(int* x) {
  assert(x != nullptr);
  *x = 42;
}
\end{cppcode}
Если вы хотите проверить preconditions для некоторой функции \verb"f", которая ожидает не нулевой указатель, то можно поставить в начале тела функции проверку, что указатель \verb"x" не нулевой.
При компиляции с макросом \verb"NDEBUG" вторая строчка не даст никакого кода.
А без этого макроса выполняется проверка условия внутри и если оно истинно, то исполнение переходит дальше к строке три.
Если же оно ложно, то программа падает с сообщением на какой строчке кода она упала.

По какой-то странной причине в отличие от \verb"static_assert" макрос \verb"assert" не поддерживает второй аргумент -- сообщение об ошибке.
Потому приходится прибегать к следующему трюку.
\begin{cppcode}
void f(int* x) {
  assert(x != nullptr && "The argument x must not be nullptr!");
  *x = 42;
}
\end{cppcode}
В этом случае мы передаем адрес статической константы (который всегда не ноль) и он конвертируется к \verb"true" и потом делается логическое <<и>> с проверяемым условием.

\paragraph{Рекомендации}

Мои рекомендации по по использованию \verb"assert" кратко выражаются так: чем больше, тем лучше.
Чем ближе к багу программа упадет на ошибке, тем быстрее вы его найдете и поправите.
С \verb"assert"-ами вам скорее всего придется забыть про использование дебагера, так как не понадобится.
Вот пара мыслей об использовании:
\begin{enumerate}
\item  Ставьте \verb"assert" в начале каждой функции, чтобы проверить preconditions.
Например у оператора деления второй аргумент должен быть не ноль.
Причем это не ошибка исполнения, это программист должен был проверить этот случай перед вызовом деления.
То есть программист не предусмотрел валидный случай в программе, на котором падает текущее исполнение.
\begin{cppcode}
class Int {
  ...
};

Int operator/(Int first, Int second) {
  assert(second != 0 && "The second argument of operator/ must be non-zero!");
    return first.value / second.value;
}
\end{cppcode}

\item Ставьте \verb"assert" в конце каждой мутирующей функции для проверки postcondition.
Вдруг вы где-то ошиблись с имплементацией.
\begin{cppcode}
template<class T>
class Tree {
  using Node = Node<T>;
public:
  ...
  void add_value(T value) {
    /*place the value in the tree*/
    assert(is_correct());
  }
private:
  bool is_correct() const:
  Node* root_ = nullptr;
};
\end{cppcode}

\item Все конструкторы класса должны проверять не только preconditions для аргументов, но и инварианты класса.
Выделите в классе приватные функции по проверке инвариантов и заворачивайте их внутрь \verb"assert".
\begin{cppcode}
template<class T>
class Tree {
  using Node = Node<T>;
public:
  ...
  void add_value(T value) {
    /*place the value in the tree*/
    assert(is_correct());
  }
private:
  bool is_correct() const {
    return is_correct(root_);  
  }
  static bool is_correct(Node* node) {
    if (node == nullptr)
      return true;
    bool is_node_good = /*do checks for node*/;    
    return is_node_good && is_correct(node->left) && is_correct(node->right);
  }
  Node* root_ = nullptr;
};
\end{cppcode}

\item Не пишите слишком длинные и сложные выражения внутри \verb"assert", вы иначе никогда не поймете, что вы проверяете.
Выделите отдельные вспомогательные функции с говорящими названиями.
Например
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
Плохо
\begin{cppcode}[numbers = none]
void f(int x, int y, int z) {
  assert(x > y && y <= z + x &&
        (x & !y) == 1 && "Ups!");
  /*function code*/
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
Получше
\begin{cppcode}[numbers = none]
void f(int x, int y, int z) {
  assert(is_condition_true(x, y, z) &&
        "Ups!");
  /*function code*/
}
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}
Вы конечно можете добавить комментарий и сообщение об ошибке.
Но все же имя функции скажет больше, чем комментарий.
Только важно в функциях, которые вызываются внутри \verb"assert" не делать проверок с помощью \verb"assert", а то вы можете уйти в бесконечную рекурсию вызовов \verb"assert".

\item Обязательно вставляйте \verb"assert" перед обращением через указатель, он может быть нулевой.
\begin{cppcode}
void f(A* a, B* b) {
  assert(a != nullptr && "a must not be nullptr!");
  assert(b != nullptr && "b must not be nullptr!");
  b->consume(a->produce());
}
\end{cppcode}
Обратите внимание, что две разные проверки разнесены в разные \verb"assert"-ы, чтобы при падении было понятно на какое именно условие вы упали.

Если в классе перегружен оператор \verb"operator->()", то соответствующую проверку можно выполнить внутри него.
Однако, для указателей нельзя этот оператор перегрузить, а потому вам придется делать эту проверку заранее.
В случае же класса и перегруженного оператора \verb"operator->()" проверка может выглядеть так.
\begin{cppcode}
class A {
public:
  ...
  I* operator->() const {
    assert(ptr_ != nullptr && "The object has invalid pointer!");
    return ptr_;
  }
private:
  I* ptr_ = nullptr;
};
\end{cppcode}
В данном примере мы можем спокойно звать
\begin{cppcode}
int main() {
  A a;
  a->f();
  return 0;
}
\end{cppcode}
Если в объекте \verb"a" хранится нулевой указатель, то в третьей строчке все упадет на проверке по \verb"assert".

\item НЕ делайте \verb"assert" на ошибки, которые разрешимы на этапе компиляции (например в шаблонной магии), для этого используйте \verb"static_assert".
Следующий пример возможно не самый лучший, тут можно было бы воспользоваться концептами или \verb"std::enable_if" (если вы динозвар из прошлого), но он хорошо иллюстрирует проблему.
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
Плохо
\begin{cppcode}[numbers = none]
template<class T>
void f(T x) {
  assert(std::is_arithmetic_v<T> &&
         "The type must be arithmetic!");
  /*function inplementation*/
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
Получше
\begin{cppcode}[numbers = none]
template<class T>
void f(T x) {
  static_assert(std::is_arithmetic_v<T> &&
         "The type must be arithmetic!");
  /*function inplementation*/
}
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}

\item И конечно же не забывайте сообщить об ошибке текстом.
Вам же будет проще.
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
Плохо
\begin{cppcode}[numbers = none]
#include <cassert>

int main() {
  int x = 1;
  assert(x == 1);
  return 0;
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
Получше
\begin{cppcode}[numbers = none]
#include <cassert>

int main() {
  int x = 1;
  assert(x == 1 && "x must be 1!");
  return 0;
}
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}
\end{enumerate}

\subsubsection{Кастомные \texttt{assert}-ы}

Главный недостаток \verb"assert" заключается в том, что макрос \verb"NDEBUG" отключает сразу все проверки во всех компилируемых файлах.
Если вам нужно выборочное отключение проверок, то можно сделать свои кастомные макросы на основе \verb"assert" и управлять включением и отключением проверок с помощью дополнительных макросов.
Вот как могут выглядеть кастомные \verb"assert"-ы.
\begin{cppcode}
// file custom_asserts.h
#include <cassert>

#ifndef DISABLE_ASSERTS
#define DISABLE_ASSERTS 3
#endif

#if DISABLE_ASSERTS < 0
#define ASSERT0(expr, msg) ((void)0)
#else
#define ASSERT0(expr, msg) assert(expr && msg)
#endif

#if DISABLE_ASSERTS < 1
#define ASSERT1(expr, msg) ((void)0)
#else
#define ASSERT1(expr, msg) assert(expr && msg)
#endif

#if DISABLE_ASSERTS < 2
#define ASSERT2(expr, msg) ((void)0)
#else
#define ASSERT2(expr, msg) assert(expr && msg)

#endif

#if DISABLE_ASSERTS < 3
#define ASSERT3(expr, msg) ((void)0)
#else
#define ASSERT3(expr, msg) assert(expr && msg)
#endif
\end{cppcode}
В этом примере мы вводим $4$ вида \verb"assert"-ов:
\begin{multicols}{4}
\begin{itemize}
\item \verb"ASSERT0"

\item \verb"ASSERT1"

\item \verb"ASSERT2"

\item \verb"ASSERT3"
\end{itemize}
\end{multicols}
Думать про них надо так: чем номер меньше, тем важнее \verb"assert".
Макрос \verb"DISABLE_ASSERTS" отключает \verb"assert"-ы с уровнем выше заданного.
То есть \verb"-1" отключает все сообщения об ошибках, \verb"0" оставляет только самые важные \verb"ASSERT0" и так далее.
Используется это так
\begin{cppcode}
#include "custom_asserts.h"

int main() {
  int x = 0;
  ASSERT0(x == 0, "x must be 0!");
  int y = 1;
  ASSERT1(y == 1, "y must be 1!");
  int z = 2;
  ASSERT2(z == 2, "z must be 2!");
  return 0;
}
\end{cppcode}
При необходимости отключить \verb"assert"-ы после уровня \verb"0" нужно сделать так:
\begin{cppcode}
#define DISABLE_ASSERTS 0
#include "custom_asserts.h"

int main() {
  int x = 0;
  ASSERT0(x == 0, "x must be 0!");
  int y = 1;
  ASSERT1(y == 1, "y must be 1!"); // is disabled
  int z = 2;
  ASSERT2(z == 2, "z must be 2!"); // is disabled
  return 0;
}
\end{cppcode}
Так же можно сделать \verb"assert"-ы не по уровням, а по управляемому макросу.
Например, вы хотите сделать проверки для конкретного класса или для конкретного модуля в коде.
\begin{cppcode}
// file my_assert.h
#include <cassert>

#ifndef DISALBE_MY_ASSERT
#define MY_ASSERT(expr, msg) assert(expr && msg)
#else
#define MY_ASSERT() ((void)0)
#endif
\end{cppcode}
Тогда используется это так
\begin{cppcode}
#include "my_assert"

int main() {
  int x = 1;
  MY_ASSERT(x == 1, "x must be 1!");
  int y = 2;
  ASSERT0(y == 2, "y must be 2!");
  return 0;
}
\end{cppcode}
И для отключения нужно добавить макрос отключения
\begin{cppcode}
#define DISALBE_MY_ASSERT
#include "my_assert.h"

int main() {
  int x = 1;
  MY_ASSERT(x == 1, "x must be 1!"); // is disabled
  int y = 2;
  ASSERT0(y == 2, "y must be 2!");
  return 0;
}
\end{cppcode}
Так же можно сделать свитч между тремя опциями: \verb"assert", исключение или ничего.
Например так
\begin{cppcode}
// file my_check.h
#include <cassert>
#include <exception>

#ifdef MYASSERT
#define MyCheck(expr, msg) assert(expr && msg)
#else
#ifdef MYEXCEPT
#define MyCheck(expr, msg)       \
  if (!expr)                     \
  throw std::runtime_error(msg)
#else
#define MyCheck(expr, msg) ((void)0)
#endif
#endif
\end{cppcode}
Теперь этот код можно использовать в трех случаях:
\begin{center}
\begin{tabular}{lll}
{
\begin{minipage}[\baselineskip]{5cm}
Без проверок
\begin{cppcode}[numbers = none]

#include "my_check.h"

int main() {
  int x = 1;
  MyCheck(x == 1, "Ups!");
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{5cm}
Проверка через \verb"assert"
\begin{cppcode}[numbers = none]
#define MYASSERT
#include "my_check.h"

int main() {
  int x = 1;
  MyCheck(x == 1, "Ups!");
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{5cm}
Бросаем исключение
\begin{cppcode}[numbers = none]
#define MYEXCEPT
#include "my_check.h"

int main() {
  int x = 1;
  MyCheck(x == 1, "Ups!");
}
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}


% TO DO
% Добавить тут пример того как сделать несколько макросов, которые отключатся разными командами.
% Добавить пример макросов с уровнем важности и отключать все макросы по важности ниже, чем данное значение.

\subsubsection{Exceptions}
% TO DO

Если вы хотите проверять ошибки программиста с помощью исключений, то вам надо валить вашу программу соответствующим исключением.
То есть надо кидать исключение и не перехватывать его.
Тогда в режиме дебага вы сразу увидите текущее состояние стека вызова и состояние программы в памяти при исполнении.
Наличие стека вызовов позволит лучше понять происхождение ошибки.
Однако при таком подходе вам не доступна информация лежащая в самом исключении.

Так же не пытайтесь такие ошибки обрабатывать в блоках \verb"catch".
Иначе вы получите управление логикой программы с помощью исключений.
Лучше завести какой-то служебный класс для таких ошибок и в перехватчике исключений его выбрасывать из программы.
Например так
% TO DO
% Добавить ссылку на точку входа в программу из MVC раздела
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
// file react.h
struct Die {};
void react();

// file react.cpp
void react() {
  try {
    throw;
  } catch (std::exception& e) {
    /*react to standard exception*/
  } catch (Die& die) {
    throw die; // rethrow Die exception
  } catch (...) {
    /*react to unknown exception*/
  }
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
#include "react.h"

namespace {
void f() {
  throw Die{};
}
}

int main() {
  try {
    f();
  } catch(...) {
    react();
  }
  return 0;
}
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}
Обычно дебагер позволит вам не только увидеть стек вызовов, но и прыгнуть в строчку кода, где возникло исключение.
Так же из плюсов вы увидите текущее состояние всех переменных на стеке.

\subsection{Ошибки исполнения среды}
% TO DO
% Общие слова о том, что это за ошибки и как их можно обрабатывать. Пример с быстрым выходом со стека при парсинге.


\subsubsection{Error Codes}
% TO DO

\subsubsection{\texttt{std::expected}}
% TO DO

\subsubsection{Exceptions}

Очень рекомендую посмотреть доклад Peter Muldoon \href{https://youtu.be/HXJmrMnnDYQ?si=uylqtbTLdzKMrg9S}{Exceptions in C++: Better Design Through Analysis of Real World Usage}.
Значительная часть этого раздела была написана под влиянием этого доклада.

\paragraph{Зачем?}

Прежде всего давайте поймем зачем нам в принципе в языке нужны исключения.
Казалось бы можно использовать коды с ошибками или даже \verb"std::expected".
Однако, есть два случая, когда вы не можете воспользоваться этими механизмами.
\begin{enumerate}
\item Конструкторы.
Давайте начнем с примера кода
\begin{cppcode}
class A {
public:
  A() = default;
  A(int x) : x_(x) {}
private:
  int x_ = 0;
};

int main() {
  A a;
  A b(4);
  return 0;
}
\end{cppcode}
Как мы видим в строчках~10 и~11, в синтаксисе использования конструкторов у нас нет возможности вернуть код ошибки.
Потому что конструктор должен вернуть сконструированный объект.
Точнее, это не совсем правда.
Технически устроены конструкторы объявленные в строчках~3 и~4 можно представлять себе так
\begin{cppcode}
class A {
public:
  static void ctor(A* this) = default;
  static void ctor(A* this, int x);
private:
  int x_ = 0;
};
\end{cppcode}
Так вот, конструктор получает указатель на адрес, где надо создать объект и возвращает \verb"void".
Техническую часть можно было бы изменить, но синтаксически не понятно, как это выразить.
Как в строчках~10 и~11 написать что-то, чтобы вернуть сообщение об ошибке?
Думаю тут можно было бы придумать особый синтаксис, но что если вы используете вложенные конструкторы или напрямую используете их как аргументы функции
\begin{cppcode}
function(A(), B(A(), 5), C{1, 2});
\end{cppcode}
Кто и куда тут должен возвращать ошибку?
Тут вызывается $4$ конструктора.
Как такое должно сообщать об ошибке?

\item Операторы.
Давайте посмотрим на следующий код
\begin{cppcode}
class A {
public:
  friend operator+(const A& first, const A& second);
private:
  ...
};

int main() {
  A a, b, c;
  std::cin >> a >> b;
  c = a / b;
  std::cout << c << '\n';
  return 0;
}
\end{cppcode}
В строчке~11 вызывается оператор деления.
Что если разделить на \verb"b" нельзя?
Куда сообщить об ошибке?
И опять, можно было бы придумать разные синтаксисы, но подумайте, как вы это будете применять, если у вас большое сложное арифметическое выражение.
Кроме того, тут еще есть два оператор \verb"operator>>" и \verb"operator<<" для потокового ввода вывода.
Они тоже не имеют возможности вернуть код ошибки.
Тем не менее, даже потоковые операторы для \verb"std::out" и \verb"std::cin" имеют альтернативный механизм, в рамках которого устанавливаются биты ошибок в специальном глобальном объекте.
\end{enumerate}

\paragraph{Как это работает}

Давайте посмотрим на следующий пример:
\begin{cppcode}
void g() {
  throw std::runtime_error("Ups!");
}

void f() {
  /*some work*/
  g();
  /*some work*/
}

int main() {
  try {
    f();
  } catch(std::exception& e) {
    std::cout << "Error: " << e.what() << '\n';
  } catch(...) {
    std::cout << "Unknown exception!\n";
  }
}
\end{cppcode}
Давайте опишу работу кода по строкам.
Точка входа в программу -- функция \verb"main", потому начинаем с нее.
\begin{enumerate}
\item Исполнение начинается в строке~13.
Тут вызывается функция \verb"f".
Так как мы ожидаем, что она кидает исключения, оборачиваем это в блок \verb"try", чтобы его можно было поймать.

\item Далее выполняется код в строке~6 (тут может быть много кода).

\item После этого в строке~7 вызывается функция \verb"g".

\item Управление переходит к функции \verb"g" и выполняется строчка~2.
В этой строчке бросается исключение.
В этом месте мы вываливаемся из функции \verb"g" в строчку~7 внутри функции \verb"f".

\item В строчке~7 после исключения мы должны выйти из функции \verb"f" и будем так выходить до тех пор, пока не встретим \verb"catch", который поймает исключение.
Но чтобы выйти мы должны почистить стек от функции \verb"f".
Это называется stack unwinding.
Надо удалить все локальные переменные и аргументы функции \verb"f".
Для этого после строчки 7 вызываются деструкторы всех локальных переменных на стеке, которые создала функция \verb"f".

\item Почистив стек мы выходим в больший scope из которого вызвана \verb"f".
В данном случае это строка~13.
Так как мы вышли в блок \verb"try", то мы ловим исключение и для реакции на него нужны следующие блоки \verb"catch".

\item Мы идем по блокам \verb"catch" один за одним и смотрим, есть ли хотя бы один блок, под который подходит наше исключение.
В данном случае исключение типа \verb"std::runtime_error" унаследовано от \verb"std::exception" и так как мы принимаем исключение по ссылке, то включается полиморфизм и мы можем поймать это исключение в первом блоке.
Если бы было несколько подходящих блоков, то исключение ловится первым, а остальные не реагируют.
Если нет ни одного блока, который может поймать исключение, то оно улетает дальше из текущего scope.
\end{enumerate}
Таким образом, если вы работаете с исключениями, то вообще говоря, вы можете выйти из любого scope в любой точке функции.

\paragraph{Технические детали}

Прежде чем обсуждать какие есть сложности при использовании исключений, давайте обсудим технические детали связанные с имплементацией.
Когда вы кидаете исключения надо помнить о следующем:
\begin{enumerate}
\item Как аллоцируется память для исключения в стандарте не определено.
На практике это означает, что вы всегда аллоцируете память на куче даже для стандартных типов вроде \verb"int".

\item Для того, чтобы произвести stack unwinding вам нужно для каждой точки программы знать, какие деструкторы позвать.
Как это должно делаться в стандартне не определено, но на практике есть два способа:
\begin{enumerate}
\item Frame-based.
Данный метод по сути поддерживает в run-time второй стэк, на который складываются деструкторы объектов для текущего scope.
Этот метод означает, что вы платите за исключения даже, когда их не кидаете.
Этот подход использует компилятор от Microsoft.

\item Table-based.
В данном подходе, во время компиляции программы, вы составляете таблицы для вызова нужных деструкторов из каждой точки вашего кода.
И в run-time используете эти таблицу для их вызова.
Такой подход очень сильно раздувает бинарники программы, потому что нужно хранить все эти таблицы.
Такой подход используют gcc и clang.
\end{enumerate}
\end{enumerate}
Когда мы ловим исключения надо понимать следующее:
\begin{enumerate}
\item Язык предоставляет полиморфное поведение.
То есть если вы унаследовали класс \verb"A" от класса \verb"B", то по ссылке на \verb"B" можно ловить и исключение класса \verb"A".
В стандарте не прописано как это должно быть имплементировано, но на практике всегда используется RTTI, что дорого.

\item Деаллокация памяти для исключения не специфицирована в стандарте.
На практике это значит удаление объекта с кучи и это дорого.
\end{enumerate}

\paragraph{Возможные состояния}

Здесь я хочу немного поговорить про ментальную модель для исключений и в каких состояниях может находиться ваша программа логически.
Давайте начнем с картинки:
\[
\xymatrix@R=15pt@C=15pt{
  {\text{try}}
 	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{\text{uncpecified storage}}
   	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  \\
  {\text{code throws}}\ar@/^10pt/[rr]
       	{
	\save
   [].[]*[F--]\frm{}
   \restore
	}
  &{}&{\text{exception}}\ar@/^10pt/[ddll]
   	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  \\
  {\text{catch}}
   	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{}\\
  {\text{code reacts}}
     	{
	\save
   [].[]*[F--]\frm{}
   \restore
	}
  &{}&{}\\
}
\]
Думаю, что данная диаграмма более или менее не требует объяснений.
Процесс бросания исключений в штатном режиме можно представлять себе так:
\begin{center}
\resetgitem
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\gitem Исполнение в блоке \verb"try"
\[
\xymatrix@R=15pt@C=15pt{
  {\text{try}}
 	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{\text{uncpecified storage}}
   	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  \\
  {\text{code throws}}
  %\ar@/^10pt/[rr]
       	{
	\save
   [].[]*[F--]\frm{}
   \restore
	}
  &{}&{\phantom{\text{exception}}}
  %\ar@/^10pt/[ddll]
   	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  \\
  {\text{catch}}
   	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{}\\
  {\text{code reacts}}
     	{
	\save
   [].[]*[F--]\frm{}
   \restore
	}
  &{}&{}\\
}
\]
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\gitem  Бросаем исключение
\[
\xymatrix@R=15pt@C=15pt{
  {\text{try}}
 	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{\text{uncpecified storage}}
   	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  \\
  {\text{code throws}}\ar@/^10pt/[rr]
       	{
	\save
   [].[]*[F--]\frm{}
   \restore
	}
  &{}&{\text{exception}}
  %\ar@/^10pt/[ddll]
   	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  \\
  {\text{catch}}
   	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{}\\
  {\text{code reacts}}
     	{
	\save
   [].[]*[F--]\frm{}
   \restore
	}
  &{}&{}\\
}
\]
\end{minipage}
}\\\noalign{\medskip}
{
\begin{minipage}[\baselineskip]{8cm}
\gitem Перехватываем исключение в \verb"catch"
\[
\xymatrix@R=15pt@C=15pt{
  {\text{try}}
 	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{\text{uncpecified storage}}
   	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  \\
  {\text{code throws}}
  %\ar@/^10pt/[rr]
       	{
	\save
   [].[]*[F--]\frm{}
   \restore
	}
  &{}&{\phantom{\text{exception}}}
  \ar@/^10pt/[ddll]
   	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  \\
  {\text{catch}}
   	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{}\\
  {\text{code reacts}}
     	{
	\save
   [].[]*[F--]\frm{}
   \restore
	}
  &{}&{}\\
}
\]
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\end{minipage}
}\\
\end{tabular}
\end{center}
Давайте проговорим, что тут происходит:
\begin{enumerate}
\item Начинаем исполнение программы в блоке \verb"try".

\item Код в блоке \verb"try" бросает исключение.
В этот момент объект исключения аллоцируется неспецифицированным образом.

\item Как только исключение долетело до блока \verb"try", для него ищется нужный обработчик среди присоединенных \verb"catch" блоков.
Если нужный обработчик нашелся, то мы вынимаем объект исключения оттуда, где он хранился и отдаем его в распоряжение \verb"catch" блока.
В конце обработки \verb"catch" блок сам удалит объект исключения, вам не надо об этом заботиться.
\end{enumerate}
А теперь поговорим, что в этой схеме может пойти не так.
\begin{enumerate}
\item Вы можете кинуть исключение, когда другое исключение все еще висит не обработанное.
Такое возможно, если вы бросите исключение во время stack unwinding.
По этой причине нельзя кидать исключения в деструкторах.
\[
\xymatrix@R=15pt@C=40pt{
  {\text{try}}
 	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{\text{uncpecified storage}}
   	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  \\
  {\text{code throws}}\ar@/^10pt/[rr]^{\boxed{\text{exception}}}
       	{
	\save
   [].[]*[F--]\frm{}
   \restore
	}
  &{}&{\text{exception}}%\ar@/^10pt/[ddll]
   	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  \\
  {\text{catch}}
   	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{}\\
  {\text{code reacts}}
     	{
	\save
   [].[]*[F--]\frm{}
   \restore
	}
  &{}&{}\\
}
\]
В этом случае программа падает по \verb"std::terminate".

\item Если не нашлось ни одного обработчика среди \verb"catch" блоков.
\[
\xymatrix@R=15pt@C=15pt{
  {\text{try}}
 	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{\text{uncpecified storage}}
   	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  \\
  {\text{code throws}}
       	{
	\save
   [].[]*[F--]\frm{}
   \restore
	}
  &{}&{\text{exception}}\ar[dd]
   	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  \\
  {\text{catch}}
   	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{}\\
  {\text{code reacts}}
     	{
	\save
   [].[]*[F--]\frm{}
   \restore
	}
  &{}&{\texttt{std::terminate}}\\
}
\]
При этом был ли почищен стэк с помощью stack unwinding не специфицировано.

\item Исключение брошено не внутри блока \verb"try".
В этом случае мы никогда не найдем соответствующий перехватчик для исключения.
И мы опять падаем по \verb"std::terminate".
\[
\xymatrix@R=15pt@C=15pt{
  {\phantom{\text{try}}}
% 	{
%	\save
%   [].[d]*+[F-:<3pt>]\frm{}
%   \restore
%	}
  &{}&{\text{uncpecified storage}}
   	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  \\
  {\text{code throws}}\ar@/^10pt/[rr]
       	{
	\save
   [].[]*[F--]\frm{}
   \restore
	}
  &{}&{\text{exception}}\ar[dd]
   	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  \\
  {\phantom{\text{catch}}}
%   	{
%	\save
%   [].[d]*+[F-:<3pt>]\frm{}
%   \restore
%	}
  &{}&{}\\
  {\phantom{\text{code reacts}}}
%     	{
%	\save
%   [].[]*[F--]\frm{}
%   \restore
%	}
  &{}&{\texttt{std::terminate}}\\
}
\]
\end{enumerate}

\paragraph{Важные примеры и ожидаемое поведение}

\begin{enumerate}
\item Самый первый пример, который обычно приводя -- выделение памяти.
Например, вы пытаетесь выделить память под \verb"std::vector" и ее не хватило.
Это плохой пример для использования исключений по следующим причинам:
\begin{enumerate}
\item Если вы запросили память и ее больше в системе нет, то что вы собираетесь делать?
Скорее всего у вашей системы проблемы покруче, чем невозможность продолжить работать вашей программы.
Смысла тут делать что-то нет.

\item Память запрашивает чуть ли не каждый кусок кода в любой библиотеке.
Тогда придется проверять на исключение каждое обращение к оператору выделения памяти.
В таком случае программа только и будет делать, что проверять исключения и ничего больше.
Это очень глупо.
\end{enumerate}

\item
\label{item::example::ExceptionDie}
Разумный пример, чтобы умереть.
Скажем, вы хотите работать в программе с клавиатурой через какой-нибудь интерфейс операционной системы.
Делаете запрос, на доступ к этому интерфейсу, а операционная система говорит, что нельзя и не дает доступ.
\begin{cppcode}
auto handle = access_keyboard(...);
if (!handle) {
  // cannot access the keyboard
}
\end{cppcode}
То есть системная функция вернула ошибку и вы не можете даже начать выполнение программы в таком случае.
Вот такую ситуацию как раз надо ловить исключением.
И политика тут такая, если все получилось, то хорошо, если не удалось получить доступ, то сообщаем пользователю, что у нас проблемы с доступом и завершаем работу.
Обычно за получение доступа к клавиатуре у вас будет отвечать специальный объект.
И доступ к клавиатуре вы запросите в его конструкторе.
\begin{cppcode}
class Keyboard {
public:
  Keyboard() {
    auto handle = access_keyboard(...);
    if (!handle)
      throw std::runtime_error("Cannot access the keyboard!");
  }
private:
  ...
};
\end{cppcode}
При этом для приличия такое исключение надо поймать в \verb"main", чтобы не падать по \verb"std::terminate".

\item
\label{item::example::ExceptionLive}
Разумный пример для продолжения работы.
Предположим, что вы парсите файл какого-то сложного формата.
И в рамках этого парсинга вы вызываете много вспомогательных функций.
И если возникла проблема с парсингом, то это значит, что файл прочитать нельзя, формат не верный и вы хотите быстро выйти наверх в самую старшую функцию.
\begin{cppcode}
Object parse(std::filesystem::path name) {
  File file = open_file(name);
  auto header = parse_header(file);
  auto data = parse_data(file);
  return Object(data);
}

auto parse_data(File& file) {
  ...
  parse_something(file);
  ...
  return ...;
}

auto  parse_something(File& file) {
  ...
  if (error occure)
    throw std::runtime_error("parsing error in parse_something!");
  return ...;
}
\end{cppcode}
Только теперь надо обработать эту ошибку грамотно
\begin{cppcode}
std::optional<Object> try_parse(std::filesystem::path name) noexcept {
  try {
    return parse_impl(name);
  } catch (...) {
    return std::nullopt
  }
}

Object parse(std::filesystem::path name) {
  File file = open_file(name);
  auto header = parse_header(file);
  auto data = parse_data(file);
  return Object(data);
}
\end{cppcode}
Причем мы это делаем неинтрузивно, то есть без вмешательства в имплементацию старой функции.
Обратите внимание, что старая функция всегда возвращает объект нужного типа \verb"Object", но об ошибках она сообщает с помощью исключений, которые надо ловить снаружи.
Это может быть не удобно, так как засоряет ваш код.
Вы не хотите управлять логикой программы с помощью исключений.
Для этого мы оборачиваем старую имплементацию в новую.
Новая имплементация уже не может кидать исключения, и об ошибке она сообщает уже через возвращаемое значение.
Я использовал \verb"std::optional", но можно и лучше использовать \verb"std::expected".
В таком случае вы просто пытаетесь распарсить файл и если была ошибка возвращаете пустоту, а если не было ошибки, то возвращаете данные.
После использования этой функции надо просто проверить удалось ли считать данные или нет.
И если удалось, то надо вынуть их.
Давайте сравним два обработчика:
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
try {
  Object obj = parse(file_name);
  run_program(obj);
} catch (std::exception& e) {
  print_error(e.what());
} catch(...) {
  print_error("Unknown error!");
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
std::optional<Object> obj =
                   try_parse(file_name);

if (!obj.has_value()) {
  print_error("Cannot parse file_name");
  return 0;
}
run_program(*obj);
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Обратите внимание как проще выглядит workflow во втором случае.
Во втором подходе, если вы забыли, что у вас могут быть невалидные данные после парсинга и вы попытаетесь написать такое:
\begin{cppcode}
auto obj = try_parse(file_name);
run_program(obj);
\end{cppcode}
То компилятор вам подскажет об ошибке, что вы забыли распаковать данные и передаете \verb"std::optional" вместо \verb"Object" в функцию \verb"run_program".
Однако, если в первом подходе, вы забыли поставить \verb"try/catch" блок или забыли добавить в \verb"catch" блок нужный перехватчик, то ваша программа в этом случае упадет по \verb"std::terminate" и никто вам в этом не поможет.
\end{enumerate}
Давайте я подведу итоги написанному выше.
Исключения можно использовать в двух сценариях:
\begin{enumerate}
\item На критическую ошибку, которая не позволяет продолжать работать, умереть и сообщить причину смерти пользователю.
Это был пример~\ref{item::example::ExceptionDie}.

\item На не критическую ошибку перехватить исключение и пойти по плану <<Б>> для данной ошибки.
Это был пример~\ref{item::example::ExceptionLive}.
При этом обратите внимание, что на стороне пользователя лучше иметь функцию, которая не кидает исключения, а возвращает либо объект, либо ошибку.
Потому что в этом случае попытка управления через исключения -- это ошибка дизайна.
Вы не должны управлять логикой программы с помощью исключений.
Кроме того, вам придется при каждом использовании бросающей исключения функции писать \verb"try/catch" блоки, что сделает код менее читаемым.
Лучше инкапсюлировать эту работу в другую не бросающую исключения функцию.
\end{enumerate}
Если вы используете исключения для чего-то еще, то скорее всего вы делаете что-то не так.

\paragraph{Рекомендации по использованию}

Тут я бы хотел сформулировать несколько соображений о том, как я вижу обработку исключений.
\begin{enumerate}
\item По-хорошему у вас должна быть одна точка по обработке исключений (или несколько, но не много).
Чаще всего -- это event loop в вашей программе, где вы можете сообщить об ошибке и умереть.
Или функция \verb"main", которая является последней линией обороны до выхода в операционную систему или падения по \verb"std::terminate".

\item Исключения никогда не должны быть в критической для производительности части.
Более того, рекомендуется помечать код \verb"noexcept" (даже если он кидает исключения, например на запрос памяти у системы), чтобы компилятору было дозволено больше оптимизаций.

\item Исключения не должны ни в каком виде контролировать workflow вашего кода.
За это должна отвечать логика программы.
% TO DO
% Пример
\end{enumerate}

\paragraph{Технические рекомендации}

\begin{enumerate}
\item Исключения кидаются by value.
\begin{cppcode}
throw A(1, "abc");
\end{cppcode}

\item Исключения ловятся по ссылке или константной ссылке.
Это нужно для обеспечения полиморфного поведения.
\begin{cppcode}
catch(const A& a)
\end{cppcode}

\item Повторное кидание висячего исключения делается командой \verb"throw" без аргументов.
Этот трюк используется для того, чтобы отложить реакцию на исключение.
\begin{cppcode}
void react() {
  try {
    throw;
  } catch (std::exception& e) {
    /*react to std::exception*/
  } catch (...) {
    /*react to unknown exception*/
  }
}

int main() {
  try {
    run();
  } catch(...) {
    react();
  }
}
\end{cppcode}
В этом примере, когда мы попадаем в блок \verb"catch", мы перехватили текущее исключение.
Оно больше не висит, но система знает это последнее исключение внутри блока \verb"catch".
И чтобы перекинуть его мы в функции \verb"react" используем команду \verb"throw" без аргументов в строке~3.
Однако, ее надо помещать внутри \verb"try" блока, чтобы после перекидывания, можно было поймать исключение.

\item Производные классы исключений среди \verb"catch" обработчиков должны идти перед базовыми классами, чтобы поймать наиболее специализированный тип.
\begin{cppcode}
class A {};
class B : public A {};

try {
  run();
} catch (const B& e) {
  /*reacto to B*/
} catch (const A& e) {
  /*reacto to A*/
} catch(...) {
  /*reacto to everything left*/
}
\end{cppcode}
Напомню, что блоки \verb"catch" проходятся сверху вниз по одному, и на первом подходящем блоке исключение обрабатывается и последующие \verb"catch" блоки игнорируются.

\end{enumerate}

\paragraph{Гарантии поведения при исключениях}

Предположим, мы выполняем следующий код
\begin{cppcode}
Data d = ...;
Result r;
try {
  r = algorithm(d);
} catch(...) {
}
\end{cppcode}
Вопрос, если во время выполнения алгоритма было брошено исключение, то в каком состоянии находятся \verb"d" и \verb"r"?
Если \verb"d" принимается по константной ссылке, то оно гарантировано не меняется, потому нас скорее всего интересует состояние объекта \verb"r".
Бывает три вида гарантий:
\begin{enumerate}
\item Strong Exception Guaranty.
В этом случае все объекты находятся в состоянии в каком они были до вызова функции бросающей исключение.

\item Basic Exceptioni Guaranty.
В этом случае все объекты находятся в корректном состоянии, но неизвестно в каком.
Объектами можно пользоваться, но конкретное состояние не известно и скорее всего не представляет интереса.

\item No Exception Guaranty.
Никаких гарантий.
Например, у \verb"r" из примера выше могут быть нарушены инварианты класса.
\end{enumerate}

\paragraph{Еще проблемы с исключениями}
% TO DO

\paragraph{Примеры использования исключений}
% TO DO

\subsection{Exceptions, Stack Unwinding и RAII}
% TO DO
% Не нравится как написан раздел.
% Не логично и не по порядку. Плюс есть пересечения с главами про классы. Надо его пересмотреть и понять что и как пофиксить.

\paragraph{Простой пример}

Мы уже с вами говорили, что такое RAII в разделе~\ref{section::RAII}.
Данный подход позволяет автоматизировать менеджмент ресурсов.
Пока мы не говорим об исключениях, этот RAII кажется лишь удобной автоматизацией рутинной работы.
Однако, как только вы включаете исключения в языке, то  программа может выйти из любого scope в совершенно любой точке, а не только по \verb"return", потому что именно так работают исключения.
Внутри любой функции исключение может возникнуть в любой строчке кода, а значит если исполнилась одна строчка кода, то у вас нет гарантии, что выполнится следующая.
Давайте посмотрим на следующий пример:
\begin{cppcode}
void g() {
  throw std::runtime_error("Ups!");
}

void f() {
  int* x = new(0);
  g();
  delete x;
}
\end{cppcode}
В строчке 6 вы явно выделяете память, а в строчке 7 бросается исключение и 8-я строчка никогда не вызовется.
Как вообще работает код в функции \verb"f".
Давайте опишу его по строчкам:
\begin{enumerate}
\item В строчке 6 происходит сразу несколько вещей.

\begin{enumerate}
\item Выделение памяти  на стеке для указателя \verb"x".

\item Вызов оператора \verb"new" для выделения памяти под переменную типа \verb"int", и запись по этому адресу значения \verb"0".

\item Пишем адрес памяти в переменную \verb"x".
\end{enumerate}

\item В строчке~7 вызываем функцию \verb"g".

\item Функция \verb"g" бросает исключение.
В этом месте мы вываливаемся из функции \verb"g" в строчку 7 внутри функции \verb"f".

\item В строчке 7 после исключения мы должны выйти из функции \verb"f" и будем так выходить до тех пор, пока не встретим \verb"catch", который поймает исключение.
Но чтобы выйти мы должны почистить стек от функции \verb"f".
Это называется stack unwinding.
Надо удалить все локальные переменные и аргументы функции \verb"f".
Для этого после строчки 7 вызывается деструктор \verb"x", а так как это встроенный тип, то никакого деструктора нет и мы просто уменьшаем стек и выкидываем переменную \verb"x" со стека.

\item Почистив стек мы выходим в больший scope из которого вызвана \verb"f" и продолжаем вываливаться дальше.
\end{enumerate}

\paragraph{Проблемы с исключениями}

У этого процесса есть две вещи о которых надо обязательно поговорить.
\begin{enumerate}
\item Безопасное выделение ресурсов.
Чтобы безопасно выделить и удалить память, или любой другой ресурс мы вынуждены пользоваться специальными обертками, которые делают всю работу автоматически при выходе из scope.
Для памяти такая обертка называется \verb"std::unique_ptr".
Вот тут простейший пример обертки
\begin{cppcode}
class IntPtr {
  IntPtr(int value) : ptr_(new int(value)) {}
  IntPtr(const IntPtr) = delete;
  IntPtr(IntPtr&& other) : ptr_(std::exchange(other.ptr_, nullptr)) {}
  IntPtr& operator=(const IntPtr&) = delete;
  IntPtr& operator=(IntPtr&& other) {
    IntPtr tmp = std::move(other);
    std::swap(ptr_, tmp.ptr_);
    return *this;
  }
  ~IntPtr() {
    delete ptr_;
  }
  int* ptr() const {
    return ptr_;
  }
private:
  int* ptr_;
};

void f() {
  IntPtr x(0);
  throw std::runtime_error("Exception");
}
\end{cppcode}
Теперь в строчке~22 происходит выделение памяти в конструкторе \verb"IntPtr".
А при выходе из \verb"f" по исключению, во время stack unwinding вызовется деструктор для \verb"x" и удалится выделенная память.
Такой механизм позволяет гарантированно выполнять действия при выходе из любого scope.

\item Обратите внимание на тонкий момент в предыдущей схеме.
А что если во время stack unwinding вы бросите исключение?
По стандарту -- это недопустимо.
Программа упадет в run-time вызовом \verb"terminate".
Потому никогда не бросайте исключения в деструкторах.
Это чревато и не работает.
У вас нет шансов сообщить об ошибке в деструкторе безопасно.
Их надо обрабатывать внутри самого деструктора.
Но лучше не кидать никогда.
\end{enumerate}

\subsection{Исключения и конструирование объектов}
% TO DO
% Написать, что исключение в конструкторе обрывает построение объекта и он считается не созданным.

\paragraph{Несколько ресурсов и исключения}

Теперь, что делать, если вам надо выделить память для двух указателей?
Тупой вариант такой
\begin{cppcode}
struct IntPtrPair {
  IntPtrPair(int x, int y) : ptr1_(new int(x)), ptr2_(new int(y)) {}
  ~IntPtrPair() {
    delete ptr1_;
    delete ptr2_;
  }
  int* ptr1_;
  int* ptr2_;
};

IntPtrPair x(1, 2);
\end{cppcode}
Беда этого подхода вот в чем.
Когда вы в строчке 11 вызываете конструктор, то сначала выделяется память под \verb"ptr1_", а потом под \verb"ptr2_".
И если при первом вызове память выделится, а во втором нет и будет брошено исключение.
То конструктор не завершит работу, а значит объект не будет считаться построенным, а значит и не вызовется деструктор для него во время stack unwinding.
А это значит, что память потечет круче вашей подружки.
Есть много костылей для этой проблемы, но правильное решение -- обернуть каждый указатель в свой wrapper.
Например так
\begin{cppcode}
struct IntPtrPair {
  IntPtrPair(int x, int y) : ptr1_(x), ptr2_(y) {}

  IntPtr ptr1_;
  IntPtr ptr2_;
};

IntPtrPair x(1, 2);
\end{cppcode}
И теперь вам вообще не надо париться о деструкторах и прочих радостях.
Все это за вас для каждого ресурса делает wrapper для работы с одним указателем.
На практике, конечно, надо пользоваться библиотечными опциями, тут подойдет \verb"std::unique_ptr".

\paragraph{Зависимые ресурсы и исключения}

Существует еще одна ситуация, о которой стоит рассказать.
А что если у нас данные зависимы?
Например, я должен сначала выделить память под \verb"x", а потом выделяя память под \verb"y" я должен туда положить информацию про \verb"x"?
То есть у вас есть естественная зависимость порядка конструирования данных.
А для конструирования по частям как раз и создано наследование.
Оно собирает объект в определенном порядке.
Давайте приведу такой пример
\begin{cppcode}
struct A {
  A(int x) : ptr_(std::make_unique<int>(x)) {}
  std::unique_ptr<int> ptr_;
};

struct B : A {
  A(int x)
   : A(x),
     ptr_(std::make_unique<int*>(A::ptr_.get()) {}
   std::unique_ptr<int*> ptr_;
};

B x(1);
\end{cppcode}
В таком случае у вас в строчке 13 сначала создается базовая часть объекта, то есть выделяется память под \verb"x" и кладется адрес в \verb"A::ptr_".
А потом вы выделяете память под \verb"B::ptr_" и кладете туда адрес \verb"A::ptr_" из базовой части.
Понятно, что это бессмысленная деятельность, но демонстрирует зависимость данных.
Тут прошу обратить внимание на несколько вещей:
\begin{enumerate}
\item Я везде пользуюсь wrapper-ами для указателей и мне вообще не надо задумываться про деструкторы.
\item Обратите внимание, что нигде не пользуюсь \verb"new" явно, вместо этого пользуюсь \verb"std::make_unique" функцией.
\item Если честно, то \verb"std::unique_ptr" не самая высоко оптимизированная вещь.\footnote{Кто-то, читая это, сейчас должен был брызнуть слезами смеха и отчаяния от моей аккуратности в формулировках.} Но для большинства ситуаций этой обертки хватает на ура.
Правда деревья я бы на ее основе не собирал, как минимум убьете стэк в деструкторе или получите неописуемые тормоза.
\end{enumerate}

\paragraph{Другие виды ресурсов}

Аналогично тому, что я написал про память используется для выделения других ресурсов.
Например для мьютексов используются \verb"std::lock_guard" или похожие механизмы.
Любой запрос к операционной системе, который требует освобождения своих ресурсов, должен выполняться через wrapper, где в конструкторе вы запрашиваете ресурс, а в деструкторе освобождаете.
Вот \href{https://github.com/DimaTrushin/TypingAnalysisQt/blob/master/ThreadPool.h}{тут} я могу привести пример того, как я оборачивал Windows нативный thread pool в exception safe обертку.
Это уже не искусственный пример, где много разных взаимозависимых ресурсов требуют своего последовательного выделения или освобождения.
Наследование позволяет это сделать удобным и контролируемым.
Но надо пописать какой-то код.
Обратите внимание, что в \href{https://github.com/DimaTrushin/TypingAnalysisQt/blob/master/ThreadPool.cpp}{имплементации} методов я даже позволяю себе бросать исключения в конструкторах, при наличии ошибки.
Тогда все выделенные ресурсы в базовой части автоматом почистятся и не надо переживать на эту тему.

\paragraph{Зависимые ресурсы еще раз}
% TO DO
% Перенести наверх в зависимые ресурсы, как вторую альтернативу

Напоследок хочу сказать еще одно замечание про реализацию выделения памяти под зависимые данные.
Есть другая альтернатива
\begin{cppcode}
struct A {
  A(int x)
   : ptr1_(std::make_unique<int>(x)),
     ptr2_(std::make_unique<int*>(ptr1_.get()) {}
  
  std::unique_ptr<int> ptr1_;
  std::unique_ptr<int*> ptr2_;
};

A x(1);
\end{cppcode}
Плюс такого подхода -- не вызываются лишние конструкторы, все делается в одном.
При сложной цепочке вложенных конструкторов гипотетически можно потратить много на накладные расходы.
Опять же, это все нужно измерять и я никогда не испытывал с этим проблемы, но быть они могут.
Минус в том, что этот код хрупкий.
Вы опираетесь на порядок расположения данных в коде.
А именно, вариант ниже
\begin{cppcode}
struct A {
  A(int x)
   : ptr1_(std::make_unique<int>(x)),
     ptr2_(std::make_unique<int*>(ptr1_.get())) {}
  
  std::unique_ptr<int*> ptr2_;
  std::unique_ptr<int> ptr1_;
};

A x(1); // incorrect object state
\end{cppcode}
порадует вас ошибкой в run-time.
Ваш объект будет находиться в некорректном состоянии.
Дело в том, что данные конструируются не в том порядке, в каком они идут в списке инициализации (строки 3 и 4), а в каком они объявлены в классе (строки 6 и 7).
Так что у вас сначала выполнится строка для инициализации \verb"ptr2_" и в ней вы обратитесь к функции \verb"get" неинициализированной \verb"ptr1_" и получите \verb"nullptr".
И только потом инициализируете \verb"ptr1_".
Как вы видите, после отработы конструктора \verb"ptr2_" не будет содержать адрес данных из \verb"ptr1_".
И такие ошибки хрен найдешь.
Причем совершить их очень легко -- достаточно переставить данные.
А со временем вы попросту забудете, что ваши данные были зависимы, ваш код обрастет дополнительными костылями и вы просто не заметите, что это именно эта ситуация.
Причем, код скомпилируется, запустится и даже отработает, пока вы не упадете на каком-нибудь тонком тесте.

