\ProvidesFile{Errors.tex}[Ошибки]


\section{Обработка ошибок}
% TO DO

\subsection{Виды ошибок и доступные средства}

\paragraph{Виды ошибок}

\begin{enumerate}
\item \textbf{Ошибка программиста.}
Это bug-и программы, которых в коде быть не должно.
Такие ошибки надо исправлять.

\item \textbf{Ошибка при обращении к ресурсам среды исполнения.}
Например вы пытаетесь выделить память, получить доступ на чтение или запись файла, получаете доступ на прослушивание клавиатуры, получаете доступ к вычислению на видеокарте и так далее.
Бывают разные причины, почему такие операции могут быть не успешными.
В любом случае это ошибки, которые могут встретиться в  программе и которые не связаны с некорректностью кода.
\end{enumerate}

\paragraph{Обработка ошибок}

Теперь давайте обсудим какие есть механизмы в языке для работы с ошибками.
Существуют следующие механизмы:
\begin{enumerate}
\item Макрос \verb"assert".
Технически \verb"assert" это макрос, которые ведет себя следующим образом:
\begin{itemize}
\item Если определен макрос \verb"NDEBUG"%
\footnote{Компилятор от Microsoft автоматически определяет этот макрос в релизе, а gcc и clang нет.
Бывает полезно проверить условия в релизе, потому что пути оптимизации компилятора неисповедимы.
Тогда в msvc вам надо убрать при компиляции в релизе объявление макроса \verb"NDEBUG".} , то он не дает никакого кода.

\item Если не определен макрос \verb"NDEBUG", он делает проверку условия внутри макроса и если оно ложно, то валит программу с сообщением об ошибке и указанием строчки кода, на которой все упало.
\end{itemize}
Вот как выглядит его использование
\begin{cppcode}
int f(int* x) {
  assert(x != nullptr && "The argument must not be nullptr!");
  return *x;
}

int main() {
  int x = 1;
  assert(x == 1 && "x must be 1!");
  return 0;
}
\end{cppcode}

\item Конструкция \verb"static_assert".
Это по сути то же самое, что и просто \verb"assert", только данная конструкция выполняет проверки во время компиляции, а не во время исполнения.
Все проверки условий известных на этапе компиляции должны выполняться этой функцией, а не просто \verb"assert"-ом.
Вот как выглядит его использование
\begin{cppcode}
template<class T>
class A {
  static_assert(std::is_arithmetic_v<T>, "The type T must be arithmetic!");
  ...
};
\end{cppcode}
Строчка в начале класса будет проверяться при компиляции для каждого типа \verb"T".
И если тип \verb"T" не является арифметическим, то компиляция будет падать с ошибкой, где будет указана строчка, где она произошла, и сообщение.

\item Error codes или коды ошибок.
Данный подход часто применяется в Си для обработки ошибок.
Суть его в том, что мы используем возвращаемое значение функции для указания статуса операции, а для возвращения данных используем out аргументы (см.~\ref{}).
Вот как это выглядит
\begin{cppcode}
enum class Status {
  OK, Error
};

Status algorithm(const Data& input, Result* output);

int main() {
  Data data = ...;
  Result result;
  Status status = algorithm(data, &result);
  if (status == Status::OK) {
    ...
  } else {
    ...
  }
}
\end{cppcode}


\item \verb"std::expected".
Начиная с C++23 вам наконец-то доступна возможность возвращать из функции желаемое значение или ошибку.
По сути это \verb"std::variant<ValueType, ErrorType>" но только с приятным интерфейсом.
Суть его в том, чтобы использовать коды ошибок, но при этом и ошибку и результат возвращать через \verb"return".
В коде это выглядит как-то так
\begin{cppcode}
class Error {
  ...
};

std::expected<Result, Error> algorithm(const Data& data);

int main() {
  Data data = ... ;
  auto result = algorithm(data);
  if (result.has_value()) {
    Result r = std::move(result).value();
    ...
  } else {
    ...
  }
}
\end{cppcode}

\item Исключения -- Exceptions.
Это специальная фича языка, которая позволяет генерировать исключения с помощью ключевого слова \verb"throw".
Перехватывать их можно внутри блока \verb"try" и реагировать на них внутри блока \verb"catch".
Исключения являются опасным механизмом языка, потому что они могут выйти не только из текущего scope, но и в целом подниматься по стеку до тех пор, пока их не поймают или пока исключение не улетит в операционную систему.
Из-за исключений вы должны всегда думать, что вы можете выйти из любого scope в любой точке.
Из-за этого весь менеджмент ресурсов доложен быть автоматизирован с помощью RAII (см.~раздел~\ref{section::RAII}).
В коде это выглядит как-то так
\begin{cppcode}
Result algorithm(const Data& data) {
  ...
  if (/*some error*/)
    throw std::runtime_error(/*error information*/);
  ...
  return result;
}

int main() {
  Data data = ... ;
  Result result;
  try {
    result = algorithm(data);
  } catch (std::exception& e) {
    /*handle known exceptions*/
  } catch (...) {
    /*handle unknown exceptions*/
  }
  return 0;
}
\end{cppcode}
\end{enumerate}
Методы выше можно сгруппировать так:
\begin{enumerate}
\item Задача \verb"assert" и \verb"static_assert" уронить программу на первой же ошибке.
Программа не должна продолжать работу в некорректном состоянии.
Предполагается, что вы как раз ищете ошибку в коде и это должно помочь ее найти.
Эти методы для дебага.

\item Все остальные методы: коды ошибок, \verb"std::expected" и исключения, предполагают, что вы хотите как-то отреагировать на ошибку при исполнении.
Самое главное, что вы хотите и можете продолжить исполнение дальше (возможно вы все равно хотите выйти по \verb"terminate", но у вас есть возможность не падать).
Эти методы предполагают штатное исполнение программы.
\end{enumerate}

Давайте оценим методы по информативности.
\begin{enumerate}
\item \verb"assert" и \verb"static_assert" по умолчанию сообщают вам информацию о строчке кода, на которой произошла ошибка.
У вас так же есть возможность сообщить любую другую информацию (хотя у \verb"assert" добавление информации делается костылями).
По умолчанию, нет информации о стеке вызовов для \verb"assert" (для \verb"static_assert" это не имеет смысла, так как она вызывается при компиляции, а не при исполнении).
Однако начиная с C++23 появилась возможность использовать \verb"std::stacktrace".
Он, правда, не на столько хорошо отображает информацию, как привычные для нас компиляторы.

\item Коды ошибок и \verb"std::expected".
Так как и коды ошибок и тип ошибок внутри \verb"std::expected" пишите вы сами, то тут нет информации, которая будет доступна по умолчанию.
Получить информацию о стеке вызовов вы также можете с помощью \verb"std::stacktrace".
Начиная с C++20 информацию о строчке кода, где произошла ошибка можно получить с помощью \verb"std::source_location".

\item Исключения.
По умолчанию класс для исключения пишите вы сами.
Потому вы можете поместить в него все ту же самую информацию, которая доступна и другими методами, а именно: \verb"std::stacktrace" и \verb"std::source_location".
Однако, если вы используете дебагер, то при падении на исключении, которое не было поймано, вам дебагер сообщит информацию о стеке вызовов и текущее состояние вашей программы в памяти.
Это может быть удобно, но это по сути фича дебагера, а не возможности исключений.
\end{enumerate}

\paragraph{Ожидаемое поведение}

Давайте поймем, какое поведение от программы мы ожидаем при возникновении ошибок.
Можно выделить следующие случаи:
\begin{enumerate}
\item Программа падает с сообщением об ошибке.

\item Программа сообщает об ошибке, корректно ее обрабатывает, продолжает находиться в корректном состоянии и корректно работает дальше.
\end{enumerate}
Первое поведение хорошо подходит для разработки приложения, потому что вы хотите найти ошибку как можно раньше, упасть как можно ближе к ней, чтобы найти ее и исправить.
Нет необходимости работать дальше.
Второе же поведение желательно на машине пользователя.
Какой бы ни была ошибка, пользователь не ждет, что программа упадет.
В худшем случае он ждет информации, что что-то пошло не так.
В связи с этим \verb"assert" и \verb"static_assert" подходят только для первого поведения и совсем не подходят для второго.
Их суть ровно в том, чтобы уронить программу как можно раньше.
В свою очередь коды ошибок, \verb"std::expected" и исключения технически могут быть использованы для обеих ситуаций.
Это может быть не очень разумно, но никто вам не мешает это сделать.

\subsection{Доступные инструменты}

Давайте поговорим об инструментах, которые позволяют искать ошибки программиста.
Тут обычно вспоминают два:
\begin{enumerate}
\item Дебагер.
Это специальная программа, которая позволяет позволяет следить за выполнением программы.
При этом вам обычно доступна следующая информация
\begin{enumerate}
\item Текущий стек вызовов

\item Текущие переменные и присвоенные им значения.
При этом доступна информация о типе переменной и ее адрес (если это класс, то какие поля у переменной и их значения).

\item Текущая команда в программе.
\end{enumerate}
При этом дебагер позволяет поставить точку в коде на которой вы хотите остановить исполнение.
Позволяет делать пошаговое исполнение с возможностью проваливаться внутрь функций или выполнять их как единое действие.

\item Санитайзеры.
Сразу оговорюсь это все инструменты доступные под Linux и MacOS и не доступные под Windows.
Санитайзеры -- это специальные внешние инструменты, которые следят за исполнением программы и выявляют в ней ошибки.
Например для проверки корректности работы с памятью, вся выделяемая память в вашей программе имеет специальные служебные блоки памяти вокруг каждого вызова \verb"new".
И если ваша программа обращается к служебным блокам, значит вы не верно обратились к данным.
\end{enumerate}
Хочу сказать несколько важных вещей по поводу этих инструментов.
Давайте посмотрим на диаграмму экосистемы C++ еще разок (см.~раздел~\ref{section::EcoSystem}).
Обратите внимание, что дебагер и санитайзеры находятся в самом конце пайплайна по работе с кодом.
То есть дебагер -- это ваша последняя линия обороны.
На этом этапе вы работаете напрямую с бинарным кодом.
И для того, чтобы дебагер мог делать свою работу, вам приходится компилировать программу в специальном режиме, в котором становятся доступны имена и типы объектов, расположенных в памяти.
Обычно убираются разные оптимизации, чтобы бинарный код лучше сопоставлялся с исходным кодом.
Как бы то ни было, если вы пользуетесь только дебагером и санитайзерами -- вы совершаете большую ошибку, потому что на уровне исходного кода у вас куда больше возможностей предотвратить свои ошибки и получить помощь со стороны компилятора.

\subsection{Ошибки программиста}

\subsubsection{Информация об ошибке}
% TO DO
% Есть доклад от чувака, который сделал хороший доклад про  синглтон и как его убрать из кода. Там много хорошей информации по тому, что должно быть в ошибке
TO DO

\subsubsection{\texttt{assert}}

\paragraph{Как использовать}

К этому макросу можно относиться как к автоматически комментируемым проверкам.
Работает это так
\begin{cppcode}
void f(int* x) {
  assert(x != nullptr);
  *x = 42;
}
\end{cppcode}
Если вы хотите проверить preconditions для некоторой функции \verb"f", которая ожидает не нулевой указатель, то можно поставить в начале тела функции проверку, что указатель \verb"x" не нулевой.
При компиляции с макросом \verb"NDEBUG" вторая строчка не даст никакого кода.
А без этого макроса выполняется проверка условия внутри и если оно истинно, то исполнение переходит дальше к строке три.
Если же оно ложно, то программа падает с сообщением на какой строчке кода она упала.

По какой-то странной причине в отличие от \verb"static_assert" макрос \verb"assert" не поддерживает второй аргумент -- сообщение об ошибке.
Потому приходится прибегать к следующему трюку.
\begin{cppcode}
void f(int* x) {
  assert(x != nullptr && "The argument x must not be nullptr!");
  *x = 42;
}
\end{cppcode}
В этом случае мы передаем адрес статической константы (который всегда не ноль) и он конвертируется к \verb"true" и потом делается логическое <<и>> с проверяемым условием.

\paragraph{Рекомендации}

Мои рекомендации по по использованию \verb"assert" кратко выражаются так: чем больше, тем лучше.
Чем ближе к багу программа упадет на ошибке, тем быстрее вы его найдете и поправите.
С \verb"assert"-ами вам скорее всего придется забыть про использование дебагера, так как не понадобится.
Вот пара мыслей об использовании:
\begin{enumerate}
\item  Ставьте \verb"assert" в начале каждой функции, чтобы проверить preconditions.
Например у оператора деления второй аргумент должен быть не ноль.
Причем это не ошибка исполнения, это программист должен был проверить этот случай перед вызовом деления.
То есть программист не предусмотрел валидный случай в программе, на котором падает текущее исполнение.
\begin{cppcode}
class Int {
  ...
};

Int operator/(Int first, Int second) {
  assert(second != 0 && "The second argument of operator/ must be non-zero!");
    return first.value / second.value;
}
\end{cppcode}

\item Ставьте \verb"assert" в конце каждой мутирующей функции для проверки postcondition.
Вдруг вы где-то ошиблись с имплементацией.
\begin{cppcode}
template<class T>
class Tree {
  using Node = Node<T>;
public:
  ...
  void add_value(T value) {
    /*place the value in the tree*/
    assert(is_correct());
  }
private:
  bool is_correct() const:
  Node* root_ = nullptr;
};
\end{cppcode}

\item Все конструкторы класса должны проверять не только preconditions для аргументов, но и инварианты класса.
Выделите в классе приватные функции по проверке инвариантов и заворачивайте их внутрь \verb"assert".
\begin{cppcode}
template<class T>
class Tree {
  using Node = Node<T>;
public:
  ...
  void add_value(T value) {
    /*place the value in the tree*/
    assert(is_correct());
  }
private:
  bool is_correct() const {
    return is_correct(root_);  
  }
  static bool is_correct(Node* node) {
    if (node == nullptr)
      return true;
    bool is_node_good = /*do checks for node*/;    
    return is_node_good && is_correct(node->left) && is_correct(node->right);
  }
  Node* root_ = nullptr;
};
\end{cppcode}

\item Не пишите слишком длинные и сложные выражения внутри \verb"assert", вы иначе никогда не поймете, что вы проверяете.
Выделите отдельные вспомогательные функции с говорящими названиями.
Например
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
Плохо
\begin{cppcode}[numbers = none]
void f(int x, int y, int z) {
  assert(x > y && y <= z + x &&
        (x & !y) == 1 && "Ups!");
  /*function code*/
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
Получше
\begin{cppcode}[numbers = none]
void f(int x, int y, int z) {
  assert(is_condition_true(x, y, z) &&
        "Ups!");
  /*function code*/
}
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}
Вы конечно можете добавить комментарий и сообщение об ошибке.
Но все же имя функции скажет больше, чем комментарий.
Только важно в функциях, которые вызываются внутри \verb"assert" не делать проверок с помощью \verb"assert", а то вы можете уйти в бесконечную рекурсию вызовов \verb"assert".

\item Обязательно вставляйте \verb"assert" перед обращением через указатель, он может быть нулевой.
\begin{cppcode}
void f(A* a, B* b) {
  assert(a != nullptr && "a must not be nullptr!");
  assert(b != nullptr && "b must not be nullptr!");
  b->consume(a->produce());
}
\end{cppcode}
Обратите внимание, что две разные проверки разнесены в разные \verb"assert"-ы, чтобы при падении было понятно на какое именно условие вы упали.

Если в классе перегружен оператор \verb"operator->()", то соответствующую проверку можно выполнить внутри него.
Однако, для указателей нельзя этот оператор перегрузить, а потому вам придется делать эту проверку заранее.
В случае же класса и перегруженного оператора \verb"operator->()" проверка может выглядеть так.
\begin{cppcode}
class A {
public:
  ...
  I* operator->() const {
    assert(ptr_ != nullptr && "The object has invalid pointer!");
    return ptr_;
  }
private:
  I* ptr_ = nullptr;
};
\end{cppcode}
В данном примере мы можем спокойно звать
\begin{cppcode}
int main() {
  A a;
  a->f();
  return 0;
}
\end{cppcode}
Если в объекте \verb"a" хранится нулевой указатель, то в третьей строчке все упадет на проверке по \verb"assert".

\item НЕ делайте \verb"assert" на ошибки, которые разрешимы на этапе компиляции (например в шаблонной магии), для этого используйте \verb"static_assert".
Следующий пример возможно не самый лучший, тут можно было бы воспользоваться концептами или \verb"std::enable_if" (если вы динозвар из прошлого), но он хорошо иллюстрирует проблему.
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
Плохо
\begin{cppcode}[numbers = none]
template<class T>
void f(T x) {
  assert(std::is_arithmetic_v<T> &&
         "The type must be arithmetic!");
  /*function inplementation*/
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
Получше
\begin{cppcode}[numbers = none]
template<class T>
void f(T x) {
  static_assert(std::is_arithmetic_v<T> &&
         "The type must be arithmetic!");
  /*function inplementation*/
}
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}

\item И конечно же не забывайте сообщить об ошибке текстом.
Вам же будет проще.
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
Плохо
\begin{cppcode}[numbers = none]
#include <cassert>

int main() {
  int x = 1;
  assert(x == 1);
  return 0;
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
Получше
\begin{cppcode}[numbers = none]
#include <cassert>

int main() {
  int x = 1;
  assert(x == 1 && "x must be 1!");
  return 0;
}
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}
\end{enumerate}

\subsubsection{Кастомные \texttt{assert}-ы}

Главный недостаток \verb"assert" заключается в том, что макрос \verb"NDEBUG" отключает сразу все проверки во всех компилируемых файлах.
Если вам нужно выборочное отключение проверок, то можно сделать свои кастомные макросы на основе \verb"assert" и управлять включением и отключением проверок с помощью дополнительных макросов.
Вот как могут выглядеть кастомные \verb"assert"-ы.
\begin{cppcode}
// file custom_asserts.h
#include <cassert>

#ifndef DISABLE_ASSERTS
#define DISABLE_ASSERTS 3
#endif

#if DISABLE_ASSERTS < 0
#define ASSERT0(expr, msg) ((void)0)
#else
#define ASSERT0(expr, msg) assert(expr && msg)
#endif

#if DISABLE_ASSERTS < 1
#define ASSERT1(expr, msg) ((void)0)
#else
#define ASSERT1(expr, msg) assert(expr && msg)
#endif

#if DISABLE_ASSERTS < 2
#define ASSERT2(expr, msg) ((void)0)
#else
#define ASSERT2(expr, msg) assert(expr && msg)

#endif

#if DISABLE_ASSERTS < 3
#define ASSERT3(expr, msg) ((void)0)
#else
#define ASSERT3(expr, msg) assert(expr && msg)
#endif
\end{cppcode}
В этом примере мы вводим $4$ вида \verb"assert"-ов:
\begin{multicols}{4}
\begin{itemize}
\item \verb"ASSERT0"

\item \verb"ASSERT1"

\item \verb"ASSERT2"

\item \verb"ASSERT3"
\end{itemize}
\end{multicols}
Думать про них надо так: чем номер меньше, тем важнее \verb"assert".
Макрос \verb"DISABLE_ASSERTS" отключает \verb"assert"-ы с уровнем выше заданного.
То есть \verb"-1" отключает все сообщения об ошибках, \verb"0" оставляет только самые важные \verb"ASSERT0" и так далее.
Используется это так
\begin{cppcode}
#include "custom_asserts.h"

int main() {
  int x = 0;
  ASSERT0(x == 0, "x must be 0!");
  int y = 1;
  ASSERT1(y == 1, "y must be 1!");
  int z = 2;
  ASSERT2(z == 2, "z must be 2!");
  return 0;
}
\end{cppcode}
При необходимости отключить \verb"assert"-ы после уровня \verb"0" нужно сделать так:
\begin{cppcode}
#define DISABLE_ASSERTS 0
#include "custom_asserts.h"

int main() {
  int x = 0;
  ASSERT0(x == 0, "x must be 0!");
  int y = 1;
  ASSERT1(y == 1, "y must be 1!"); // is disabled
  int z = 2;
  ASSERT2(z == 2, "z must be 2!"); // is disabled
  return 0;
}
\end{cppcode}
Так же можно сделать \verb"assert"-ы не по уровням, а по управляемому макросу.
Например, вы хотите сделать проверки для конкретного класса или для конкретного модуля в коде.
\begin{cppcode}
// file my_assert.h
#include <cassert>

#ifndef DISALBE_MY_ASSERT
#define MY_ASSERT(expr, msg) assert(expr && msg)
#else
#define MY_ASSERT() ((void)0)
#endif
\end{cppcode}
Тогда используется это так
\begin{cppcode}
#include "my_assert"

int main() {
  int x = 1;
  MY_ASSERT(x == 1, "x must be 1!");
  int y = 2;
  ASSERT0(y == 2, "y must be 2!");
  return 0;
}
\end{cppcode}
И для отключения нужно добавить макрос отключения
\begin{cppcode}
#define DISALBE_MY_ASSERT
#include "my_assert.h"

int main() {
  int x = 1;
  MY_ASSERT(x == 1, "x must be 1!"); // is disabled
  int y = 2;
  ASSERT0(y == 2, "y must be 2!");
  return 0;
}
\end{cppcode}
Так же можно сделать свитч между тремя опциями: \verb"assert", исключение или ничего.
Например так
\begin{cppcode}
// file my_check.h
#include <cassert>
#include <exception>

#ifdef MYASSERT
#define MyCheck(expr, msg) assert(expr && msg)
#else
#ifdef MYEXCEPT
#define MyCheck(expr, msg)       \
  if (!expr)                     \
  throw std::runtime_error(msg)
#else
#define MyCheck(expr, msg) ((void)0)
#endif
#endif
\end{cppcode}
Теперь этот код можно использовать в трех случаях:
\begin{center}
\begin{tabular}{lll}
{
\begin{minipage}[\baselineskip]{5cm}
Без проверок
\begin{cppcode}[numbers = none]

#include "my_check.h"

int main() {
  int x = 1;
  MyCheck(x == 1, "Ups!");
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{5cm}
Проверка через \verb"assert"
\begin{cppcode}[numbers = none]
#define MYASSERT
#include "my_check.h"

int main() {
  int x = 1;
  MyCheck(x == 1, "Ups!");
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{5cm}
Бросаем исключение
\begin{cppcode}[numbers = none]
#define MYEXCEPT
#include "my_check.h"

int main() {
  int x = 1;
  MyCheck(x == 1, "Ups!");
}
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}


% TO DO
% Добавить тут пример того как сделать несколько макросов, которые отключатся разными командами.
% Добавить пример макросов с уровнем важности и отключать все макросы по важности ниже, чем данное значение.

\subsubsection{Exceptions}
% TO DO

Если вы хотите проверять ошибки программиста с помощью исключений, то вам надо валить вашу программу соответствующим исключением.
То есть надо кидать исключение и не перехватывать его.
Тогда в режиме дебага вы сразу увидите текущее состояние стека вызова и состояние программы в памяти при исполнении.
Наличие стека вызовов позволит лучше понять происхождение ошибки.
Однако при таком подходе вам не доступна информация лежащая в самом исключении.

Так же не пытайтесь такие ошибки обрабатывать в блоках \verb"catch".
Иначе вы получите управление логикой программы с помощью исключений.
Лучше завести какой-то служебный класс для таких ошибок и в перехватчике исключений его выбрасывать из программы.
Например так
% TO DO
% Добавить ссылку на точку входа в программу из MVC раздела
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
// file react.h
struct Die {};
void react();

// file react.cpp
void react() {
  try {
    throw;
  } catch (std::exception& e) {
    /*react to standard exception*/
  } catch (Die& die) {
    throw die; // rethrow Die exception
  } catch (...) {
    /*react to unknown exception*/
  }
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
#include "react.h"

namespace {
void f() {
  throw Die{};
}
}

int main() {
  try {
    f();
  } catch(...) {
    react();
  }
  return 0;
}
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}
Обычно дебагер позволит вам не только увидеть стек вызовов, но и прыгнуть в строчку кода, где возникло исключение.
Так же из плюсов вы увидите текущее состояние всех переменных на стеке.

\subsection{Ошибки исполнения среды}
% TO DO
% Общие слова о том, что это за ошибки и как их можно обрабатывать. Пример с быстрым выходом со стека при парсинге.


\subsubsection{Error Codes}
% TO DO

\subsubsection{\texttt{std::expected}}
% TO DO

\subsubsection{Exceptions}
% TO DO

\paragraph{Зачем?}

\paragraph{Как использовать}

Теперь поговорим о ситуации, когда нужны исключения.
Причина такой ошибки -- программа хотела, система не смогла.
Например, вы пытаетесь запросить у системы ресурс, а она вам его не дает.
Обычно приводят такой пример: вы пытаетесь запросить память под вектор и система отказывает, потому что нет памяти.
Это не лучший пример вот почему
\begin{enumerate}
\item Если вы запросили память и ее больше в системе нет, то что вы собираетесь делать?
Скорее всего у вашей системы проблемы покруче, чем невозможность продолжить работать вашей программы.
Смысла тут делать что-то нет.

\item Память запрашивает чуть ли не каждый кусок кода в любой библиотеке.
И что же, тогда придется проверять на исключение каждое обращение к операционной системе?
В таком случае программа только и будет делать, что проверять исключения и ничего больше.
Это очень глупо.
\end{enumerate}
Давайте я постараюсь привести другой, более удачный пример обработки исключения.
Скажем, вы хотите работать в программе с клавиатурой через какой-нибудь интерфейс операционной системы.
Делаете запрос, на доступ к этому интерфейсу, а операционная система говорит, что нельзя и не дает доступ.
То есть у системной функции, которую вы зовете есть возможность отказать вам в доступе и вы не можете даже начать выполнение программы в таком случае.
Вот такую ситуацию как раз надо ловить исключением.
И политика тут такая, если все получилось, то хорошо, если не удалось получить доступ, то сообщаем пользователю, что у нас проблемы с доступом и умираем по \verb"terminate".

\paragraph{Не злоупотреблять исключениями}

Тут я бы хотел сформулировать несколько соображений о том, как я вижу обработку исключений.
\begin{enumerate}
\item По-хорошему у вас должна быть одна точка по обработке исключений (или несколько, но не много).
Чаще всего -- это event loop в вашей программе, где вы можете сообщить об ошибке и умереть.
Или функция \verb"main", которая является последней линией обороны до выхода в операционную систему.

\item Исключений никогда не должно быть в критической для производительности части.
Более того, рекомендуется помечать код \verb"noexcept" (даже если он кидает исключения, например на запрос памяти у системы), чтобы компилятору было дозволено больше оптимизаций.

\item Исключения не должны ни в каком виде контролировать workflow вашего кода.
За это должна отвечать логика программы.
% TO DO
% Пример
\end{enumerate}

\subsection{Exceptions, Stack Unwinding и RAII}
% TO DO
% Не нравится как написан раздел.
% Не логично и не по порядку. Плюс есть пересечения с главами про классы. Надо его пересмотреть и понять что и как пофиксить.

\paragraph{Простой пример}

Мы уже с вами говорили, что такое RAII в разделе~\ref{section::RAII}.
Данный подход позволяет автоматизировать менеджмент ресурсов.
Пока мы не говорим об исключениях, этот RAII кажется лишь удобной автоматизацией рутинной работы.
Однако, как только вы включаете исключения в языке, то  программа может выйти из любого scope в совершенно любой точке, а не только по \verb"return", потому что именно так работают исключения.
Внутри любой функции исключение может возникнуть в любой строчке кода, а значит если исполнилась одна строчка кода, то у вас нет гарантии, что выполнится следующая.
Давайте посмотрим на следующий пример:
\begin{cppcode}
void g() {
  throw std::runtime_error("Ups!");
}

void f() {
  int* x = new(0);
  g();
  delete x;
}
\end{cppcode}
В строчке 6 вы явно выделяете память, а в строчке 7 бросается исключение и 8-я строчка никогда не вызовется.
Как вообще работает код в функции \verb"f".
Давайте опишу его по строчкам:
\begin{enumerate}
\item В строчке 6 происходит сразу несколько вещей.

\begin{enumerate}
\item Выделение памяти  на стеке для указателя \verb"x".

\item Вызов оператора \verb"new" для выделения памяти под переменную типа \verb"int", и запись по этому адресу значения \verb"0".

\item Пишем адрес памяти в переменную \verb"x".
\end{enumerate}

\item В строчке~7 вызываем функцию \verb"g".

\item Функция \verb"g" бросает исключение.
В этом месте мы вываливаемся из функции \verb"g" в строчку 7 внутри функции \verb"f".

\item В строчке 7 после исключения мы должны выйти из функции \verb"f" и будем так выходить до тех пор, пока не встретим \verb"catch", который поймает исключение.
Но чтобы выйти мы должны почистить стек от функции \verb"f".
Это называется stack unwinding.
Надо удалить все локальные переменные и аргументы функции \verb"f".
Для этого после строчки 7 вызывается деструктор \verb"x", а так как это встроенный тип, то никакого деструктора нет и мы просто уменьшаем стек и выкидываем переменную \verb"x" со стека.

\item Почистив стек мы выходим в больший scope из которого вызвана \verb"f" и продолжаем вываливаться дальше.
\end{enumerate}

\paragraph{Проблемы с исключениями}

У этого процесса есть две вещи о которых надо обязательно поговорить.
\begin{enumerate}
\item Безопасное выделение ресурсов.
Чтобы безопасно выделить и удалить память, или любой другой ресурс мы вынуждены пользоваться специальными обертками, которые делают всю работу автоматически при выходе из scope.
Для памяти такая обертка называется \verb"std::unique_ptr".
Вот тут простейший пример обертки
\begin{cppcode}
class IntPtr {
  IntPtr(int value) : ptr_(new int(value)) {}
  IntPtr(const IntPtr) = delete;
  IntPtr(IntPtr&& other) : ptr_(std::exchange(other.ptr_, nullptr)) {}
  IntPtr& operator=(const IntPtr&) = delete;
  IntPtr& operator=(IntPtr&& other) {
    IntPtr tmp = std::move(other);
    std::swap(ptr_, tmp.ptr_);
    return *this;
  }
  ~IntPtr() {
    delete ptr_;
  }
  int* ptr() const {
    return ptr_;
  }
private:
  int* ptr_;
};

void f() {
  IntPtr x(0);
  throw std::runtime_error("Exception");
}
\end{cppcode}
Теперь в строчке~22 происходит выделение памяти в конструкторе \verb"IntPtr".
А при выходе из \verb"f" по исключению, во время stack unwinding вызовется деструктор для \verb"x" и удалится выделенная память.
Такой механизм позволяет гарантированно выполнять действия при выходе из любого scope.

\item Обратите внимание на тонкий момент в предыдущей схеме.
А что если во время stack unwinding вы бросите исключение?
По стандарту -- это недопустимо.
Программа упадет в run-time вызовом \verb"terminate".
Потому никогда не бросайте исключения в деструкторах.
Это чревато и не работает.
У вас нет шансов сообщить об ошибке в деструкторе безопасно.
Их надо обрабатывать внутри самого деструктора.
Но лучше не кидать никогда.
\end{enumerate}

\subsection{Исключения и конструирование объектов}
% TO DO
% Написать, что исключение в конструкторе обрывает построение объекта и он считается не созданным.

\paragraph{Несколько ресурсов и исключения}

Теперь, что делать, если вам надо выделить память для двух указателей?
Тупой вариант такой
\begin{cppcode}
struct IntPtrPair {
  IntPtrPair(int x, int y) : ptr1_(new int(x)), ptr2_(new int(y)) {}
  ~IntPtrPair() {
    delete ptr1_;
    delete ptr2_;
  }
  int* ptr1_;
  int* ptr2_;
};

IntPtrPair x(1, 2);
\end{cppcode}
Беда этого подхода вот в чем.
Когда вы в строчке 11 вызываете конструктор, то сначала выделяется память под \verb"ptr1_", а потом под \verb"ptr2_".
И если при первом вызове память выделится, а во втором нет и будет брошено исключение.
То конструктор не завершит работу, а значит объект не будет считаться построенным, а значит и не вызовется деструктор для него во время stack unwinding.
А это значит, что память потечет круче вашей подружки.
Есть много костылей для этой проблемы, но правильное решение -- обернуть каждый указатель в свой wrapper.
Например так
\begin{cppcode}
struct IntPtrPair {
  IntPtrPair(int x, int y) : ptr1_(x), ptr2_(y) {}

  IntPtr ptr1_;
  IntPtr ptr2_;
};

IntPtrPair x(1, 2);
\end{cppcode}
И теперь вам вообще не надо париться о деструкторах и прочих радостях.
Все это за вас для каждого ресурса делает wrapper для работы с одним указателем.
На практике, конечно, надо пользоваться библиотечными опциями, тут подойдет \verb"std::unique_ptr".

\paragraph{Зависимые ресурсы и исключения}

Существует еще одна ситуация, о которой стоит рассказать.
А что если у нас данные зависимы?
Например, я должен сначала выделить память под \verb"x", а потом выделяя память под \verb"y" я должен туда положить информацию про \verb"x"?
То есть у вас есть естественная зависимость порядка конструирования данных.
А для конструирования по частям как раз и создано наследование.
Оно собирает объект в определенном порядке.
Давайте приведу такой пример
\begin{cppcode}
struct A {
  A(int x) : ptr_(std::make_unique<int>(x)) {}
  std::unique_ptr<int> ptr_;
};

struct B : A {
  A(int x)
   : A(x),
     ptr_(std::make_unique<int*>(A::ptr_.get()) {}
   std::unique_ptr<int*> ptr_;
};

B x(1);
\end{cppcode}
В таком случае у вас в строчке 13 сначала создается базовая часть объекта, то есть выделяется память под \verb"x" и кладется адрес в \verb"A::ptr_".
А потом вы выделяете память под \verb"B::ptr_" и кладете туда адрес \verb"A::ptr_" из базовой части.
Понятно, что это бессмысленная деятельность, но демонстрирует зависимость данных.
Тут прошу обратить внимание на несколько вещей:
\begin{enumerate}
\item Я везде пользуюсь wrapper-ами для указателей и мне вообще не надо задумываться про деструкторы.
\item Обратите внимание, что нигде не пользуюсь \verb"new" явно, вместо этого пользуюсь \verb"std::make_unique" функцией.
\item Если честно, то \verb"std::unique_ptr" не самая высоко оптимизированная вещь.\footnote{Кто-то, читая это, сейчас должен был брызнуть слезами смеха и отчаяния от моей аккуратности в формулировках.} Но для большинства ситуаций этой обертки хватает на ура.
Правда деревья я бы на ее основе не собирал, как минимум убьете стэк в деструкторе или получите неописуемые тормоза.
\end{enumerate}

\paragraph{Другие виды ресурсов}

Аналогично тому, что я написал про память используется для выделения других ресурсов.
Например для мьютексов используются \verb"std::lock_guard" или похожие механизмы.
Любой запрос к операционной системе, который требует освобождения своих ресурсов, должен выполняться через wrapper, где в конструкторе вы запрашиваете ресурс, а в деструкторе освобождаете.
Вот \href{https://github.com/DimaTrushin/TypingAnalysisQt/blob/master/ThreadPool.h}{тут} я могу привести пример того, как я оборачивал Windows нативный thread pool в exception safe обертку.
Это уже не искусственный пример, где много разных взаимозависимых ресурсов требуют своего последовательного выделения или освобождения.
Наследование позволяет это сделать удобным и контролируемым.
Но надо пописать какой-то код.
Обратите внимание, что в \href{https://github.com/DimaTrushin/TypingAnalysisQt/blob/master/ThreadPool.cpp}{имплементации} методов я даже позволяю себе бросать исключения в конструкторах, при наличии ошибки.
Тогда все выделенные ресурсы в базовой части автоматом почистятся и не надо переживать на эту тему.

\paragraph{Зависимые ресурсы еще раз}
% TO DO
% Перенести наверх в зависимые ресурсы, как вторую альтернативу

Напоследок хочу сказать еще одно замечание про реализацию выделения памяти под зависимые данные.
Есть другая альтернатива
\begin{cppcode}
struct A {
  A(int x)
   : ptr1_(std::make_unique<int>(x)),
     ptr2_(std::make_unique<int*>(ptr1_.get()) {}
  
  std::unique_ptr<int> ptr1_;
  std::unique_ptr<int*> ptr2_;
};

A x(1);
\end{cppcode}
Плюс такого подхода -- не вызываются лишние конструкторы, все делается в одном.
При сложной цепочке вложенных конструкторов гипотетически можно потратить много на накладные расходы.
Опять же, это все нужно измерять и я никогда не испытывал с этим проблемы, но быть они могут.
Минус в том, что этот код хрупкий.
Вы опираетесь на порядок расположения данных в коде.
А именно, вариант ниже
\begin{cppcode}
struct A {
  A(int x)
   : ptr1_(std::make_unique<int>(x)),
     ptr2_(std::make_unique<int*>(ptr1_.get())) {}
  
  std::unique_ptr<int*> ptr2_;
  std::unique_ptr<int> ptr1_;
};

A x(1); // incorrect object state
\end{cppcode}
порадует вас ошибкой в run-time.
Ваш объект будет находиться в некорректном состоянии.
Дело в том, что данные конструируются не в том порядке, в каком они идут в списке инициализации (строки 3 и 4), а в каком они объявлены в классе (строки 6 и 7).
Так что у вас сначала выполнится строка для инициализации \verb"ptr2_" и в ней вы обратитесь к функции \verb"get" неинициализированной \verb"ptr1_" и получите \verb"nullptr".
И только потом инициализируете \verb"ptr1_".
Как вы видите, после отработы конструктора \verb"ptr2_" не будет содержать адрес данных из \verb"ptr1_".
И такие ошибки хрен найдешь.
Причем совершить их очень легко -- достаточно переставить данные.
А со временем вы попросту забудете, что ваши данные были зависимы, ваш код обрастет дополнительными костылями и вы просто не заметите, что это именно эта ситуация.
Причем, код скомпилируется, запустится и даже отработает, пока вы не упадете на каком-нибудь тонком тесте.

