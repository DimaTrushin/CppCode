\ProvidesFile{Errors.tex}[Ошибки]


\section{Обработка ошибок}

Очень рекомендую посмотреть доклад Peter Muldoon \href{https://youtu.be/HXJmrMnnDYQ?si=uylqtbTLdzKMrg9S}{Exceptions in C++: Better Design Through Analysis of Real World Usage}.
Значительная часть этого раздела была написана под влиянием этого доклада.

\subsection{Виды ошибок и доступные средства}

\paragraph{Виды ошибок}

\begin{enumerate}
\item \textbf{Ошибка программиста.}
Это bug-и программы, которых в коде быть не должно.
Такие ошибки надо исправлять.

\item \textbf{Ошибка при обращении к ресурсам среды исполнения.}
Например вы пытаетесь выделить память, получить доступ на чтение или запись файла, получаете доступ на прослушивание клавиатуры, получаете доступ к вычислению на видеокарте и так далее.
Бывают разные причины, почему такие операции могут быть не успешными.
В любом случае это ошибки, которые могут встретиться в  программе и которые не связаны с некорректностью кода.
\end{enumerate}

\paragraph{Обработка ошибок}

Теперь давайте обсудим какие есть механизмы в языке для работы с ошибками.
Существуют следующие механизмы:
\begin{enumerate}
\item Макрос \verb"assert".
Технически \verb"assert" это макрос, которые ведет себя следующим образом:
\begin{itemize}
\item Если определен макрос \verb"NDEBUG"%
\footnote{Компилятор от Microsoft автоматически определяет этот макрос в релизе, а gcc и clang нет.
Бывает полезно проверить условия в релизе, потому что пути оптимизации компилятора неисповедимы.
Тогда в msvc вам надо убрать при компиляции в релизе объявление макроса \verb"NDEBUG".} , то он не дает никакого кода.

\item Если не определен макрос \verb"NDEBUG", он делает проверку условия внутри макроса и если оно ложно, то валит программу с сообщением об ошибке и указанием строчки кода, на которой все упало.
\end{itemize}
Вот как выглядит его использование
\begin{cppcode}
int f(int* x) {
  assert(x != nullptr && "The argument must not be nullptr!");
  return *x;
}

int main() {
  int x = 1;
  assert(x == 1 && "x must be 1!");
  return 0;
}
\end{cppcode}

\item Конструкция \verb"static_assert".
Это по сути то же самое, что и просто \verb"assert", только данная конструкция выполняет проверки во время компиляции, а не во время исполнения.
Все проверки условий известных на этапе компиляции должны выполняться этой функцией, а не просто \verb"assert"-ом.
Вот как выглядит его использование
\begin{cppcode}
template<class T>
class A {
  static_assert(std::is_arithmetic_v<T>, "The type T must be arithmetic!");
  ...
};
\end{cppcode}
Строчка в начале класса будет проверяться при компиляции для каждого типа \verb"T".
И если тип \verb"T" не является арифметическим, то компиляция будет падать с ошибкой, где будет указана строчка, где она произошла, и сообщение.

\item Error codes или коды ошибок.
Данный подход часто применяется в Си для обработки ошибок.
Суть его в том, что мы используем возвращаемое значение функции для указания статуса операции, а для возвращения данных используем out аргументы (см. раздел~\ref{section::Explicitness} часть <<Аргументы ссылки>>).
Вот как это выглядит
\begin{cppcode}
enum class Status {
  OK, Error
};

Status algorithm(const Data& input, Result* output);

int main() {
  Data data = ...;
  Result result;
  Status status = algorithm(data, &result);
  if (status == Status::OK) {
    ...
  } else {
    ...
  }
}
\end{cppcode}


\item \verb"std::expected".
Начиная с C++23 вам наконец-то доступна возможность возвращать из функции желаемое значение или ошибку.
По сути это \verb"std::variant<ValueType, ErrorType>" но только с приятным интерфейсом.
Суть его в том, чтобы использовать коды ошибок, но при этом и ошибку и результат возвращать через \verb"return".
В коде это выглядит как-то так
\begin{cppcode}
class Error {
  ...
};

std::expected<Result, Error> algorithm(const Data& data);

int main() {
  Data data = ... ;
  auto result = algorithm(data);
  if (result.has_value()) {
    Result r = std::move(result).value();
    ...
  } else {
    ...
  }
}
\end{cppcode}

\item Исключения -- Exceptions.
Это специальная фича языка, которая позволяет генерировать исключения с помощью ключевого слова \verb"throw".
Перехватывать их можно внутри блока \verb"try" и реагировать на них внутри блока \verb"catch".
Исключения являются опасным механизмом языка, потому что они могут выйти не только из текущего scope, но и в целом подниматься по стеку до тех пор, пока их не поймают или пока исключение не улетит в операционную систему.
Из-за исключений вы должны всегда думать, что вы можете выйти из любого scope в любой точке.
Из-за этого весь менеджмент ресурсов доложен быть автоматизирован с помощью RAII (см.~раздел~\ref{section::RAII}).
В коде это выглядит как-то так
\begin{cppcode}
Result algorithm(const Data& data) {
  ...
  if (/*some error*/)
    throw std::runtime_error(/*error information*/);
  ...
  return result;
}

int main() {
  Data data = ... ;
  Result result;
  try {
    result = algorithm(data);
  } catch (std::exception& e) {
    /*handle known exceptions*/
  } catch (...) {
    /*handle unknown exceptions*/
  }
  return 0;
}
\end{cppcode}
\end{enumerate}
Методы выше можно сгруппировать так:
\begin{enumerate}
\item Задача \verb"assert" и \verb"static_assert" уронить программу на первой же ошибке.
Программа не должна продолжать работу в некорректном состоянии.
Предполагается, что вы как раз ищете ошибку в коде и это должно помочь ее найти.
Эти методы для дебага.

\item Все остальные методы: коды ошибок, \verb"std::expected" и исключения, предполагают, что вы хотите как-то отреагировать на ошибку при исполнении.
Самое главное, что вы хотите и можете продолжить исполнение дальше (возможно вы все равно хотите выйти по \verb"terminate", но у вас есть возможность не падать).
Эти методы предполагают штатное исполнение программы.
\end{enumerate}

Давайте оценим методы по информативности.
\begin{enumerate}
\item \verb"assert" и \verb"static_assert" по умолчанию сообщают вам информацию о строчке кода, на которой произошла ошибка.
У вас так же есть возможность сообщить любую другую информацию (хотя у \verb"assert" добавление информации делается костылями).
По умолчанию, нет информации о стеке вызовов для \verb"assert" (для \verb"static_assert" это не имеет смысла, так как она вызывается при компиляции, а не при исполнении).
Однако начиная с C++23 появилась возможность использовать \verb"std::stacktrace".
Он, правда, не на столько хорошо отображает информацию, как привычные для нас компиляторы.

\item Коды ошибок и \verb"std::expected".
Так как и коды ошибок и тип ошибок внутри \verb"std::expected" пишите вы сами, то тут нет информации, которая будет доступна по умолчанию.
Получить информацию о стеке вызовов вы также можете с помощью \verb"std::stacktrace".
Начиная с C++20 информацию о строчке кода, где произошла ошибка можно получить с помощью \verb"std::source_location".

\item Исключения.
По умолчанию класс для исключения пишите вы сами.
Потому вы можете поместить в него все ту же самую информацию, которая доступна и другими методами, а именно: \verb"std::stacktrace" и \verb"std::source_location".
Однако, если вы используете дебагер, то при падении на исключении, которое не было поймано, вам дебагер сообщит информацию о стеке вызовов и текущее состояние вашей программы в памяти.
Это может быть удобно, но это по сути фича дебагера, а не возможности исключений.
\end{enumerate}

\paragraph{Ожидаемое поведение}

Давайте поймем, какое поведение от программы мы ожидаем при возникновении ошибок.
Можно выделить следующие случаи:
\begin{enumerate}
\item Программа падает с сообщением об ошибке.

\item Программа сообщает об ошибке, корректно ее обрабатывает, продолжает находиться в корректном состоянии и корректно работает дальше.
\end{enumerate}
Первое поведение хорошо подходит для разработки приложения, потому что вы хотите найти ошибку как можно раньше, упасть как можно ближе к ней, чтобы найти ее и исправить.
Нет необходимости работать дальше.
Второе же поведение желательно на машине пользователя.
Какой бы ни была ошибка, пользователь не ждет, что программа упадет.
В худшем случае он ждет информации, что что-то пошло не так.
В связи с этим \verb"assert" и \verb"static_assert" подходят только для первого поведения и совсем не подходят для второго.
Их суть ровно в том, чтобы уронить программу как можно раньше.
В свою очередь коды ошибок, \verb"std::expected" и исключения технически могут быть использованы для обеих ситуаций.
Это может быть не очень разумно, но никто вам не мешает это сделать.

\subsection{Доступные инструменты}

Давайте поговорим об инструментах, которые позволяют искать ошибки программиста.
Тут обычно вспоминают два:
\begin{enumerate}
\item Дебагер.
Это специальная программа, которая позволяет позволяет следить за выполнением программы.
При этом вам обычно доступна следующая информация
\begin{enumerate}
\item Текущий стек вызовов

\item Текущие переменные и присвоенные им значения.
При этом доступна информация о типе переменной и ее адрес (если это класс, то какие поля у переменной и их значения).

\item Текущая команда в программе.
\end{enumerate}
При этом дебагер позволяет поставить точку в коде на которой вы хотите остановить исполнение.
Позволяет делать пошаговое исполнение с возможностью проваливаться внутрь функций или выполнять их как единое действие.

\item Санитайзеры.
Сразу оговорюсь это все инструменты доступные под Linux и MacOS и не доступные под Windows.
Санитайзеры -- это специальные внешние инструменты, которые следят за исполнением программы и выявляют в ней ошибки.
Например для проверки корректности работы с памятью, вся выделяемая память в вашей программе имеет специальные служебные блоки памяти вокруг каждого вызова \verb"new".
И если ваша программа обращается к служебным блокам, значит вы не верно обратились к данным.
\end{enumerate}
Хочу сказать несколько важных вещей по поводу этих инструментов.
Давайте посмотрим на диаграмму экосистемы C++ еще разок (см.~раздел~\ref{section::EcoSystem}).
Обратите внимание, что дебагер и санитайзеры находятся в самом конце пайплайна по работе с кодом.
То есть дебагер -- это ваша последняя линия обороны.
На этом этапе вы работаете напрямую с бинарным кодом.
И для того, чтобы дебагер мог делать свою работу, вам приходится компилировать программу в специальном режиме, в котором становятся доступны имена и типы объектов, расположенных в памяти.
Обычно убираются разные оптимизации, чтобы бинарный код лучше сопоставлялся с исходным кодом.
Как бы то ни было, если вы пользуетесь только дебагером и санитайзерами -- вы совершаете большую ошибку, потому что на уровне исходного кода у вас куда больше возможностей предотвратить свои ошибки и получить помощь со стороны компилятора.

\subsection{Информация об ошибке}
\label{section::ErrorMsg}

Информация об ошибке нужна для того, чтобы выявить и исправить проблему.
Это может быть как ошибка на стороне программы, так и на стороне среды исполнения.
В идеале следующая информация должна быть доступна:
\begin{enumerate}
\item Текстовое описание ошибки.
Технически эту информацию можно хранить в \verb"std::string".
Данная информация должна быть модифицируемой, чтобы вы могли добавлять информацию об ошибке, при передаче ошибки при раскручивании стека.

\item Строчка в коде, на которой произошла ошибка.
Для получения этой информации с C++20 можно использовать \verb"std::source_location".
Эта информация должна быть константной.

\item Состояние стека вызовов во время произошедшей ошибки.
Для получения этой информации с C++23 можно использовать \verb"std::stacktrace".
Эта информация должна быть константной.

\item Какая-то специфическая для этой ошибки информация.
Это произвольный тип, который настраивается под каждую ошибку.
Данная информация должна быть модифицируемой, чтобы вы могли добавлять информацию об ошибке, при передаче ошибки при раскручивании стека.
\end{enumerate}
Независимо от метода, который вы используете и которые описаны ниже, независимо от того ошибка это программиста или ошибка исполнения среды, вам всегда достаточно информации выше.
При бывает, что можно обойтись меньшим количеством информации,  например, в простых \verb"assert"-ах.

\paragraph{Как собрать информацию о строке кода}

Давайте начнем с простого примера.
\begin{cppcode}
#include <source_location>

void f() {
  std::cout << std::source_location::current() << '\n';
}

int main() {
  f();
  return 0;
}
\end{cppcode}
Где для вывода информации о точке кода делается с помощью следующего оператора:
\begin{cppcode}
std::ostream& operator<<(std::ostream& out, const std::source_location& location) {
  out << location.file_name() << "(" << location.line() << ":"
      << location.column() << "), function '" << location.function_name()
      << "'";
  return out;
}
\end{cppcode}
Вывод будет выглядеть как-то так
\begin{cppcode}
main.cpp(4:38), function 'void __cdecl f(void)'
\end{cppcode}
То есть функция \verb"current" вызвана в строчке~$4$ и ее имя находится в столбце~$38$.
А что если мы теперь хотим автоматизировать печать информации и завернуть ее во вспомогательную функцию.
Тогда можно было бы попытаться написать так
\begin{cppcode}
#include <source_location>

void print_location() {
  std::cout << std::source_location::current() << '\n';
}

void f() {
  print_location();
}

int main() {
  f();
  return 0;
}
\end{cppcode}
Но в этом случае будет показана информация о $4$-ой строке, а не о $8$-ой.
Другой вариант передавать эту информацию явно:
\begin{cppcode}
#include <source_location>

void print_location(const  std::source_location& location) {
  std::cout << location << '\n';
}

void f() {
  print_location(std::source_location::current());
}

int main() {
  f();
  return 0;
}
\end{cppcode}
Но это ничуть не лучше, потому что все равно надо писать вызов функции \verb"current".
Завернуть этот вызов можно только в макрос, иначе она покажет точку в функции обертке, а не где мы ее вызываем.
Макрос -- плохая идея, потому что вы вводите глобальное имя, которое может потенциально конфликтовать с чем угодно.
А для избежания конфликта, вам все равно придется давать длинное имя макросу.
В этом случае есть следующий трюк -- аргументы по умолчанию.
\begin{cppcode}
#include <source_location>

void print_location(const  std::source_location& location = std::source_location::current()) {
  std::cout << location << '\n';
}

void f() {
  print_location();
}

int main() {
  f();
  return 0;
}
\end{cppcode}
Теперь вывод будет как надо.
В этом случае в строчке~$8$ при вызове функции \verb"print_location" логически аргументы по умолчанию считаются в этой строчке до вызова функции.
Вывод будет:
\begin{cppcode}
main.cpp(8:3), function 'void __cdecl f(void)'
\end{cppcode}

\paragraph{Как собрать информацию о состоянии стека}

В этом случае работают все те же правила и трюки, что использовались в случае информации о точке исполнения в коде.
Единственное -- нам надо научиться печатать информацию о стеке.
Начнем опять с простого примера.
\begin{cppcode}
#include <stacktrace>

void f() {
  std::cout << std::stacktrace::current();
}

int main() {
  f();
  return 0;
}
\end{cppcode}
В этом случае оператор вывода для состояния стека определяется так:
\begin{cppcode}
std::ostream& operator<<(std::ostream& out, const std::stacktrace& backtrace) {
  for (auto iter = backtrace.begin(); iter != (backtrace.end()); ++iter) {
    out << iter->source_file() << "(" << iter->source_line()
        << "):" << iter->description() << '\n';
  }
  return out;
}
\end{cppcode}
Вывод будет выглядеть следующим образом:
\begin{cppcode}
PathToProject\main.cpp(5599):Project!f+0x29
PathToProject\main.cpp(5682):Project!main+0xB
..\exe_common.inl(79):Project!invoke_main+0x39
..\exe_common.inl(288):Project!__scrt_common_main_seh+0x132
..\exe_common.inl(331):Project!__scrt_common_main+0xE
..\exe_main.cpp(17):Project!mainCRTStartup+0xE
(0):KERNEL32!BaseThreadInitThunk+0x14
(0):ntdll!RtlUserThreadStart+0x21
\end{cppcode}
Обратите внимание, что нижние~$6$ строк о состоянии стека -- это вызов системных функций и лишь верхние две строчки показывают стек вызова для вашей программы.
Если вы хотите убрать эти последние~$6$ строк, то можно сделать так:
\begin{cppcode}
std::ostream& operator<<(std::ostream& out, const std::stacktrace& backtrace) {
  static constexpr int bound = 6;
  if (backtrace.size() < bound)
    return out;
  for (auto iter = backtrace.begin(); iter != (backtrace.end() - bound); ++iter) {
    out << iter->source_file() << "(" << iter->source_line()
        << "):" << iter->description() << '\n';
  }
  return out;
}
\end{cppcode}
Что превратит вывод в
\begin{cppcode}
PathToProject\main.cpp(5599):Project!f+0x29
PathToProject\main.cpp(5682):Project!main+0xB
\end{cppcode}
Получилось сильно лучше.
Если вы хотите автоматизировать сбор информации о стке, то надо так же воспользоваться аргументами по умолчанию.
\begin{cppcode}
#include <stacktrace>

void print_stack(const std::stacktrace& stack = std::stacktrace::current()) {
  std::cout << std::stacktrace::current();
}

void f() {
  print_stack();
}

int main() {
  f();
  return 0;
}
\end{cppcode}

\subsection{Ошибки программиста}

\subsubsection{\texttt{assert}}

\paragraph{Как использовать}

К этому макросу можно относиться как к автоматически комментируемым проверкам.
Работает это так
\begin{cppcode}
void f(int* x) {
  assert(x != nullptr);
  *x = 42;
}
\end{cppcode}
Если вы хотите проверить preconditions для некоторой функции \verb"f", которая ожидает не нулевой указатель, то можно поставить в начале тела функции проверку, что указатель \verb"x" не нулевой.
При компиляции с макросом \verb"NDEBUG" вторая строчка не даст никакого кода.
А без этого макроса выполняется проверка условия внутри и если оно истинно, то исполнение переходит дальше к строке три.
Если же оно ложно, то программа падает с сообщением на какой строчке кода она упала.
Сообщение об ошибке пишется в \verb"stderr".
Чтобы руками добавить сообщение к \verb"assert" можно писать в поток \verb"std::cerr".

По какой-то странной причине в отличие от \verb"static_assert" макрос \verb"assert" не поддерживает второй аргумент -- сообщение об ошибке.
Потому приходится прибегать к следующему трюку.
\begin{cppcode}
void f(int* x) {
  assert(x != nullptr && "The argument x must not be nullptr!");
  *x = 42;
}
\end{cppcode}
В этом случае мы передаем адрес статической константы (который всегда не ноль) и он конвертируется к \verb"true" и потом делается логическое <<и>> с проверяемым условием.

\paragraph{Информация о стеке вызовов}

Макрос \verb"assert" печатает строчку на которой он упал.
Потому если строчка содержит текстовую константу, то вы увидите ее содержимое.
Например
\begin{cppcode}
#include <cassert>

int main() {
  int x = 0;
  assert(x != 0 && "x must not be 0!");
  return 0;
}
\end{cppcode}
Вывод будет:
\begin{cppcode}
Assertion failed: x != 0 && "x must not be 0!", file PathToProject\main.cpp, line 5
\end{cppcode}
Если же вы хотите добавить неконстантную информацию, то вам нужно писать в \verb"std::cerr" перед вызовом \verb"assert".
Давайте покажем, как это можно сделать на примере добавления информации о стеке вызовов.
Введем вспомогательную функцию
\begin{cppcode}
bool stack_state(const std::stacktrace& backtrace = std::stacktrace::current()) {
  std::cerr << "Call Stack:\n" << backtrace << '\n';
  return true;
}
\end{cppcode}
Теперь можно написать следующее:
\begin{cppcode}
#include <cassert>

int main() {
  int x = 0;
  assert(stack_state() && x != 0 && "x must not be 0!");
  return 0;
}
\end{cppcode}
Обратите внимание, что вызов функции \verb"stack_state" должен быть самым первым из-за ленивых вычислений в логических операторах.
Если первое условие ложно в коньюнкции, то второе даже не вычисляется.
Так же я размещаю вызов этой функции внутри \verb"assert", чтобы при отключении \verb"assert"-ов, эта функция не вызывалась.
В этом случае вывод будет:
\begin{cppcode}
Call Stack:
PathToProject\main.cpp(5):Project!main+0x25

Assertion failed: stack_state() && x != 0 && "x must not be 0!",
file PathToProject\main.cpp, line 5
\end{cppcode}
Аналогично можно добавлять любую информацию к \verb"assert".
Информацию о строке кода добавлять не надо, так как она и так выводится.

\paragraph{Рекомендации}

Мои рекомендации по использованию \verb"assert" кратко выражаются так: чем больше, тем лучше.
Чем ближе к багу программа упадет на ошибке, тем быстрее вы его найдете и поправите.
С \verb"assert"-ами вам скорее всего придется забыть про использование дебагера, так как не понадобится.
Вот пара мыслей об использовании:
\begin{enumerate}
\item  Ставьте \verb"assert" в начале каждой функции, чтобы проверить preconditions.
Например у оператора деления второй аргумент должен быть не ноль.
Причем это не ошибка исполнения, это программист должен был проверить этот случай перед вызовом деления.
То есть программист не предусмотрел валидный случай в программе, на котором падает текущее исполнение.
\begin{cppcode}
class Int {
  ...
};

Int operator/(Int first, Int second) {
  assert(second != 0 && "The second argument of operator/ must be non-zero!");
    return first.value / second.value;
}
\end{cppcode}

\item Ставьте \verb"assert" в конце каждой мутирующей функции для проверки postcondition.
Вдруг вы где-то ошиблись с имплементацией.
\begin{cppcode}
template<class T>
class Tree {
  using Node = Node<T>;
public:
  ...
  void add_value(T value) {
    /*place the value in the tree*/
    assert(is_correct());
  }
private:
  bool is_correct() const:
  Node* root_ = nullptr;
};
\end{cppcode}

\item Все конструкторы класса должны проверять не только preconditions для аргументов, но и инварианты класса.
Выделите в классе приватные функции по проверке инвариантов и заворачивайте их внутрь \verb"assert".
\begin{cppcode}
template<class T>
class Tree {
  using Node = Node<T>;
public:
  ...
  void add_value(T value) {
    /*place the value in the tree*/
    assert(is_correct());
  }
private:
  bool is_correct() const {
    return is_correct(root_);  
  }
  static bool is_correct(Node* node) {
    if (node == nullptr)
      return true;
    bool is_node_good = /*do checks for node*/;    
    return is_node_good && is_correct(node->left) && is_correct(node->right);
  }
  Node* root_ = nullptr;
};
\end{cppcode}

\item Не пишите слишком длинные и сложные выражения внутри \verb"assert", вы иначе никогда не поймете, что вы проверяете.
Выделите отдельные вспомогательные функции с говорящими названиями.
Например
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
Плохо
\begin{cppcode}[numbers = none]
void f(int x, int y, int z) {
  assert(x > y && y <= z + x &&
        (x & !y) == 1 && "Ups!");
  /*function code*/
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
Получше
\begin{cppcode}[numbers = none]
void f(int x, int y, int z) {
  assert(is_condition_true(x, y, z) &&
        "Ups!");
  /*function code*/
}
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}
Вы конечно можете добавить комментарий и сообщение об ошибке.
Но все же имя функции скажет больше, чем комментарий.
Только важно в функциях, которые вызываются внутри \verb"assert" не делать проверок с помощью \verb"assert", а то вы можете уйти в бесконечную рекурсию вызовов \verb"assert".

\item Обязательно вставляйте \verb"assert" перед обращением через указатель, он может быть нулевой.
\begin{cppcode}
void f(A* a, B* b) {
  assert(a != nullptr && "a must not be nullptr!");
  assert(b != nullptr && "b must not be nullptr!");
  b->consume(a->produce());
}
\end{cppcode}
Обратите внимание, что две разные проверки разнесены в разные \verb"assert"-ы, чтобы при падении было понятно на какое именно условие вы упали.

Если в классе перегружен оператор \verb"operator->()", то соответствующую проверку можно выполнить внутри него.
Однако, для указателей нельзя этот оператор перегрузить, а потому вам придется делать эту проверку заранее.
В случае же класса и перегруженного оператора \verb"operator->()" проверка может выглядеть так.
\begin{cppcode}
class A {
public:
  ...
  I* operator->() const {
    assert(ptr_ != nullptr && "The object has invalid pointer!");
    return ptr_;
  }
private:
  I* ptr_ = nullptr;
};
\end{cppcode}
В данном примере мы можем спокойно звать
\begin{cppcode}
int main() {
  A a;
  a->f();
  return 0;
}
\end{cppcode}
Если в объекте \verb"a" хранится нулевой указатель, то в третьей строчке все упадет на проверке по \verb"assert".

\item НЕ делайте \verb"assert" на ошибки, которые разрешимы на этапе компиляции (например в шаблонной магии), для этого используйте \verb"static_assert".
Следующий пример возможно не самый лучший, тут можно было бы воспользоваться концептами или \verb"std::enable_if" (если вы динозвар из прошлого), но он хорошо иллюстрирует проблему.
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
Плохо
\begin{cppcode}[numbers = none]
template<class T>
void f(T x) {
  assert(std::is_arithmetic_v<T> &&
         "The type must be arithmetic!");
  /*function inplementation*/
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
Получше
\begin{cppcode}[numbers = none]
template<class T>
void f(T x) {
  static_assert(std::is_arithmetic_v<T> &&
         "The type must be arithmetic!");
  /*function inplementation*/
}
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}

\item И конечно же не забывайте сообщить об ошибке текстом или добавить информацию о стеке вызовов или любую другую полезную для дебага информацию.
Вам же будет проще.
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
Плохо
\begin{cppcode}[numbers = none]
#include <cassert>

int main() {
  int x = 1;
  assert(x == 1);
  return 0;
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
Получше
\begin{cppcode}[numbers = none]
#include <cassert>

int main() {
  int x = 1;
  assert(x == 1 && "x must be 1!");
  return 0;
}
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}
\end{enumerate}

\subsubsection{Кастомные \texttt{assert}-ы}

Главный недостаток \verb"assert" заключается в том, что макрос \verb"NDEBUG" отключает сразу все проверки во всех компилируемых файлах.
Если вам нужно выборочное отключение проверок, то можно сделать свои кастомные макросы на основе \verb"assert" и управлять включением и отключением проверок с помощью дополнительных макросов.
Такое может понадобиться, если вы захотите запустить часть недорогих проверок (как например проверка указателя на \verb"nullptr" перед разыменованием) в релизе (который идет в прод) и отключить все дорогие проверки.
Вот как могут выглядеть кастомные \verb"assert"-ы.
\begin{cppcode}
// file custom_asserts.h
#include <cassert>

#ifndef DISABLE_ASSERTS
#define DISABLE_ASSERTS 3
#endif

#if DISABLE_ASSERTS < 0
#define ASSERT0(expr, msg) ((void)0)
#else
#define ASSERT0(expr, msg) assert(expr && msg)
#endif

#if DISABLE_ASSERTS < 1
#define ASSERT1(expr, msg) ((void)0)
#else
#define ASSERT1(expr, msg) assert(expr && msg)
#endif

#if DISABLE_ASSERTS < 2
#define ASSERT2(expr, msg) ((void)0)
#else
#define ASSERT2(expr, msg) assert(expr && msg)

#endif

#if DISABLE_ASSERTS < 3
#define ASSERT3(expr, msg) ((void)0)
#else
#define ASSERT3(expr, msg) assert(expr && msg)
#endif
\end{cppcode}
В этом примере мы вводим $4$ вида \verb"assert"-ов:
\begin{multicols}{4}
\begin{itemize}
\item \verb"ASSERT0"

\item \verb"ASSERT1"

\item \verb"ASSERT2"

\item \verb"ASSERT3"
\end{itemize}
\end{multicols}
Думать про них надо так: чем номер меньше, тем важнее \verb"assert".
Макрос \verb"DISABLE_ASSERTS" отключает \verb"assert"-ы с уровнем выше заданного.
То есть \verb"-1" отключает все сообщения об ошибках, \verb"0" оставляет только самые важные \verb"ASSERT0" и так далее.
Используется это так
\begin{cppcode}
#include "custom_asserts.h"

int main() {
  int x = 0;
  ASSERT0(x == 0, "x must be 0!");
  int y = 1;
  ASSERT1(y == 1, "y must be 1!");
  int z = 2;
  ASSERT2(z == 2, "z must be 2!");
  return 0;
}
\end{cppcode}
При необходимости отключить \verb"assert"-ы после уровня \verb"0" нужно сделать так:
\begin{cppcode}
#define DISABLE_ASSERTS 0
#include "custom_asserts.h"

int main() {
  int x = 0;
  ASSERT0(x == 0, "x must be 0!");
  int y = 1;
  ASSERT1(y == 1, "y must be 1!"); // is disabled
  int z = 2;
  ASSERT2(z == 2, "z must be 2!"); // is disabled
  return 0;
}
\end{cppcode}
Так же можно сделать \verb"assert"-ы не по уровням, а по управляемому макросу.
Например, вы хотите сделать проверки для конкретного класса или для конкретного модуля в коде.
\begin{cppcode}
// file my_assert.h
#include <cassert>

#ifndef DISALBE_MY_ASSERT
#define MY_ASSERT(expr, msg) assert(expr && msg)
#else
#define MY_ASSERT() ((void)0)
#endif
\end{cppcode}
Тогда используется это так
\begin{cppcode}
#include "my_assert"

int main() {
  int x = 1;
  MY_ASSERT(x == 1, "x must be 1!");
  int y = 2;
  ASSERT0(y == 2, "y must be 2!");
  return 0;
}
\end{cppcode}
И для отключения нужно добавить макрос отключения
\begin{cppcode}
#define DISALBE_MY_ASSERT
#include "my_assert.h"

int main() {
  int x = 1;
  MY_ASSERT(x == 1, "x must be 1!"); // is disabled
  int y = 2;
  ASSERT0(y == 2, "y must be 2!");
  return 0;
}
\end{cppcode}
Так же можно сделать свитч между тремя опциями: \verb"assert", исключение или ничего.
Например так
\begin{cppcode}
// file my_check.h
#include <cassert>
#include <exception>

#ifdef MYASSERT
#define MyCheck(expr, msg) assert(expr && msg)
#else
#ifdef MYEXCEPT
#define MyCheck(expr, msg)       \
  if (!expr)                     \
  throw std::runtime_error(msg)
#else
#define MyCheck(expr, msg) ((void)0)
#endif
#endif
\end{cppcode}
Теперь этот код можно использовать в трех случаях:
\begin{center}
\begin{tabular}{lll}
{
\begin{minipage}[\baselineskip]{5cm}
Без проверок
\begin{cppcode}[numbers = none]

#include "my_check.h"

int main() {
  int x = 1;
  MyCheck(x == 1, "Ups!");
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{5cm}
Проверка через \verb"assert"
\begin{cppcode}[numbers = none]
#define MYASSERT
#include "my_check.h"

int main() {
  int x = 1;
  MyCheck(x == 1, "Ups!");
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{5cm}
Бросаем исключение
\begin{cppcode}[numbers = none]
#define MYEXCEPT
#include "my_check.h"

int main() {
  int x = 1;
  MyCheck(x == 1, "Ups!");
}
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}

\subsubsection{Exceptions}

Если вы хотите проверять ошибки программиста с помощью исключений, то вам надо валить вашу программу соответствующим исключением.
То есть надо кидать исключение и не перехватывать его.
Тогда в режиме дебага вы сразу увидите текущее состояние стека вызова и состояние программы в памяти при исполнении.
Наличие стека вызовов позволит лучше понять происхождение ошибки.
Однако при таком подходе вам не доступна информация лежащая в самом исключении.

Так же не пытайтесь такие ошибки обрабатывать в блоках \verb"catch".
Иначе вы получите управление логикой программы с помощью исключений.
Лучше завести какой-то служебный класс для таких ошибок и в перехватчике исключений его выбрасывать из программы.
Например так (см. также самый конец раздела~\ref{section::MVCExample2}):
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
// file react.h
struct Die {};
void react();

// file react.cpp
void react() {
  try {
    throw;
  } catch (std::exception& e) {
    /*react to standard exception*/
  } catch (Die& die) {
    throw; // rethrow die exception
  } catch (...) {
    /*react to unknown exception*/
  }
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
#include "react.h"

namespace {
void f() {
  throw Die{};
}
}

int main() {
  try {
    f();
  } catch(...) {
    react();
  }
  return 0;
}
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}
Обычно дебагер позволит вам не только увидеть стек вызовов, но и прыгнуть в строчку кода, где возникло исключение.
Так же из плюсов вы увидите текущее состояние всех переменных на стеке.

\subsection{Ошибки исполнения среды}

Ошибки исполнения среды -- это ошибки, которые возникают не из-за багов в программе, а из-за того, что есть какие-то внешние проблемы.
В основном это проблемы с получением доступа к ресурсу среды.
Вот примеры таких ошибок:
\begin{enumerate}
\item Memory Corruption.
Нарушение целостности памяти.
Это фатальная ошибка, с которой не возможно бороться и нет смысла бороться.
Тем не менее, это ошибка исполнения среды.

\item Невозможно открыть файл на чтение или запись.
Это по сути отсутствие доступа к ресурсу.
Такие ошибки могут быть как фатальными (без этого файла не возможно исполнение), так и не фатальными (вы знаете, что делать и можете работать дальше, без доступа к этому файлу).

\item Нет запрашиваемого устройства.
Это по сути отсутствие доступа к ресурсу.
Такая ошибка может быть как фатальной, так и не фатально.
Все зависит от вашего приложения и устройства.

\item Процессор не поддерживает нужный вид инструкций.
Это тоже по сути доступ к ресурсу.
Вы не можете получить доступ к операциям на процессоре.
Обычно это не фатальная проблема, вы просто откатываетесь к имплементации, которая не использует недоступные операции.

\item Ошибка при парсинге файла.
Вам предоставили не корректный ресурс.
\end{enumerate}
Ошибки связанные с целостностью памяти мы просто игнорируем.
Если вашей системе битая память, то вам надо менять железо, а не латать программу.
Конечно мы можем поговорить на тему <<программируй как NASA>>, но все же это слишком специальный случай.

Ошибки при исполнении можно классифицировать следующим образом:
\begin{enumerate}
\item Фатальная ошибка, которая вызывает завершение процесса по \verb"std::terminate"

\item Фатальная ошибка, которая вызывает перезапуск event loop на процессе, но сам процесс не умирает.

\item Локальная ошибка при исполнении, например нет доступа к файлу или некорректное содержимое файла.
\end{enumerate}
Под первые два вида ошибок хорошо подходят исключения, потому что они позволяют быстро умереть или быстро подняться по стеку (при этом параллельно накапливая информацию об ошибках и/или логируя их).
Последний подход плохо решается исключениями.
Если их решать исключениями, то вы начнете управлять control flow с помощью исключений, а это ошибка дизайна.
Ошибки третьего типа лучше решать через Error Codes или \verb"std::expected", в особенности если расстояние между бросающим и ловящим исключение кодом на стеке вызовов маленькое.
Тем не менее, многие сторонние библиотеки по умолчанию обрабатывают локальные ошибки с помощью исключений.
Один из таких примеров и что с ним делать можно глянуть ниже~\ref{item::example::ExceptionDie}.
Потому для использования методов из таких библиотек, к ним приходится писать обертки, которые перехватывают исключения и на выходе используют Error Codes или \verb"std::excpected".
О том, как писать такие обертки можно посмотреть ниже в примере~\ref{item::example::ExceptionLive}.

\subsubsection{Error Codes}

Большая часть ошибок может быть обработана здесь и сейчас во время вызова функции.
Например, если вы пытаетесь открыть файл на чтение, а файла нет, то вы просто принимаете решение сообщить об этом пользователю и продолжать работать.
У вас нет необходимости посылать эту ошибку куда-то далеко по стеку вызовов.
Или если вы опрашиваете наличие видеокарты, чтобы понять можно ли ее использовать для вычислений.
Если вам приходит ответ, что ее нет, то вы просто запоминаете это и не используете видеокарту.
Нет необходимости добираться до \verb"main" раскручивая стек вызовов полностью.
Для таких ошибок еще в Си используют Error Codes.

Давайте посмотрим как это работает.
Пусть у вас есть функция
\begin{cppcode}
void func(int a, const B& b);
\end{cppcode}
и вы хотите сообщить об ошибке из нее.
Для этого надо понять какие могут быть все виды ошибок, которые могут произойти.
Для этого заводим \verb"enum class", содержащий статус операции после вызова функции.
Статус возвращается через \verb"return".
\begin{cppcode}
enum class Status {
  OK, Fatal, Error, Ingored, Pending
};

Status func(int a, const B& b);
\end{cppcode}
Теперь вы можете проверять наличие ошибок так
\begin{cppcode}
Status status = func(1, B{});
if (status != Status::OK) {
  /*handle an error*/
}
\end{cppcode}
Что делать, если функция возвращает данные через \verb"return"?
В этом случае надо сделать выходные аргументы (см. раздел~\ref{section::Explicitness} часть <<Аргументы ссылки>>).
Например, если функция имеет вид
\begin{cppcode}
struct Result {
  std::string description;
  int operations = 0;
};

Result func(int a, const B& b);

int main() {
  ...
  Result result = func(1, B{});
  ...
}
\end{cppcode}
Мы переделаем функцию в
\begin{cppcode}
Status func(int a, const B& b, Result* result);

int main() {
  ...
  Result result;
  Status status = func(1, B{}, &result);
  ...
}
\end{cppcode}
Главный недостаток такого подхода в том, что если \verb"Result" не является default constructible, то есть его нельзя построить неинициализированным, то вы не сможете просто так создать <<пустой>> \verb"result" и потом заполнить его данными.
В языке Си конечно же есть только структуры и там такой проблемы не бывает.
В C++ же проблемы все таки есть.
Многие Сишные библиотеки используют такой подход.
В операционной системе Windows функции используют такой подход.

\subsubsection{\texttt{std::expected} и \texttt{std::optional}}

Данный подход вертится вокруг идеи про Error Codes.
Мы не хотим использовать out аргументы у функции.
В этом случае мы хотим иметь возможность сообщать об ошибке и инициализировать данные, которые не default constructible.
В любом случае данные должны быть хотя бы movable.
Если у вас есть хрупкий класс, то его всегда можно сделать movable, если завернуть его имплементацию в \verb"unique_ptr" (стоит поглядеть в~\ref{section::fragile}).
Главная идея в том, что теперь по \verb"return" мы можем вернуть и данные и ошибку.

\paragraph{Простой пример}

Самый простой вариант -- ошибка не содержит никакой информации.
В этом случае можно использовать \verb"std::optional".
Пусть для примера вам нужно прочитать файл.
При этом нет гарантии, что файл, который вы читаете вообще существует.
Давайте предположим, что у вас есть функция, которая пытается прочесть данные из файла.
Пусть функция имеет следующую сигнатуру:
\begin{cppcode}
Data read_from_file(const std::filesystem::path& name) ;
\end{cppcode}
То есть она всегда по \verb"return" возвращает данные.
Что тогда должна делать эта функция, когда данных нет (например из-за отсутствия файла или ошибки чтения)?
Она должна бросить исключение.
В этом случае использование функции становится неудобным, приходится писать
\begin{cppcode}
Data data;
try {
  data = read_from_file(file_name);
} catch (...) {
  /*react to the error*/
}
\end{cppcode}
И к сожалению это не работает, если \verb"Data" не deafult constructible.
Так как логически такая функция возвращает либо данные либо ошибку, что данных нет, то можно вернуть \verb"std::optional<Data>".
\begin{cppcode}
std::optional<Data> readFromFile(const std::filesystem::path& name) {
  try {
    return read_from_file(name);
  } catch (...) {
    return std::nullopt;
  }
}
\end{cppcode}
В этом случае проверка на стороне пользователя выглядит как-то так
\begin{cppcode}
auto data = readFromFile(file_name);
if (data.has_value()) {
  use_data(*data);
} else {
  /*react to the error*/
}
\end{cppcode}
Обратите внимание, что мы не переписываем существующую функцию для чтения из файла (у нас может не быть такой опции, если это сторонняя функция).

\paragraph{Чуть менее простой пример}

В этом примере мы считаем, что ошибка может содержать какие-то данные.
По сути нам нужен тип \verb"std::variant", который умеет хранить два типа: тип данных и тип ошибки.
Только при этом мы хотим эти типы трактовать по разному.
Тип \verb"std::expected" по сути и является частным случаем \verb"std::variant", с подправленным интерфейсом.
Начнем с примера
\begin{cppcode}
struct Data { ... };
struct Error { ... };

using ExpectedData = std::expected<Data, Error>;
\end{cppcode}
Теперь функция возвращающая ошибку может выглядеть так
\begin{cppcode}
ExpectData parse_file(const std::filesystem::path &name);
\end{cppcode}
В этом случае мы можем не просто узнать, что была ошибка, но и узнать детали об ошибке:
\begin{cppcode}
auto data = parse_file(file_name);
if (!data.has_value()) {
  /* deal with data.error()*/
  return;
}
use_data(*data);
\end{cppcode}
В данном случае есть не симметрия.
Мы ожидаем, что ошибки это редкость, потому по умолчанию по оператору \verb"operator*" из \verb"std::expected" вынимаются данные.
В такой парадигме бывает два вида функций:
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
Без ошибок
\begin{cppcode}[numbers = none]
R function1(const A&);
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
С ошибками
\begin{cppcode}[numbers = none]
std::expected<R, E> function2(const A&);
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}
Функции первого типа -- это функции, которые всегда могут любой вход типа \verb"A" переработать в выход типа \verb"R".
Функции второго типа не всегда могут отработать и на каких-то входах дают ошибки.
Потому функции второго типа могут вернуть либо тип \verb"R" в случае успеха, либо тип \verb"E" в случае ошибки.

\paragraph{Компонирование}

Теперь нужно научиться компонировать функции.
Если у нас только функции, которые не могут совершать ошибки, то в этом нет ничего сложного, это делается на уровне языка композицией:
\begin{cppcode}
B function1(const A&);
C function2(const B&);

C c = function2(function1(a));
\end{cppcode}
Однако, если мы хотим работать с ошибками, то у нас периодически будут появляться типы вида \verb"std::expected".
Давайте обсудим какие есть опции.
\begin{enumerate}
\item \verb"transform".
В данном случае мы хотим выполнить операцию над содержимым \verb"std::expected".
В этом случае сигнатура функции следующая
\begin{cppcode}
R function(const A&);
\end{cppcode}
И нам дано
\begin{cppcode}
std::expected<A, E> data;
\end{cppcode}
Если внутри \verb"data" лежит объект типа \verb"A" мы хотим применить к нему функцию \verb"function" и запаковать результат в \verb"std::expected<R, E>".
Если же внутри \verb"data" лежит ошибка типа \verb"E", то мы хотим не трогать ее и вернуть \verb"std::expected<R, E>" инициализированную ошибкой из \verb"data".
Ясно что эту операцию можно сделать руками следующим образом:
\begin{cppcode}
std::expected<R, E> result;
if (data.has_value()) {
  result = function(*data);
} else {
  result = data.error();
}
\end{cppcode}
Эти действия делаются автоматически с помощью метода \verb"transform".
\begin{cppcode}
std::expected<R, E> result = data.transform(function);
\end{cppcode}
То есть \verb"transform" умеет применять к данным любую функцию, которая не совершает ошибок.

\item \verb"and_then".
В этом случае мы тоже хотим применить к данным функцию, но только теперь функция может ошибаться, то есть сигнатура функции теперь такая
\begin{cppcode}
std::expected<R, E> function(const A&);
\end{cppcode}
При этом данные нам даны в следующем виде
\begin{cppcode}
std::expected<A, E> data;
\end{cppcode}
Мы ожидаем следующее поведение:
\begin{enumerate}
\item Если внутри \verb"data" лежат данные, то мы применяем к ним \verb"function" и возвращаем этот результат.

\item Если внутри \verb"data" лежит ошибка, то мы возвращаем \verb"std::expected<R, E>" инициализированный ошибкой из \verb"data".
\end{enumerate}
Обратите внимание, что тип ошибки должен быть единый как для данных, так и для функции.
Ясно, что можно реализовать такое поведение руками следующим образом
\begin{cppcode}
std::expected<R, E> result;
if (data.has_value()) {
  result = function(*data);
} else {
  result = std::unexpected(data.error());
}
\end{cppcode}
Такая операция автоматически делается с помощью \verb"and_then" так:
\begin{cppcode}
std::expected<R, E> result = data.and_then(function);
\end{cppcode}
Таким образом \verb"and_then" умеет применять к данным с ошибкой любую функцию, которая может совершить ошибку того же типа.
\end{enumerate}

\subsubsection{Exceptions}

\paragraph{Зачем?}

Прежде всего давайте поймем зачем нам в принципе в языке нужны исключения.
Казалось бы можно использовать коды с ошибками или даже \verb"std::expected".
Однако, есть два случая, когда вы не можете воспользоваться этими механизмами.
\begin{enumerate}
\item Конструкторы.
Давайте начнем с примера кода
\begin{cppcode}
class A {
public:
  A() = default;
  A(int x) : x_(x) {}
private:
  int x_ = 0;
};

int main() {
  A a;
  A b(4);
  return 0;
}
\end{cppcode}
Как мы видим в строчках~10 и~11, в синтаксисе использования конструкторов у нас нет возможности вернуть код ошибки.
Потому что конструктор должен вернуть сконструированный объект.
Точнее, это не совсем правда.
Технически устроены конструкторы объявленные в строчках~3 и~4 можно представлять себе так
\begin{cppcode}
class A {
public:
  static void ctor(A* this) = default;
  static void ctor(A* this, int x);
private:
  int x_ = 0;
};
\end{cppcode}
Так вот, конструктор получает указатель на адрес, где надо создать объект и возвращает \verb"void".
Техническую часть можно было бы изменить, но синтаксически не понятно, как это выразить.
Как в строчках~10 и~11 написать что-то, чтобы вернуть сообщение об ошибке?
Думаю тут можно было бы придумать особый синтаксис, но что если вы используете вложенные конструкторы или напрямую используете их как аргументы функции
\begin{cppcode}
function(A(), B(A(), 5), C{1, 2});
\end{cppcode}
Кто и куда тут должен возвращать ошибку?
Тут вызывается $4$ конструктора.
Как такое должно сообщать об ошибке?

\item Операторы.
Давайте посмотрим на следующий код
\begin{cppcode}
class A {
public:
  friend operator+(const A& first, const A& second);
private:
  ...
};

int main() {
  A a, b, c;
  std::cin >> a >> b;
  c = a / b;
  std::cout << c << '\n';
  return 0;
}
\end{cppcode}
В строчке~11 вызывается оператор деления.
Что если разделить на \verb"b" нельзя?
Куда сообщить об ошибке?
И опять, можно было бы придумать разные синтаксисы, но подумайте, как вы это будете применять, если у вас большое сложное арифметическое выражение.
Кроме того, тут еще есть два оператор \verb"operator>>" и \verb"operator<<" для потокового ввода вывода.
Они тоже не имеют возможности вернуть код ошибки.
Тем не менее, даже потоковые операторы для \verb"std::out" и \verb"std::cin" имеют альтернативный механизм, в рамках которого устанавливаются биты ошибок в специальном глобальном объекте.
\end{enumerate}

\paragraph{Как это работает}

Давайте посмотрим на следующий пример:
\begin{cppcode}
void g() {
  throw std::runtime_error("Ups!");
}

void f() {
  /*some work*/
  g();
  /*some work*/
}

int main() {
  try {
    f();
  } catch(std::exception& e) {
    std::cout << "Error: " << e.what() << '\n';
  } catch(...) {
    std::cout << "Unknown exception!\n";
  }
}
\end{cppcode}
Давайте опишу работу кода по строкам.
Точка входа в программу -- функция \verb"main", потому начинаем с нее.
\begin{enumerate}
\item Исполнение начинается в строке~13.
Тут вызывается функция \verb"f".
Так как мы ожидаем, что она кидает исключения, оборачиваем это в блок \verb"try", чтобы его можно было поймать.

\item Далее выполняется код в строке~6 (тут может быть много кода).

\item После этого в строке~7 вызывается функция \verb"g".

\item Управление переходит к функции \verb"g" и выполняется строчка~2.
В этой строчке бросается исключение.
В этом месте мы вываливаемся из функции \verb"g" в строчку~7 внутри функции \verb"f".

\item В строчке~7 после исключения мы должны выйти из функции \verb"f" и будем так выходить до тех пор, пока не встретим \verb"catch", который поймает исключение.
Но чтобы выйти мы должны почистить стек от функции \verb"f".
Это называется stack unwinding.
Надо удалить все локальные переменные и аргументы функции \verb"f".
Для этого после строчки 7 вызываются деструкторы всех локальных переменных на стеке, которые создала функция \verb"f".

\item Почистив стек мы выходим в больший scope из которого вызвана \verb"f".
В данном случае это строка~13.
Так как мы вышли в блок \verb"try", то мы ловим исключение и для реакции на него нужны следующие блоки \verb"catch".

\item Мы идем по блокам \verb"catch" один за одним и смотрим, есть ли хотя бы один блок, под который подходит наше исключение.
В данном случае исключение типа \verb"std::runtime_error" унаследовано от \verb"std::exception" и так как мы принимаем исключение по ссылке, то включается полиморфизм и мы можем поймать это исключение в первом блоке.
Если бы было несколько подходящих блоков, то исключение ловится первым, а остальные не реагируют.
Если нет ни одного блока, который может поймать исключение, то оно улетает дальше из текущего scope.
\end{enumerate}
Таким образом, если вы работаете с исключениями, то вообще говоря, вы можете выйти из любого scope в любой точке функции.

\subsubsection{Гарантии поведения при исключениях}

Предположим, мы выполняем следующий код
\begin{cppcode}
Data d = ...;
Result r;
try {
  r = algorithm(d);
} catch(...) {
}
\end{cppcode}
Вопрос, если во время выполнения алгоритма было брошено исключение, то в каком состоянии находятся \verb"d" и \verb"r"?
Если \verb"d" принимается по константной ссылке, то оно гарантировано не меняется, потому нас скорее всего интересует состояние объекта \verb"r".
Бывает три вида гарантий:
\begin{enumerate}
\item Strong Exception Guaranty.
В этом случае все объекты находятся в состоянии в каком они были до вызова функции бросающей исключение.

\item Basic Exceptioni Guaranty.
В этом случае все объекты находятся в корректном состоянии, но неизвестно в каком.
Объектами можно пользоваться, но конкретное состояние не известно и скорее всего не представляет интереса.

\item No Exception Guaranty.
Никаких гарантий.
Например, у \verb"r" из примера выше могут быть нарушены инварианты класса.
\end{enumerate}
Когда вы пишите код, то важно его писать так, чтобы выполнялись Basic Exception Guaranty.
Это должно быть опцией по умолчанию.
Хорошо было бы иметь Strong Exception Guaranty, но это может оказаться дорого.
Последняя опция допустима только при отключенных исключениях.
Однако, даже если вы не используете исключения, если вы пишите код с соблюдением Basic Exception Guaranty, то под получается лучше.
Связано это с тем, что у вас появляются ограничения, которые направляют написание кода в лучшую сторону.

\subsubsection{Технические детали и логическая модель для исключений}

\paragraph{Технические детали, которые надо знать}
\label{section::ExceptionTechLogic}

Прежде чем обсуждать какие есть сложности при использовании исключений, давайте обсудим технические детали связанные с имплементацией.
Когда вы кидаете исключения надо помнить о следующем:
\begin{enumerate}
\item Как аллоцируется память для исключения в стандарте не определено.
На практике это означает, что вы всегда аллоцируете память на куче даже для стандартных типов вроде \verb"int".

\item Для того, чтобы произвести stack unwinding вам нужно для каждой точки программы знать, какие деструкторы позвать.
Как это должно делаться в стандартне не определено, но на практике есть два способа:
\begin{enumerate}
\item Frame-based.
Данный метод по сути поддерживает в run-time второй стэк, на который складываются деструкторы объектов для текущего scope.
Этот метод означает, что вы платите за исключения даже, когда их не кидаете.
Этот подход использует компилятор от Microsoft.

\item Table-based.
В данном подходе, во время компиляции программы, вы составляете таблицы для вызова нужных деструкторов из каждой точки вашего кода.
И в run-time используете эти таблицу для их вызова.
Такой подход очень сильно раздувает бинарники программы, потому что нужно хранить все эти таблицы.
Такой подход используют gcc и clang.
\end{enumerate}
\end{enumerate}
Когда мы ловим исключения надо понимать следующее:
\begin{enumerate}
\item Язык предоставляет полиморфное поведение.
То есть если вы унаследовали класс \verb"A" от класса \verb"B", то по ссылке на \verb"B" можно ловить и исключение класса \verb"A".
В стандарте не прописано как это должно быть имплементировано, но на практике всегда используется RTTI, что дорого.

\item Деаллокация памяти для исключения не специфицирована в стандарте.
На практике это значит удаление объекта с кучи и это дорого.
\end{enumerate}

\paragraph{Возможные состояния}

Здесь я хочу немного поговорить про ментальную модель для исключений и в каких состояниях может находиться ваша программа логически.
Давайте начнем с картинки:
\[
\xymatrix@R=15pt@C=15pt{
  {\text{try}}
 	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{\text{uncpecified storage}}
   	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  \\
  {\text{code throws}}\ar@/^10pt/[rr]
       	{
	\save
   [].[]*[F--]\frm{}
   \restore
	}
  &{}&{\text{exception}}\ar@/^10pt/[ddll]
   	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  \\
  {\text{catch}}
   	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{}\\
  {\text{code reacts}}
     	{
	\save
   [].[]*[F--]\frm{}
   \restore
	}
  &{}&{}\\
}
\]
Думаю, что данная диаграмма более или менее не требует объяснений.
Процесс бросания исключений в штатном режиме можно представлять себе так:
\begin{center}
\resetgitem
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\gitem Исполнение в блоке \verb"try"
\[
\xymatrix@R=15pt@C=15pt{
  {\text{try}}
 	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{\text{uncpecified storage}}
   	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  \\
  {\text{code throws}}
  %\ar@/^10pt/[rr]
       	{
	\save
   [].[]*[F--]\frm{}
   \restore
	}
  &{}&{\phantom{\text{exception}}}
  %\ar@/^10pt/[ddll]
   	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  \\
  {\text{catch}}
   	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{}\\
  {\text{code reacts}}
     	{
	\save
   [].[]*[F--]\frm{}
   \restore
	}
  &{}&{}\\
}
\]
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\gitem  Бросаем исключение
\[
\xymatrix@R=15pt@C=15pt{
  {\text{try}}
 	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{\text{uncpecified storage}}
   	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  \\
  {\text{code throws}}\ar@/^10pt/[rr]
       	{
	\save
   [].[]*[F--]\frm{}
   \restore
	}
  &{}&{\text{exception}}
  %\ar@/^10pt/[ddll]
   	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  \\
  {\text{catch}}
   	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{}\\
  {\text{code reacts}}
     	{
	\save
   [].[]*[F--]\frm{}
   \restore
	}
  &{}&{}\\
}
\]
\end{minipage}
}\\\noalign{\medskip}
{
\begin{minipage}[\baselineskip]{8cm}
\gitem Перехватываем исключение в \verb"catch"
\[
\xymatrix@R=15pt@C=15pt{
  {\text{try}}
 	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{\text{uncpecified storage}}
   	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  \\
  {\text{code throws}}
  %\ar@/^10pt/[rr]
       	{
	\save
   [].[]*[F--]\frm{}
   \restore
	}
  &{}&{\phantom{\text{exception}}}
  \ar@/^10pt/[ddll]
   	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  \\
  {\text{catch}}
   	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{}\\
  {\text{code reacts}}
     	{
	\save
   [].[]*[F--]\frm{}
   \restore
	}
  &{}&{}\\
}
\]
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\end{minipage}
}\\
\end{tabular}
\end{center}
Давайте проговорим, что тут происходит:
\begin{enumerate}
\item Начинаем исполнение программы в блоке \verb"try".

\item Код в блоке \verb"try" бросает исключение.
В этот момент объект исключения аллоцируется неспецифицированным образом.

\item Как только исключение долетело до блока \verb"try", для него ищется нужный обработчик среди присоединенных \verb"catch" блоков.
Если нужный обработчик нашелся, то мы вынимаем объект исключения оттуда, где он хранился и отдаем его в распоряжение \verb"catch" блока.
В конце обработки \verb"catch" блок сам удалит объект исключения, вам не надо об этом заботиться.
В этом случае исключение логически не в брошенном состоянии, а в пойманном.
И система помнит это исключение.
Его можно перебросить по команде \verb"throw" без аргументов.
\end{enumerate}

\paragraph{Проблемы}

А теперь поговорим, что в этой схеме может пойти не так.
\begin{enumerate}
\item Вы можете кинуть исключение, когда другое исключение все еще висит не обработанное.
Такое возможно, если вы бросите исключение во время stack unwinding.
По этой причине нельзя кидать исключения в деструкторах.
\[
\xymatrix@R=15pt@C=40pt{
  {\text{try}}
 	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{\text{uncpecified storage}}
   	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  \\
  {\text{code throws}}\ar@/^10pt/[rr]^{\boxed{\text{exception}}}
       	{
	\save
   [].[]*[F--]\frm{}
   \restore
	}
  &{}&{\text{exception}}%\ar@/^10pt/[ddll]
   	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  \\
  {\text{catch}}
   	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{}\\
  {\text{code reacts}}
     	{
	\save
   [].[]*[F--]\frm{}
   \restore
	}
  &{}&{}\\
}
\]
В этом случае программа падает по \verb"std::terminate".

\item Если не нашлось ни одного обработчика среди \verb"catch" блоков.
\[
\xymatrix@R=15pt@C=15pt{
  {\text{try}}
 	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{\text{uncpecified storage}}
   	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  \\
  {\text{code throws}}
       	{
	\save
   [].[]*[F--]\frm{}
   \restore
	}
  &{}&{\text{exception}}\ar[dd]
   	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  \\
  {\text{catch}}
   	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{}\\
  {\text{code reacts}}
     	{
	\save
   [].[]*[F--]\frm{}
   \restore
	}
  &{}&{\texttt{std::terminate}}\\
}
\]
При этом был ли почищен стэк с помощью stack unwinding не специфицировано.

\item Исключение брошено не внутри блока \verb"try".
В этом случае мы никогда не найдем соответствующий перехватчик для исключения.
И мы опять падаем по \verb"std::terminate".
\[
\xymatrix@R=15pt@C=15pt{
  {\phantom{\text{try}}}
% 	{
%	\save
%   [].[d]*+[F-:<3pt>]\frm{}
%   \restore
%	}
  &{}&{\text{uncpecified storage}}
   	{
	\save
   [].[d]*+[F-:<3pt>]\frm{}
   \restore
	}
  \\
  {\text{code throws}}\ar@/^10pt/[rr]
       	{
	\save
   [].[]*[F--]\frm{}
   \restore
	}
  &{}&{\text{exception}}\ar[dd]
   	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  \\
  {\phantom{\text{catch}}}
%   	{
%	\save
%   [].[d]*+[F-:<3pt>]\frm{}
%   \restore
%	}
  &{}&{}\\
  {\phantom{\text{code reacts}}}
%     	{
%	\save
%   [].[]*[F--]\frm{}
%   \restore
%	}
  &{}&{\texttt{std::terminate}}\\
}
\]
\end{enumerate}

\subsubsection{Важные примеры и ожидаемое поведение для исключений}

\begin{enumerate}
\item Самый первый пример, который обычно приводя -- выделение памяти.
Например, вы пытаетесь выделить память под \verb"std::vector" и ее не хватило.
Это плохой пример для использования исключений по следующим причинам:
\begin{enumerate}
\item Если вы запросили память и ее больше в системе нет, то что вы собираетесь делать?
Скорее всего у вашей системы проблемы покруче, чем невозможность продолжить работать вашей программы.
Смысла тут делать что-то нет.

\item Память запрашивает чуть ли не каждый кусок кода в любой библиотеке.
Тогда придется проверять на исключение каждое обращение к оператору выделения памяти.
В таком случае программа только и будет делать, что проверять исключения и ничего больше.
Это очень глупо.
\end{enumerate}

\item
\label{item::example::ExceptionDie}
Разумный пример, чтобы умереть.
Скажем, вы хотите работать в программе с клавиатурой через какой-нибудь интерфейс операционной системы.
Делаете запрос, на доступ к этому интерфейсу, а операционная система говорит, что нельзя и не дает доступ.
\begin{cppcode}
auto handle = access_keyboard(...);
if (!handle) {
  // cannot access the keyboard
}
\end{cppcode}
То есть системная функция вернула ошибку и вы не можете даже начать выполнение программы в таком случае.
Вот такую ситуацию как раз надо ловить исключением.
И политика тут такая, если все получилось, то хорошо, если не удалось получить доступ, то сообщаем пользователю, что у нас проблемы с доступом и завершаем работу.
Обычно за получение доступа к клавиатуре у вас будет отвечать специальный объект.
И доступ к клавиатуре вы запросите в его конструкторе.
\begin{cppcode}
class Keyboard {
public:
  Keyboard() {
    auto handle = access_keyboard(...);
    if (!handle)
      throw std::runtime_error("Cannot access the keyboard!");
  }
private:
  ...
};
\end{cppcode}
При этом для приличия такое исключение надо поймать в \verb"main", чтобы не падать по \verb"std::terminate".

\item Разумный пример, чтобы умереть и воскреснуть.
Предположим у вас в потоке крутится сервис, который может упасть в результате любой ошибки и вы хотите этот сервис перезапустить.
Код для сервиса может выглядеть как-то так:
\begin{cppcode}
int main() {
  Server server;
  server.run();
  return 0;
}
\end{cppcode}
Если метод \verb"run" бросает исключение, то можно сделать следующее:
\begin{cppcode}
int main() {
  for (Status status = Running; status != Quit;) {
    try {
      Server server;
      status = server.run(); // if returns normally sets status to be Quit
    } catch(...) {
      /*log the error*/
    }
  }
  return 0;
}
\end{cppcode}
В этом случае мы крутимся в бесконечном цикле, пока флаг \verb"status" не имеет значение \verb"Quit".
Если сервер заканчивает работу в штатном режиме, то метод \verb"run" устанавливает \verb"status" в состояние \verb"Quit" и так мы понимаем, что надо выйти из цикла.
Если же конструктор \verb"server" или метод \verb"run" умирают по исключению, то мы логируем ошибку и пытаемся еще раз инициализировать \verb"server" и запустить его.
В таком методе полезно еще установить границу максимального количества перезапусков сервера и максимальную частоту перезапусков.

\item
\label{item::example::ExceptionLive}
Разумный пример для продолжения работы.
Предположим, что вы парсите файл какого-то сложного формата.
И в рамках этого парсинга вы вызываете много вспомогательных функций.
И если возникла проблема с парсингом, то это значит, что файл прочитать нельзя, формат не верный и вы хотите быстро выйти наверх в самую старшую функцию.
\begin{cppcode}
Object parse(std::filesystem::path name) {
  File file = open_file(name);
  auto header = parse_header(file);
  auto data = parse_data(file);
  return Object(data);
}

auto parse_data(File& file) {
  ...
  parse_something(file);
  ...
  return ...;
}

auto  parse_something(File& file) {
  ...
  if (error occure)
    throw std::runtime_error("parsing error in parse_something!");
  return ...;
}
\end{cppcode}
Только теперь надо обработать эту ошибку грамотно
\begin{cppcode}
std::optional<Object> try_parse(std::filesystem::path name) noexcept {
  try {
    return parse_impl(name);
  } catch (...) {
    return std::nullopt
  }
}

Object parse(std::filesystem::path name) {
  File file = open_file(name);
  auto header = parse_header(file);
  auto data = parse_data(file);
  return Object(data);
}
\end{cppcode}
Причем мы это делаем неинтрузивно, то есть без вмешательства в имплементацию старой функции.
Обратите внимание, что старая функция всегда возвращает объект нужного типа \verb"Object", но об ошибках она сообщает с помощью исключений, которые надо ловить снаружи.
Это может быть не удобно, так как засоряет ваш код.
Вы не хотите управлять логикой программы с помощью исключений.
Для этого мы оборачиваем старую имплементацию в новую.
Новая имплементация уже не может кидать исключения, и об ошибке она сообщает уже через возвращаемое значение.
Я использовал \verb"std::optional", но можно и лучше использовать \verb"std::expected".
В таком случае вы просто пытаетесь распарсить файл и если была ошибка возвращаете пустоту, а если не было ошибки, то возвращаете данные.
После использования этой функции надо просто проверить удалось ли считать данные или нет.
И если удалось, то надо вынуть их.
Давайте сравним два обработчика:
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
try {
  Object obj = parse(file_name);
  run_program(obj);
} catch (std::exception& e) {
  print_error(e.what());
} catch(...) {
  print_error("Unknown error!");
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
std::optional<Object> obj =
                   try_parse(file_name);

if (!obj.has_value()) {
  print_error("Cannot parse file_name");
  return 0;
}
run_program(*obj);
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Обратите внимание как проще выглядит workflow во втором случае.
Во втором подходе, если вы забыли, что у вас могут быть невалидные данные после парсинга и вы попытаетесь написать такое:
\begin{cppcode}
auto obj = try_parse(file_name);
run_program(obj);
\end{cppcode}
То компилятор вам подскажет об ошибке, что вы забыли распаковать данные и передаете \verb"std::optional" вместо \verb"Object" в функцию \verb"run_program".
Однако, если в первом подходе, вы забыли поставить \verb"try/catch" блок или забыли добавить в \verb"catch" блок нужный перехватчик, то ваша программа в этом случае упадет по \verb"std::terminate" и никто вам в этом не поможет.
\end{enumerate}
Давайте я подведу итоги написанному выше.
Исключения можно использовать в двух сценариях:
\begin{enumerate}
\item На критическую ошибку, которая не позволяет продолжать работать, умереть и сообщить причину смерти пользователю.
Это был пример~\ref{item::example::ExceptionDie}.

\item На не критическую ошибку перехватить исключение и пойти по плану <<Б>> для данной ошибки.
Это был пример~\ref{item::example::ExceptionLive}.
При этом обратите внимание, что на стороне пользователя лучше иметь функцию, которая не кидает исключения, а возвращает либо объект, либо ошибку.
Потому что в этом случае попытка управления через исключения -- это ошибка дизайна.
Вы не должны управлять логикой программы с помощью исключений.
Кроме того, вам придется при каждом использовании бросающей исключения функции писать \verb"try/catch" блоки, что сделает код менее читаемым.
Лучше инкапсюлировать эту работу в другую не бросающую исключения функцию.
\end{enumerate}
Если вы используете исключения для чего-то еще, то скорее всего вы делаете что-то не так.

\subsubsection{<<Идеальная>> имплементация}
\label{section::IdealException}

Богатая иерархия наследования между исключениями -- большая головная боль.
Вы никогда не запомните (а может быть даже и не узнаете), кто от кого унаследован и унаследован ли и никогда не поставите \verb"catch" блоки в правильном порядке.
Потому система должна быть максимально простой.
Нужен обязательно один базовый класс, чтобы можно было ловить сразу все исключения, а все остальные от него унаследованы и отличаются только данными.
На уровне интерфейса я бы ожидал следующее:
\begin{cppcode}
template<class T>
class Exception {
public:
  Exception(std::string description, T data);

  const std::string& what() const;
  std::string& what();
  const std::source_location where() const;
  const std::stacktrace& stack() const;
  const T& data() const;
  T& data();
private:
  std::string description_;
  std::source_location location_;
  std::stacktrace backtrace_;
  T data_;
};
\end{cppcode}
Обратите внимание, что любое исключение содержит информацию, которую мы обсуждали в разделе~\ref{section::ErrorMsg}, а именно:
\begin{enumerate}
\item Текстовое описание ошибки.

\item Точка в коде, где ошибка произошла.

\item Текущее состояние стека.

\item Специфические данные типа \verb"T".
\end{enumerate}
В данном подходе все исключения параметризуются типом \verb"T" и для одинакового типа \verb"T" исключения не отличимы.

Заметим, что для \verb"T = void" нужно сделать специальную имплементацию, которую можно так же использовать в качестве базового класса, а именно:
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8.2cm}
\begin{cppcode}[numbers = none]
template<>
class Exception<void> {
public:
  Exception(std::string description);

  const std::string& what() const;
  std::string& what();
  const std::source_location where() const;
  const std::stacktrace& stack() const;
private:
  std::string description_;
  std::source_location location_;
  std::stacktrace backtrace_;
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8.2cm}
\begin{cppcode}[numbers = none]
template<class T>
class Exception : public Exception<void> {
public:
  Exception(std::string description, T data);





  const T& data() const;
  T& data();
private:
  T data_;
};
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Давайте обсудим некоторые важные детали.
\begin{enumerate}
\item Данные о точке кода, где произошла ошибка, и текущее состояние стека являются константными (это инвариант класса).
Они создаются в конструкторе и потом доступны только для чтения.
Поля класса не делаются константами, чтобы обеспечить хорошее поведение value semantics.

\item Строка с описанием и данные типа \verb"T" доступны для модификации.
Это нужно, если при перебрасывании исключения вам нужно добавить информацию.
Выглядит это как-то так
\begin{cppcode}
try {
  function(); // throws
} catch(Exception<void>& e) {
  e.what() += "info"; // adds extra information
  throw;
}
\end{cppcode}
Аналогично может понадобиться модификация кастомных данных типа \verb"T".

\item Перехват всех возможных исключений нашего типа делается с помощью перехвата базового класса \verb"Exception<void>", который не содержит кастомных данных.
\end{enumerate}
Таким образом логическая схема наследования получается очень простой:
\[
\xymatrix{
  {}&{\texttt{Exception<void>}}
  	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  &{}\\
  {\texttt{Exception<T1>}}\ar[ur]
    	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  &{\ldots}&{\texttt{Exception<Tk>}}\ar[ul]
    	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
\\
}
\]
Теперь приведем имплементацию классов.
В начале базовый класс.
\begin{cppcode}
template<class T>
class Exception;

template<>
class Exception<void> {
public:
  Exception(std::string description,
            std::source_location location = std::source_location::current(),
            std::stacktrace backtrace = std::stacktrace::current())
      : description_(std::move(description)), location_(std::move(location)),
        backtrace_(std::move(backtrace)) {
  }
  std::string& what() {
    return description_;
  }
  const std::string& what() const {
    return description_;
  }
  const std::source_location where() const {
    return location_;
  }
  const std::stacktrace& stack() const {
    return backtrace_;
  }
private:
  std::string description_;
  std::source_location location_;
  std::stacktrace backtrace_;
};
\end{cppcode}
Обратите внимание, что тут приходится использовать трюк из раздела~\ref{section::ErrorMsg}, чтобы правильно перехватить строку, в которой произошла ошибка и состояние стека.
Нам важно, чтобы это был не конструктор для исключения, а точка, где вызван конструктор.
Это возможно с помощью аргументов по умолчанию, потому что они конструируются в точке вызова функции (в данном случае конструктора).
Теперь классы с дополнительной информацией выглядят так:
\begin{cppcode}
template<class T>
class Exception : public Exception<void> {
  using Base = Exception<void>;

public:
  Exception(std::string description, T data,
            std::source_location location = std::source_location::current(),
            std::stacktrace backtrace = std::stacktrace::current())
      : Base(std::move(description), std::move(location), std::move(backtrace)),
        data_(std::move(data)) {
  }
  const T& data() const {
    return data_;
  }
  T& data() {
    return data_;
  }
private:
  T data_;
};
\end{cppcode}
Обратите внимание, что тут нельзя вызвать базовый конструктор с аргументами по умолчанию, потому что они покажут точку в коде -- текущий конструктор.
Потому здесь придется руками еще раз прописать аргументы по умолчанию и все аргументы передаем в базовый конструктор.

Теперь для удобства ввода вывода нужно правильно перегрузить потоковые операторы.
Для отображения места в коде, где произошла ошибка, и текущего состояния стека мы уже писали имплементацию в разделе~\ref{section::ErrorMsg}, однако, для полноты картины я их еще раз тут повторю:%
\footnote{Если вам интересно, что значит \verb"bound", то загляните в конец раздела~\ref{section::ErrorMsg}.}
\begin{cppcode}
std::ostream& operator<<(std::ostream& out, const std::source_location& location) {
  out << location.file_name() << "(" << location.line() << ":"
      << location.column() << "), function '" << location.function_name()
      << "'";
  return out;
}

std::ostream& operator<<(std::ostream& out, const std::stacktrace& backtrace) {
  static constexpr int bound = 6;
  if (backtrace.size() < bound)
    return out;
  for (auto iter = backtrace.begin(); iter != (backtrace.end() - bound); ++iter) {
    out << iter->source_file() << "(" << iter->source_line()
        << "):" << iter->description() << '\n';
  }
  return out;
}
\end{cppcode}
Теперь нужны удобные операторы для отображения исключений.
Придется написать оба по-отдельности, потому что в базовом классе отсутствует данное, которое есть в производных классах.
\begin{cppcode}
std::ostream& operator<<(std::ostream& out, const Exception<void>& e) {
  std::cout << "Failed to process: " << e.what() << '\n'
            << e.where() << '\n'
            << e.stack();
  return out;
}

template<class T>
std::ostream& operator<<(std::ostream& out, const Exception<T>& e) {
  std::cout << "Failed to process with code (" << e.data() << ") : " << e.what()
            << '\n'
            << e.where() << '\n'
            << e.stack();
  return out;
}
\end{cppcode}
Теперь этим можно пользоваться так:
\begin{cppcode}
void function() {
  throw Exception<int>("Some error!", 1);
}

int main() {
  try {
    function();
  } catch (const Exception<int>& e) {
    std::cout << e;
  } catch (const Exception<void>& e) {
    std::cout << e;
  } catch (...) {
  }
}
\end{cppcode}

\subsubsection{Рекомендации}

\paragraph{Рекомендации по использованию}

Тут я бы хотел сформулировать несколько соображений о том, как я вижу обработку исключений.
\begin{enumerate}
\item По-хорошему у вас должна быть одна точка по обработке исключений (или несколько, но не много).
Чаще всего -- это event loop в вашей программе, где вы можете сообщить об ошибке и умереть.
Или функция \verb"main", которая является последней линией обороны до выхода в операционную систему или падения по \verb"std::terminate".

\item Исключения никогда не должны быть в критической для производительности части.
Более того, рекомендуется помечать код \verb"noexcept" (даже если он кидает исключения, например на запрос памяти у системы), чтобы компилятору было дозволено больше оптимизаций.

\item Исключения не должны ни в каком виде контролировать workflow вашего кода.
За это должна отвечать логика программы.
% TO DO
% Пример
\end{enumerate}

\paragraph{Технические рекомендации}

\begin{enumerate}
\item Исключения кидаются by value.
\begin{cppcode}
throw A(1, "abc");
\end{cppcode}

\item Исключения ловятся по ссылке или константной ссылке.
Это нужно для обеспечения полиморфного поведения.
\begin{cppcode}
catch(const A& a)
\end{cppcode}

\item Повторное кидание висячего исключения делается командой \verb"throw" без аргументов.
Этот трюк используется для того, чтобы отложить реакцию на исключение.
\begin{cppcode}
void react() {
  try {
    throw;
  } catch (std::exception& e) {
    /*react to std::exception*/
  } catch (...) {
    /*react to unknown exception*/
  }
}

int main() {
  try {
    run();
  } catch(...) {
    react();
  }
}
\end{cppcode}
В этом примере, когда мы попадаем в блок \verb"catch", мы перехватили текущее исключение.
Оно больше не висит, но система знает это последнее исключение внутри блока \verb"catch".
И чтобы перекинуть его мы в функции \verb"react" используем команду \verb"throw" без аргументов в строке~3.
Однако, ее надо помещать внутри \verb"try" блока, чтобы после перекидывания, можно было поймать исключение.

\item Производные классы исключений среди \verb"catch" обработчиков должны идти перед базовыми классами, чтобы поймать наиболее специализированный тип.
\begin{cppcode}
class A {};
class B : public A {};

try {
  run();
} catch (const B& e) {
  /*reacto to B*/
} catch (const A& e) {
  /*reacto to A*/
} catch(...) {
  /*reacto to everything left*/
}
\end{cppcode}
Напомню, что блоки \verb"catch" проходятся сверху вниз по одному, и на первом подходящем блоке исключение обрабатывается и последующие \verb"catch" блоки игнорируются.
Проблема с этим подходом в том, что вы должны знать отношение наследования между классами, чтобы правильно добавлять обработчики.
Вот отличный пример
\begin{cppcode}
try {
  ...
} catch (const std::runtime_error& e) {
} catch (const std::underflow_error& e) {
} catch (const std::range_error& e) {
} catch (const std::logic_error& e) {
} catch (...) {
}
\end{cppcode}
проблема в том, что диаграмма наследования для исключений выглядит так
\[
\xymatrix@R=15pt@C=15pt{
  {}&{\texttt{std::exception}}
  	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  &{}&{}\\
  {}&{\texttt{std::runtime\_error}}\ar[u]
    	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  &{}&{\texttt{std::logic\_error}}\ar[ull]
    	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  \\
  {\texttt{std::underflow\_error}}\ar[ur]
    	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  &{}&{\texttt{std::range\_error}}\ar[ul]
    	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  &{}\\
}
\]
Это означает, что мы никогда не поймаем исключение в строках~4 и~5, потому что они унаследованы от исключения, перехватываемого в строке~3.
Помнить наизусть это все невозможно.
Иерархия на исключениях делает код хрупким.
Куда проще было бы сразу перехватывать базовый класс.
\begin{cppcode}
try {
  ...
} catch (const std::exception& e) {
} catch (...) {
}
\end{cppcode}
В идеале для работы с исключениями можно пользоваться имплементацией описанной в разделе~\ref{section::IdealException}.
\end{enumerate}

\subsubsection{Проблемы при использовании исключений}

Прежде чем вы прочитаете как жизнь с исключениями невыносима, я хочу напомнить про главную пользу исключений.
Когда вы пишите код, подразумевая, что у вас могут быть исключения, вы находитесь в рамках серьезных ограничений (пусть компилятор их на вас не накладывает, но вы должны это понимать).
А когда у вас есть серьезные ограничения, то вы всегда пишите код лучше.

\paragraph{Менеджмент ресурсов}

Так как исключение может возникнуть в любой строчке кода то это значит, что если исполнилась одна строчка кода, то у вас нет гарантии, что выполнится следующая.
Давайте посмотрим на следующий пример:
\begin{cppcode}
void g() {
  throw std::runtime_error("Ups!");
}

void f() {
  int* x = new(0);
  g();
  delete x;
}
\end{cppcode}
В этом примере при вызове \verb"f" мы выйдем из нее в строчке~7, где функция \verb"g" кинет исключение.
Потому операция \verb"delete" никогда не вызовется.
Потому когда вы используете исключения, все ресурсы должны менеджериться автоматическими методами с использованием RAII (см. раздел~\ref{section::RAII}).

\paragraph{Исключения в деструкторах}

В разделе~\ref{section::ExceptionTechLogic} мы обсудили, что нельзя бросать исключения, когда есть активное не пойманное исключение в системе.
Такое может произойти, когда мы освобождаем стек при выходе из текущего scope.
В этот момент вызываются деструкторы всех локальных переменных из данного scope.
А это означает, что ни в коем случае нельзя кидать исключения в деструкторах.
Если вы это сделаете, то программа упадет в run-time вызовом \verb"terminate".
Потому никогда не бросайте исключения в деструкторах.
Это чревато и не работает.
У вас нет шансов сообщить об ошибке в деструкторе безопасно.
Их надо обрабатывать внутри самого деструктора.
Но лучше не кидать никогда.

\paragraph{Правила инициализации объектов и несколько ресурсов}

Теперь, что делать, если вам надо выделить память для двух указателей?
Тупой вариант такой
\begin{cppcode}
struct IntPtrPair {
  IntPtrPair(int x, int y) : ptr1_(new int(x)), ptr2_(new int(y)) {}
  ~IntPtrPair() {
    delete ptr1_;
    delete ptr2_;
  }
  int* ptr1_;
  int* ptr2_;
};

IntPtrPair x(1, 2);
\end{cppcode}
Беда этого подхода вот в чем.
Когда вы в строчке 11 вызываете конструктор, то сначала выделяется память под \verb"ptr1_", а потом под \verb"ptr2_".
И если при первом вызове память выделится, а во втором нет и будет брошено исключение, то конструктор не завершит работу, а значит объект не будет считаться построенным, а значит и не вызовется деструктор для него во время stack unwinding.
А это значит, что память, выделенная первым вызовом не освободится.
Есть много костылей для этой проблемы, но правильное решение -- обернуть каждый указатель в свой wrapper.
Например так
\begin{cppcode}
struct IntPtrPair {
  IntPtrPair(int x, int y) : ptr1_(std::make_unique<int>(x)),
                             ptr2_(std::make_unique<int>(y)) {}

  std::unique_ptr<int> ptr1_;
  std::unique_ptr<int> ptr2_;
};

IntPtrPair x(1, 2);
\end{cppcode}
И теперь вам вообще не надо беспокоиться о деструкторах и прочих радостях, потому что у вас везде value semantics.
Все это за вас для каждого ресурса делает wrapper для работы с одним указателем.

\paragraph{Зависимые ресурсы и исключения}

Существует еще одна ситуация, о которой стоит рассказать.
А что если у нас данные зависимы?
Например, я должен сначала выделить память под \verb"x", а потом выделяя память под \verb"y", я должен туда положить информацию про \verb"x"?
То есть у вас есть естественная зависимость порядка конструирования данных.
Мы уже обсуждали, что для конструирования по частям как раз и создано наследование в разделе~\ref{section::Composition}.
Оно собирает объект в определенном порядке.
Давайте приведу такой пример
\begin{cppcode}
struct A {
  A(int x) : ptr_(std::make_unique<int>(x)) {}
  
  std::unique_ptr<int> ptr_;
};

struct B : A {
  A(int x) : A(x), ptr_(std::make_unique<int*>(A::ptr_.get()) {}
     
   std::unique_ptr<int*> ptr_;
};

B x(1);
\end{cppcode}
В таком случае у вас в строчке 13 сначала создается базовая часть объекта, то есть выделяется память под \verb"x" и кладется адрес в \verb"A::ptr_".
А потом вы выделяете память под \verb"B::ptr_" и кладете туда адрес \verb"A::ptr_" из базовой части.
Понятно, что это бессмысленная деятельность, но демонстрирует зависимость данных.
Тут прошу обратить внимание на несколько вещей:
\begin{enumerate}
\item Я везде пользуюсь wrapper-ами для указателей и мне вообще не надо задумываться про деструкторы.

\item Обратите внимание, что нигде не пользуюсь \verb"new" явно, вместо этого пользуюсь \verb"std::make_unique" функцией.

\item Если в конструкторе \verb"B" при выделении памяти под \verb"B::ptr_" будет кинуто исключение, то так как базовая часть была построена и ее конструктор завершил работу, то вызовется деструктор базовой части \verb"~A()".
Это позволяет безболезненно кидать исключения при построении объекта по частям.
\end{enumerate}
Вот еще один пример по сборке Thread Pool через Windows Api.
Для инициализации у нас есть несколько ресурсов:
\begin{enumerate}
\item \verb"PTP_POOL pool"

\item \verb"TP_CALLBACK_ENVIRON environment"

\item \verb"PTP_CLEANUP_GROUP cleanup_group"
\end{enumerate}
При этом логика инициализации следующая:
\begin{enumerate}
\item Создать \verb"pool" так
\begin{cppcode}
pool = CreateThreadpool(nullptr);
\end{cppcode}
Эта операция может завершиться ошибкой.
В этом случае \verb"pool" будет \verb"nullptr"

\item Создать \verb"environment" так
\begin{cppcode}
InitializeThreadpoolEnvironment(&environment);
\end{cppcode}

\item Соединить \verb"pool" и \verb"environment" так:
\begin{cppcode}
SetThreadpoolCallbackPool(&environment, pool);
\end{cppcode}

\item Создать \verb"cleanup_group" так
\begin{cppcode}
cleanup_group = CreateThreadpoolCleanupGroup();
\end{cppcode}
Эта операция может завершиться ошибкой.
В этом случае \verb"cleanup_group" будет \verb"nullptr".

\item Соединить \verb"environment" и \verb"cleanup_group" так
\begin{cppcode}
SetThreadpoolCallbackCleanupGroup(&environment, cleanup_group, nullptr);
\end{cppcode}
\end{enumerate}
Чтобы инициализировать целиком все данные можно сделать следующее.
Под каждый ресурс заводим класс, который будет за него отвечать.
После чего наследуем их друг от друга, чтобы инициализировать их в правильном порядке.
\begin{center}
\begin{longtable}{ll}
{
\begin{minipage}[\baselineskip]{8.2cm}
\begin{cppcode}[numbers = none]
class Pool {
public:
  Pool();
  ~Pool();
  /*other methods*/
private:
  PTP_POOL pool_;
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{9cm}
\begin{cppcode}[numbers = none]
Pool::Pool() : pool_(CreateThreadpool(nullptr)) {
  if (pool_ == nullptr)
    throw std::runtime_error("Fail!\n");
}

Pool::~Pool() {
  CloseThreadpool(pool_);
}
\end{cppcode}
\end{minipage}
}\\\noalign{\medskip}
{
\begin{minipage}[\baselineskip]{8.2cm}
\begin{cppcode}[numbers = none]
class Environment : protected Pool {
public:
  Environment();
  ~Environment();
  /*other methods*/
private:
  TP_CALLBACK_ENVIRON environment_;
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{9cm}
\begin{cppcode}[numbers = none]
Environment::Environment() {
  InitializeThreadpoolEnvironment(&environment_);
  SetThreadpoolCallbackPool(&environment_, pool_);
}

Environment::~Environment() {
  DestroyThreadpoolEnvironment(&environment_);
}
\end{cppcode}
\end{minipage}
}\\\noalign{\medskip}\newpage
{
\begin{minipage}[\baselineskip]{8.2cm}
\begin{cppcode}[numbers = none]
class CleanupGroup : protected Environment {
public:
  CleanupGroup();
  ~CleanupGroup();
  /*other methods*/
  
  
private:

  PTP_CLEANUP_GROUP cleanup_;
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{9cm}
\begin{cppcode}[numbers = none]
CleanupGroup::CleanupGroup()
  : cleanup_(CreateThreadpoolCleanupGroup()) {
  if (cleanup_ == nullptr)
    throw std::exception("Fail!\n");
  SetThreadpoolCallbackCleanupGroup(
      &environment_, cleanup_, nullptr);
}
CleanupGroup::~CleanupGroup() {
  assert(cleanup_ != nullptr);
  CloseThreadpoolCleanupGroup(cleanup_);
}
\end{cppcode}
\end{minipage}
}\\\noalign{\medskip}
{
\begin{minipage}[\baselineskip]{8.2cm}
\begin{cppcode}[numbers = none]
class ThreadPool : protected CleanupGroup {
public:
  ThreadPool();
  ~ThreadPool();
  /*other methods*/
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{9cm}
\begin{cppcode}[numbers = none]
ThreadPool::ThreadPool() = default;

ThreadPool::~ThreadPool() {
  CloseThreadpoolCleanupGroupMembers(
      cleanup_, false, nullptr);
}
\end{cppcode}
\end{minipage}
}\\
\end{longtable}
\end{center}
В такой схеме можно спокойно кидать исключение в любом конструкторе и вся часть класса, построенная на предыдущих этапах очистится корректно.

\paragraph{Другие виды ресурсов}

Аналогично тому, что я написал про память используется для выделения других ресурсов.
Например для мьютексов используются \verb"std::lock_guard" или похожие механизмы.
Любой запрос к операционной системе, который требует освобождения своих ресурсов, должен выполняться через wrapper, где в конструкторе вы запрашиваете ресурс, а в деструкторе освобождаете.
