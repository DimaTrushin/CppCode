\ProvidesFile{BadCode.tex}[Признаки плохого кода]


\section{Признаки хорошего и плохого кода}
% TO DO

\subsection{Локальность}
\label{section::Locality}

Local Reasoning или возможность делать выводы по небольшому куску кода -- очень важное свойство.
Давайте я поделюсь тут некоторым философским замечанием.
Я знаю, что в среде программистов не особенно принято доказывать, что их программа работает корректно.
Мы просто пишем код.
Потом смотрим, кто на него ругается.
Если ругается компилятор -- исправляем на что ругается.
Если ругаются тесты -- исправляем на что ругается.
Если ругается начальник -- исправляем на что ругается.
Все работа выполнена.
При таком подходе не возможно ничего гарантировать.
И вот тут я бы сравнил написание программ с написанием математических статей.
Математические статьи оперируют куда более сложными конструкциями, чем проекты в индустрии.
Однако, если вы почитаете хорошие статьи в них нет ошибок.
Это не просто привычка писать текст и проверять себя, просто на дисциплине такое держать сложно.
Один из важных инструментов -- Local Reasoning.
Мы разбиваем сложное утверждение на маленькие утверждения, чьи доказательства проверить на корректность легко.
А потом собираем все из кусочков так, чтобы ошибке некуда было закрасться.
У профессиональных математиков этого достаточно чтобы гарантировать отсутствие ошибок (хотя не на 100\% как показывает практика).
Однако, даже в этом вопросе программисты пошли другим путем.
Есть специальные языки программирования, которые позволяют проверить корректность работы программы.
И если она не корректная, то вам на это ругнется компилятор, а если он не ругнулся, то значит проблем нет, это гарантируется.
Это очень здорово на самом деле и жаль, что такие инструменты мало распространены и не всегда ими удобно пользоваться.
А теперь давайте перейдем все таки от философии к делу.


Вся идея написания большого и сложного программного проекта -- разбить его на независимые части поменьше, обозначить четкие границы и правила взаимодействия между ними сквозь эти границы.
А дальше мы применяем это правило рекурсивно, бьем полученные компоненты на меньшие части и так далее.
Отсюда сразу становится понятно почему важна value semantics.
Наличие ссылок и указателей в данных или в объектах друг на друга (если только это не специальный паттерн) -- это всегда большая проблема для локальности.
Например
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
class A {
public:
  ...
  void f(int);
  void g(int);
private:
  B* b_;
  int data_;
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
class B {
public:
  ...
  void h(int);
  void w(int);
private:
  A* a_;
  int data_;
};
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Как мы видим выше у нас два класса и каждый из них хранит указатель на другой.
Тут важно понимать, что это не значит, что два объекта обязаны хранить указатели друг на друга.
Сырые указатели не спрятанные внутрь шаблона проектирования не дают никаких гарантий.
Теперь, представьте, что внутри метода \verb"A::f" вы дергаете метод \verb"B::h" доступный по указателю \verb"b_".
То есть теперь, чтобы понять, что делает класс \verb"A", вам надо знать, что делает класс \verb"B" и как он коммуницирует с \verb"A".
Но этого мало.
Вам надо держать в голове целый граф из всех возможных объектов класса \verb"A" и \verb"B", потому что они могут ссылаться друг на друга случайным образом.
А еще надо не забыть, что указатель может быть нулевым.
И чтобы написать код корректно, вам придется обрабатывать все возможные ситуации.
Вероятность, что вы это сделаете, почти ноль.
А значит ваш код очень быстро начнет падать на всем подряд.

\paragraph{Ссылки для передачи данных}

В таких ситуациях надо понять зачем вам нужны ссылки и указатели на другие объекты.
Очень часто бывает так, что вам надо передать данные из одного объекта в другой.
Вот пример кода и как его переделать
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
struct A {
  void do_something() {
    int x = make();
    b->do_something(x);
  }
  int make() const;
  B* b;
};

struct B {
  void do_something(int);
};

int main() {
  A a;
  B b;
  a.b = &b;
  a.do_something();  
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
struct A {
  int make() const;
};

struct B {
  void do_something(int);
};






int main() {
  A a;
  B b;
  int x = a.make();
  b.do_something(x);
}
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Как вы видите нет необходимости хранить указатель на другой объект, мы просто получаем данные из \verb"A" и отдаем их \verb"B".
Тут есть одна особенность.
Что эту передачу данных должен кто-то делать.
Если оба объекта лежат в каком-то классе, то за передачу данных отвечает класс.
Если оба объекта являются локальными объектами функции (как в примере выше), то за передачу данных отвечает сама функция.
Это так называемый мастер объект.
Однако, так бывает, что объекты равноправны и не имеют одного мастер объекта, который бы мог передавать данные.
В таких ситуациях надо использовать Observer pattern, который будет описан в разделе~\ref{section::Observer}.
В целом всегда можно организовать любую программу как пайплайн, где объекты поглощают и производят данные, и передача данных между объектами делается посредством Observer pattern-а.
Это не всегда нужно, но там где нужно, это позволяет полностью избавиться от каких-либо ссылок и указателей.

\paragraph{Парные операции}

Еще один пример отсутствия локальности мы видели в разделе~\ref{section::TimeEstimation} посвященному измерению времени.
Давайте посмотрим на вот такой кусок кода
\begin{cppcode}
void f(int, double);

int main() {
  Time start = Timer.now();
  f(5, 42.);
  Time elapsed = Timer.now() - start;
  return 0;
}
\end{cppcode}
Этот код хорош, что в нем сразу несколько проблем.
Но тут же мы видим не локальность.
А именно, мы работу по измерению времени делаем не в одном месте, а сразу в двух строчках~4 и~6.
И на практике эти строчки могут разъехаться очень далеко.
Данную ситуацию можно отнести к случаю, когда у вас есть какие-то парные связанные друг с другом операции, которые должны гарантированно выполняться парами.
Раздел~\ref{section::Decorators} про Декораторы как раз был посвящен тому, как стоит организовывать код в такой ситуации.

\paragraph{\texttt{shared\_ptr}}

Одна из причин, почему я делаю акцент на \texttt{shared\_ptr} на неконстантный объект -- он нарушает локальность.
Два \texttt{shared\_ptr}-а могут быть сколь угодно далеко друг от друга в коде, но при этом ссылаться на одни и те же данные.
Подробнее про это можно почитать в разделе~\ref{section::Dangerous} и~\ref{section::SharedPtr}.

\paragraph{Глобальные данные}

Это еще один пример нарушения локальности.
Наличие глобального состояния у системы может сломать все что угодно.
Любой чих в любой строчке кода может изменить глобальное состояние и все функции могут начать выдавать другой результат из-за этого.
Если вы страдали с тем, чтобы выставить правильно все сиды в рандомных генераторах каких-нибудь крупных фреймворков, чтобы получить воспроизводимость результатов, то вы знаете о чем я говорю.
Тем не менее, бывает, что без глобальных данных не обойтись.
Про примеры и то, как этим пользоваться стоит посмотреть раздел~\ref{section::Singleton}.

\paragraph{Value Semantics}

Одна из причин почему value semantics важная штука -- она улучшает локальность.
Потому что по определению данные в двух разных переменных никогда ни при каких условиях не влияют друг на друга, какой бы ни была имплементация.
Подробнее про семантику можно глянуть в разделе~\ref{section::Semantics}.

\subsection{Явные зависимости}
\label{section::Explicitness}
% TO DO
% Нужны примеры и побольше

Любая программа всегда состоит из двух частей
\begin{enumerate}
\item Данные

\item Методы
\end{enumerate}
Это все можно заворачивать в классы и прочие прелести, но у вас всегда есть данные, над которыми вы работаете, и методы, которые эти данные обрабатывают.
Когда вы работаете с данными, то очень важно понять какой объект какие другие объекты в себе содержит.
Это позволяет понять зону ответственности объекта и ограничить связанные данные вместе от посторонних.
Полезно перед глазами держать диаграмму владения.
Это граф, у которого вершины -- это объекты и вы проводите ребро из вершины подъобъекта в вершину владеющего объекта.
Либо вы можете это визуализировать в виде вложенных друг в друга боксов.
Если у вас не получается нарисовать такую диаграмму, значит у вас какие-то проблемы.
И часто проблемы связаны с отсутствием value semantics.
В данном случае диаграмма описывает явно зависимости между классами, кто кого содержит.

Другая полезная информация -- это поток данных между методами.
Просто потому что любое исполнение программы -- это выполнение ее методов: построение данных одними методами, передача этих данных в другие методы и так далее.
Важно не делать скрытых зависимостей и делать передачу данных явно.
Это одна из причин по которой я не люблю всякие ссылки и указатели внутри объектов.
Потому что вы могли передать данные в другой объект внутри метода, а пользователь метода снаружи даже не знает о том, что оказывается там какой-то скрытый метод выстрелил.
У вас всегда должны быть четкие границы между объектами.
Избегайте двустороннего общения между объектами.

Есть различные мысли о том почему Observer pattern плох.
Один из аргументов в том, что он ломает явные зависимости: мы отправляем сообщение и не знаем, что там выполнится.
Но я бы не сказал, что это прям беда, это скорее фича этого паттерна.
Но вот бездумное использование указателей и ссылок и вызов через них методов -- это уже проблема для явных зависимостей.

Так же формально инкапсюляция -- это противник явных зависимостей.
Потому что вы скрываете детали имплементации и не знаете, что внутри происходит.
Тем не менее, это не рассматривается как что-то плохое.
Дело в том, что вы обычно имплементируете класс с требуемым поведением, а потому наличие каких-то зависимостей внутри класса для вас не важно.
Если вы поставили границу так, что класс теперь просто черный ящик с нужным поведением, то у вас все зависимые узлы спрятаны внутри ящика.
А если вы занимаетесь имплементацией ящика, то там конечно не стоит делать неявные зависимости между деталями через ссылки и указателями.
Обращайтесь с данными явно.

\subsection{Уровни абстракции}
\label{section::AbstractionLevels}

При написании любого кода у вас есть мелкая рутинная работа, может быть прям на уровне машинного кода или вызова интринзиков или ассемблерные вставки и т.д.
А есть код очень высокого уровня, где вы оперируете сложными сущностями вроде \verb"Application", \verb"Scheduler", \verb"Renderer" и тому подобное.
Бывает, что код функций выполняет напрямую арифметические операции, а бывает, что вы вызываете другие функции.
То есть вы всегда находитесь на некоторой абстрактной линейной шкале между машиной и идейной моделью.
И глядя на разный код, можно смело сказать, что один является кодом более высокого уровня, чем другой.
Вот примеры
% TO DO
% Плохой пример. Надо сделать лучше.
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]

for (size_t i = 0; i < data.size(); ++i) {
  data[i] = function(data[i]);
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
std::transform(data.cbegin(), data.cend(),
    data.begin(), [](const auto& x) {
  return function(x);
});
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Обратите внимание, что код слева написан в виде сырого цикла, где мы руками бежим по элементам, руками применяем функцию \verb"function" к каждому элементу, и руками складываем результат в ту же ячейку вектора.
Справа же код более высокого уровня, потому что мы не говорим как надо делать операцию, мы делегируем детали функции \verb"std::transform" и лишь передаем нужные детали для выполнения операции.
Обратите внимание, что я сейчас не собираюсь обсуждать вопрос <<как лучше?>>.
Все что меня интересует, что слева -- низкоуровневый код, справа -- более высокоуровневый.

Что плохо -- смешение уровней абстракции.
Любой блок кода всегда должен быть написан на одном уровне абстракции, без смешения этих уровней.

\paragraph{Простая функция \texttt{main}}

Вот пример кода с нарушением уровня абстракции.
\begin{cppcode}
int main() {
  auto data = read();
  vector<int> result (data.size());
  for (size_t i = 0; i < data.size(); ++i)
    result[i] = f(data[i]);
  print(result);
  return 0;
}
\end{cppcode}
Мы видим, что строки~2 и~6 -- это делегирование высокоуровневой работы другим функциям.
Но в то же время в строках с~3 по~5 идет низкоуровневая работа по построению результата.
Для изменения уровня абстракции, проще поднять уровень абстракции у секции с 3 по 5 строки выделением их в функцию:
\begin{cppcode}
int main() {
  auto data = read();
  vector<int> result = apply_algorithm(data);
  print(result);
  return 0;
}
\end{cppcode}
Обратите внимание как теперь выглядит функция \verb"main".
Теперь все строки кода на одном уровне: мы в начале читаем данные, потом обрабатываем данные и получаем результат, потом печатаем результат.
Нужны детали -- смотрим в имплементацию каждой функции.

\paragraph{Измерение времени}

Давайте еще раз посмотрим на пример из раздела~\ref{section::TimeEstimation}.
\begin{cppcode}
void f(int, double);

int main() {
  Time start = Timer.now();
  f(5, 42.);
  Time elapsed = Timer.now() - start;
  return 0;
}
\end{cppcode}
В этом случае строчка~5 -- это делегирование какой-то вычислительной задачи другой функции.
Это высокоуровневая работа.
Измерение времени происходит в строках~4 и~6.
Причем мы руками создаем две переменные, руками находим разность между началом и концом.
Это явно более низкоуровневая работа.
Потому в этом примере происходит нарушение абстракции.

\paragraph{Захват ресурса}

Очень частая проблема -- захват ресурса.
Например, если вы хотите защитить данные для много поточки мьютексом вы можете написать что-то такое
\begin{cppcode}
void function() {
  Data d = read_data();
  Header h = compose_header();
  std::scoped_lock(mutex); // too low level
  write_to_file(h, d);
}
\end{cppcode}
Если посмотреть на функцию выше, то мы видим, что строки~2, 3 и~5 -- это делегирование работы другим функциям.
Это код высокого уровня.
Однако, в строке~4 идет супер низкоуровневая операция -- захват мьютекса.
Это явно нарушение уровня абстракции.
В бизнеслогике вообще не должны фигурировать всякие низкоуровневые детали имплементации.
Вам все равно что там надо залочить на уровне железа, на уровне функции \verb"function" все что нас интересует -- мы хотим безопасно записать данные в файл.
Потому правильно будет либо создать отдельную функцию \verb"write_to_file_safely" либо воспользоваться декораторами как написано в разделе~\ref{section::Decorators}.
Вот как будет выглядеть исправленное решение:
\begin{cppcode}
void function() {
  Data d = read_data();
  Header h = compose_header();
  write_to_file_safely(h, d);
}
\end{cppcode}
Вопрос выбора имен -- это разумеется отдельная проблема, но зато теперь весь код написан на одном уровне абстракции.

\subsection{Уровни доступа}
\label{section::AccessLevels}

Давайте посмотрим на следующий пример
\begin{cppcode}
A a;
int x = a.b.f();
int y = a.b.c.g();
a.d.h(x, y);
\end{cppcode}
Обратите внимание, что мы создали объект класса \verb"A" и хотим с ним работать.
Мы хотим получить из него две целочисленные переменные \verb"x" и \verb"y" и потом их передать опять объекту типа \verb"A".
Однако, мы вместо использования методов класса \verb"A" стучимся в подъобъекты.
Это означает, что класс \verb"A" не содержит нужных методов для работы с ним, отчего приходится стучаться в его кишки.
Вместо этого надо в классе \verb"A" пробросить соответствующие методы
\begin{cppcode}
class A {
public:
  int f() const {
    return b.f();
  }
  int g() const {
    return b.c.g(); // BAD
  }
  void h(int x, int y) {
    d.h(x, y);
  }
private:
  B b;
  D d;
};
\end{cppcode}
Вот так уже лучше, но строчка~7 -- это тоже нарушение уровня доступа.
Теперь уже объект класса \verb"B" не предоставляет нужные методы для работы с ним, а потому надо метод \verb"g" пробросить в интерфейс класса \verb"B", чтоб написать так
\begin{cppcode}
int g() const {
  return b.g();
}
\end{cppcode}
После чего использование класса \verb"A" становится простым и понятным
\begin{cppcode}
A a;
int x = a.f();
int y = a.g();
a.h(x, y);
\end{cppcode}
Обратите внимание, что есть паттерн Builder (разобранный в разделе~\ref{section::Builder}), который наоборот использует вызовы вида
\begin{cppcode}
Builder b;
b.input(3).addLinear(5).add(Sigmoid).addLinear(2).add(ReLu);
Network n = b.extract();
\end{cppcode}
Такой подход вызова команд друг за другом называется Chaining.
Его использование нисколько не противоречит правилу про уровень доступа, потому что вы просто хотите на одном объекте вызвать много методов друг за другом.
Это просто другой стиль использования плюсового синтаксиса.

\subsection{Не сваливать все в кучу}
\label{section::SeparateStuff}
% TO DO

\subsection{Не своя работа}
\label{section::WrongWork}
% TO DO

\subsection{Плохо продуманные интерфейсы}
\label{section::BadInterfaces}

Важно, чтобы объекты и методы, которые вы пишете, могли удобно друг с другом коммуницировать.
В частности если один метод возвращает данные в каком-то формате, то удобно и другому методы принимать их в таком формате.
Если это не возможно, то значит должен быть промежуточный метод, который делает трансформацию данных.
Или же если один класс пользуется другим для своих целей, то хорошо бы, чтобы в интерфейсе этого другого класса был весь тот функционал, который необходим для использования.
Либо нужный функционал должен быть написан поверх предоставляемого.

\paragraph{Передача данных}

Предположим у вас есть две функции
\begin{cppcode}
struct Vector2D {
  double x;
  double y;
};

Vector2D produce();
void consume(double x, double y);
\end{cppcode}
Обе функции работают с двумерными векторами, но одна функция возвращает вектор как структуру, а другая принимает координаты вектора по-отдельности.
Что придется делать, чтобы передавать данные из одной функции в другую?
Конвертировать
\begin{cppcode}
Vector2D vec = produce();
consume(vec.x, vec.y);
\end{cppcode}
Либо симметричная ситуация
\begin{cppcode}
double produce_x();
double produce_y();
void consume(Vector2D);
\end{cppcode}
Тогда придется писать
\begin{cppcode}
consume(Vector2D{produce_x(), produce_y()});
\end{cppcode}
Проблема в этом случае в том, что один метод выдает данные не в том формате, в котором их ожидает другой метод.
Если вы разрабатывали эти интерфейсы, то вы просто плохо их продумали.
Вы знали, какие у вас есть функции и какие данные надо передавать между ними.
И раз вы их передаете в несовместимом формате, то это вы сами себе усложнили задачу.
В идеале должно быть
\begin{cppcode}
Vector2D produce();
void consume(Vector2D);

Vector2D vec = produce();
consume(vec);
\end{cppcode}
Если же интерфейсы этих функций вы поменять не можете, то вы на самом деле попали в ситуацию проблемы, которая будет адресована в разделе~\ref{section::NotEnoughHats}.
Попросту говоря, вам надо создать новую функцию, с нужным интерфейсом, которая будет внутри себя делать конвертацию и потом вызывать уже функцию с неудобным интерфейсом.
Такая функция называется адаптером.
Про адаптеры и фасады подробнее написано в разделе~\ref{section::AdaptorsFacades}.

\paragraph{Интерфейс класса}

Мой любимый пример -- пример из STL, а именно имплементация \verb"std::vector".
А точнее метод \verb"size".
Кто писал такой код
\begin{cppcode}
std::vector<int> vec = { ... };
for (int i = 0; i < vec.size(); ++i)
  vec[i] = ...;
\end{cppcode}
тот знает мою боль.
Дело в том, что в цикле \verb"for" происходит сравнение знакового \verb"i" и без знакового \verb"vec.size()".
Так лучше не делать, можно легко добиться UB смешивая знаковые и без знаковые типы.
Поэтому в C++20 даже добавили \verb"ssize", которая возвращает знаковое значение для размера вектора.
Я считаю это успех.

\subsection{Люди носят не достаточное количество шляп}
\label{section::NotEnoughHats}
% TO DO

Я думаю, что стоит начать с пояснения названия раздела.
Это название я взял из доклада Tony Van Eerd <<SOLID, Revisited>>.
Его можно было сформулировать так: <<люди используют недостаточное количество функций>>.
Это значит, что какую-то работу, которую можно было погрузить в отдельную функцию, делают на месте руками, что усложняет код и работу с ним.
% TO DO

%\subsubsection{Комментарии}
% TO DO

%\subsection{Не обеспечена семантика класса}
% TO DO
