\ProvidesFile{BadCode.tex}[Признаки плохого кода]


\section{Признаки хорошего и плохого кода}

\subsection{Общие слова}

Вы скорее всего встретите много разных советов, что в коде хорошо, а что плохо.
И с большой вероятностью все эти правила буду противоречить друг другу.
Потому очень важно понимать как к этому относиться.
Ситуация с кодом очень похожа на ситуацию со скоростными ограничениями на дороге.
Плохая идея гонять по городу $110$, в то же время плохая идея ехать по трассе $60$.
Главная мысль в том, что все сильно зависит от ситуации и обстоятельств.
Чтобы хоть как-то пояснить это я хочу начать с примера.

\paragraph{Олимпиадное программирование}

Вы когда-нибудь смотрели посылки на codeforces?
Вы видели какое безобразие люди пишут в коде?
Вот один из примеров.
\begin{cppcode}
#define int long long
\end{cppcode}
А теперь вопрос: хорошо это или плохо?
Раз топовые участники codeforces так пишут, то видимо хорошо.
Однако, в то же время топовые программисты со всего мира рассказывают вам, что ни в коем случае так писать нельзя.
Возникает вопрос, почему в олимпиадном программировании так писать хорошо, а в промышленном программировании плохо.
Дело в том, что задача олимпиадного программиста максимально быстро написать программу, которая продет все тесты системы и все.
После этого код никогда не используется, он выкидывается на помойку и про него никто не вспоминает.
Его не надо поддерживать, его не надо модифицировать, его вообще не надо даже вспоминать.
А потому любые трюки, которые позволяют что-либо сделать быстрее -- это хорошо.
В частности вместо того, чтобы везде менять int на long long и получить ошибку от того, что вы где-то это забыли сделать, можно просто воспользоваться препроцессором.

С другой стороны в промышленном коде подобные трюки плохи, потому что они мешают поддерживать код.
Основная проблема с этим макросом, что он меняет код где угодно после него.
И тогда код который видит программист и который видит компилятор -- это два разных кода.
А это значит, что код начинает врать программисту.
Это не локальное изменение, которое тяжело обслуживать.

\paragraph{Математика и алгоритмы}

Есть хорошее правило, что размер функций должен быть не большим, чтобы можно было понять, что функция делает.
Что переменные должны иметь нормальные имена, чтобы было понятно, что они делают.
Что не должно быть больше $3$ вложенных scope, чтобы не было спагетти кода.
Все это хорошо, но вот вы начинаете писать какой-то известный алгоритм.
Предположим в этом алгоритме используются обозначения для времени, координаты, скорости, массы и импульса $t$, $x$, $v$, $m$ и $p$, соответственно.
Теперь сравните два кода
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
x = v * t;
p = m * v;
E = 1/2 * m * v * v;
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
coordinate = velocity * time;
impulse = mass * velocity;
Energy = 1/2 * mass * velocity * velocity;
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Обратите внимание на сколько тяжелее читать код справа, хотя мы дали всем переменным говорящие имена.
Тут есть две проблемы:
\begin{enumerate}
\item Имена справа не привычные, а обозначения слева нам более привычны.

\item Имена справа врут.
Дело в том, что переменная \verb"time" не ясно какое именно время обозначает.
То есть мы вроде уточнили, что \verb"t" это время, но вот время от какого момента до какого, не уточнили.
Или \verb"Energy" справа -- это все таки кинетическая энергия, а не просто какая-то энергия.
И усложнять эти имена до длинных предложений не имеет смысла.
\end{enumerate}
Аналогичная проблема с именами в математических алгоритмах или в имплементации структур данных.
Часто авторы статей используют для обозначений короткие обозначения, которые облегчают понимание алгоритма.
Разумно так и записать алгоритм, а перед этим алгоритмом добавить пояснения для всех переменных, которые присутствуют в статье.

Сюда же я хочу добавить замечания по поводу размеров функций и количества вложенных scope.
Так часто бывает, что какой-нибудь сложный алгоритм может содержать $4$ вложенных цикла.
И он не бьется никаким разумным образом на подфункции, в которые можно было бы спрятать внутренние циклы или как-то разбить его на логические части.

Я хочу сказать, что в подобных ситуациях нет смысла пытаться подогнать ваш код под какие-то специфические правила.
Вы можете ухудшить читаемость кода и/или его производительность.
И причина почему вы можете себе это позволить -- вы этот алгоритм пишете один раз.
Вы точно знаете, что он так работает корректно и никогда не будете его модифицировать.
В худшем случае, вы имплементируете новый алгоритм из другой статьи.
А потому лучше для понимания, чтобы код был близок к статье, по которой вы его пишете.

\paragraph{Масштабы проекта}

Вы можете прочитать кучу разных теорий о том как писать то или иное приложение, о разных подходах к архитектуре или прочие тонкости.
Однако, не всегда следует применять все что вы видите, только потому что это было создано для вашей ситуации.
Все сильно зависит от масштабов вашего проекта.
Если проект маленький, то нет смысла в него внедрять сложные конструкции или парадигмы.
Не занимайтесь Over Engeneering.
Вот пример, который мне часто приходится видеть на проектах.
Ребята имплементируют 3D Renderer с нуля и используя его пишут интерактивное приложение, которое демонстрирует возможности движка.
Схема потока данных в интерактивном приложении следующая
\[
\xymatrix{
  {}&{\text{World}}\ar[dr]&{}&{}&{}&{}\\
  {\text{Input}}\ar[r]&{\text{Camera}}\ar[r]&{\text{Renderer}}\ar[r]&{\text{Picture}}\ar[r]&{\text{Screen}}&{}\\
  {}&{\text{Lights}}\ar[ur]&{}&{}&{}&{}\\
}
\]
Для такой простой схемы, можно даже не городить никакую Message Driven System, не использовать MVC или другие паттерны.
Весь код можно засунуть целиком в цикл обработчик событий.
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
class Application {
public:
  Application(); // initializes resources
  
  void run(); // run event loop
private:
  auto read_user_input();

  World world_;
  Camera camera_;
  Lights lights_;
  Renderer renderer_;
  Screen screen_;
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
Application::Application() {
  /*Initialization*/
}
void Application::run() {
  ...
  /*somewhere in event loop*/
  auto action = read_user_input();
  camera_.move(action);
  Picture picture = renderer.make(world_,
                                  camera_,
                                  lights_);
  screen_.draw(picture);
  ...
}
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Заметьте, что нет необходимости делить код на ядро, и другие компоненты.
Все хранится непосредственно в классе приложения.
И вы просто друг за другом передаете данные от одного объекта другому, как и требуется.
В этой простой ситуации нет необходимости использовать межобъектную коммуникацию или какие-то сложные паттерны.
Вы даже можете не использовать event loop, вы можете просто крутиться в бесконечном цикле и опрашивать клавиатуру.
Нужно только защититься таймером, чтобы цикл не проходил слишком быстро и все.

Недостаток такого подхода -- его не возможно масштабировать.
Но если вам надо начать масштабировать это решение, то вы можете стартовать с кода выше.
У вас уже есть в готовые работающие компоненты и теперь лишь надо распилить \verb"Application" и соединить его компоненты  друг с другом в соответствии с MVC.
То есть вы делаете эту работу тогда, когда она нужна, а не заранее, когда вы даже не знаете нужно это или нет.

\paragraph{Идеал и реальность}

Есть хороший вопрос: как понять, когда что-то надо использовать или нет.
Есть по сути три простых ситуации
\begin{enumerate}
\item Вы знаете что в данной ситуации надо использовать и умеете это имплементировать.
Например, вы знаете, что лучше использовать \verb"std::vector" из-за локальности в памяти данных.
Или вы умеете имплементировать поиск за $O(\log(n))$ или $O(1)$ с помощью соответствующей структуры данных и вы знаете, что вам это нужно.
Ну значит так и делайте.
Раз вы знаете, что это тут нужно и умеете, то глупо этого не делать.

\item Вы не знаете, что в данной ситуации надо использовать.
Тут все проще, вы даже не поймете, что у вас была такая ситуация.
Либо если вы задумаетесь над ней, то это повод что-то почитать и изучить.

\item Вы знаете, что в данной ситуации надо использовать, но не умеете это имплементировать.
Вот тут ситуация интереснее.
Вы можете поступить двумя способами
\begin{enumerate}
\item Имплементировать как получится и как вы умеете.

\item Изучить, что в этом случае люди делают.
\end{enumerate}
И тут все зависит от ваших ресурсов.Если вы ограничены
 во времени и ресурсах, то намного проще и правильнее  будет имплементировать как получится.
Очень может оказаться, что оно и так сойдет, что не оказывается тут нет никакого узкого горлышка и все и так работает.
Вы сэкономите время и силы на то, что не потратите его на ненужную работу.
Во втором подходе есть так же проблема в том, что вам без опыта и понимания надо как-то понять какое из предлагаемых решений вам действительно нужно и какое из них действительно хорошо.
И часто вы просто придете к тому, что надо было просто имплементировать как есть.
\end{enumerate}
От себя хочу добавить, что работая над проектом анализа качества печати в одиночку, я часто встречался с ситуацией, что есть какая-то второстепенная деталь в проекте, которую надо имплементировать и без нее нельзя продвинуться дальше в содержательных вопросах.
И я понятия не имел как это делать.
И каждый раз решение -- сделать как-то было самым правильным.
Оно сохраняло время, силы и желание работать над важной частью проекта.
Чем опытнее вы будете становиться, тем больше у вас будет понимания, а как теперь надо писать проект.

%\paragraph{Не будьте умным}

\subsection{Локальность}
\label{section::Locality}

Local Reasoning или возможность делать выводы по небольшому куску кода -- очень важное свойство.
Давайте я поделюсь тут некоторым философским замечанием.
Я знаю, что в среде программистов не особенно принято доказывать, что их программа работает корректно.
Мы просто пишем код.
Потом смотрим, кто на него ругается.
Если ругается компилятор -- исправляем на что ругается.
Если ругаются тесты -- исправляем на что ругается.
Если ругается начальник -- исправляем на что ругается.
Все работа выполнена.
При таком подходе не возможно ничего гарантировать.
И вот тут я бы сравнил написание программ с написанием математических статей.
Математические статьи оперируют куда более сложными конструкциями, чем проекты в индустрии.
Однако, если вы почитаете хорошие статьи в них нет ошибок.
Это не просто привычка писать текст и проверять себя, просто на дисциплине такое держать сложно.
Один из важных инструментов -- Local Reasoning.
Мы разбиваем сложное утверждение на маленькие утверждения, чьи доказательства проверить на корректность легко.
А потом собираем все из кусочков так, чтобы ошибке некуда было закрасться.
У профессиональных математиков этого достаточно чтобы гарантировать отсутствие ошибок (хотя не на 100\% как показывает практика).
Однако, даже в этом вопросе программисты пошли другим путем.
Есть специальные языки программирования, которые позволяют проверить корректность работы программы.
И если она не корректная, то вам на это ругнется компилятор, а если он не ругнулся, то значит проблем нет, это гарантируется.
Это очень здорово на самом деле и жаль, что такие инструменты мало распространены и не всегда ими удобно пользоваться.
А теперь давайте перейдем все таки от философии к делу.


Вся идея написания большого и сложного программного проекта -- разбить его на независимые части поменьше, обозначить четкие границы и правила взаимодействия между ними сквозь эти границы.
А дальше мы применяем это правило рекурсивно, бьем полученные компоненты на меньшие части и так далее.
Отсюда сразу становится понятно почему важна value semantics.
Наличие ссылок и указателей в данных или в объектах друг на друга (если только это не специальный паттерн) -- это всегда большая проблема для локальности.
Например
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
class A {
public:
  ...
  void f(int);
  void g(int);
private:
  B* b_;
  int data_;
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
class B {
public:
  ...
  void h(int);
  void w(int);
private:
  A* a_;
  int data_;
};
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Как мы видим выше у нас два класса и каждый из них хранит указатель на другой.
Тут важно понимать, что это не значит, что два объекта обязаны хранить указатели друг на друга.
Сырые указатели не спрятанные внутрь шаблона проектирования не дают никаких гарантий.
Теперь, представьте, что внутри метода \verb"A::f" вы дергаете метод \verb"B::h" доступный по указателю \verb"b_".
То есть теперь, чтобы понять, что делает класс \verb"A", вам надо знать, что делает класс \verb"B" и как он коммуницирует с \verb"A".
Но этого мало.
Вам надо держать в голове целый граф из всех возможных объектов класса \verb"A" и \verb"B", потому что они могут ссылаться друг на друга случайным образом.
А еще надо не забыть, что указатель может быть нулевым.
И чтобы написать код корректно, вам придется обрабатывать все возможные ситуации.
Вероятность, что вы это сделаете, почти ноль.
А значит ваш код очень быстро начнет падать на всем подряд.

\paragraph{Ссылки для передачи данных}

В таких ситуациях надо понять зачем вам нужны ссылки и указатели на другие объекты.
Очень часто бывает так, что вам надо передать данные из одного объекта в другой.
Вот пример кода и как его переделать
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
struct A {
  void do_something() {
    int x = make();
    b->do_something(x);
  }
  int make() const;
  B* b;
};

struct B {
  void do_something(int);
};

int main() {
  A a;
  B b;
  a.b = &b;
  a.do_something();  
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
struct A {
  int make() const;
};

struct B {
  void do_something(int);
};






int main() {
  A a;
  B b;
  int x = a.make();
  b.do_something(x);
}
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Как вы видите нет необходимости хранить указатель на другой объект, мы просто получаем данные из \verb"A" и отдаем их \verb"B".
Тут есть одна особенность.
Что эту передачу данных должен кто-то делать.
Если оба объекта лежат в каком-то классе, то за передачу данных отвечает класс.
Если оба объекта являются локальными объектами функции (как в примере выше), то за передачу данных отвечает сама функция.
Это так называемый мастер объект.
Однако, так бывает, что объекты равноправны и не имеют одного мастер объекта, который бы мог передавать данные.
В таких ситуациях надо использовать Observer pattern, который будет описан в разделе~\ref{section::Observer}.
В целом всегда можно организовать любую программу как пайплайн, где объекты поглощают и производят данные, и передача данных между объектами делается посредством Observer pattern-а.
Это не всегда нужно, но там где нужно, это позволяет полностью избавиться от каких-либо ссылок и указателей.

\paragraph{Парные операции}

Еще один пример отсутствия локальности мы видели в разделе~\ref{section::TimeEstimation} посвященному измерению времени.
Давайте посмотрим на вот такой кусок кода
\begin{cppcode}
void f(int, double);

int main() {
  Time start = Timer.now();
  f(5, 42.);
  Time elapsed = Timer.now() - start;
  return 0;
}
\end{cppcode}
Этот код хорош, что в нем сразу несколько проблем.
Но тут же мы видим не локальность.
А именно, мы работу по измерению времени делаем не в одном месте, а сразу в двух строчках~4 и~6.
И на практике эти строчки могут разъехаться очень далеко.
Данную ситуацию можно отнести к случаю, когда у вас есть какие-то парные связанные друг с другом операции, которые должны гарантированно выполняться парами.
Раздел~\ref{section::Decorators} про Декораторы как раз был посвящен тому, как стоит организовывать код в такой ситуации.

\paragraph{\texttt{shared\_ptr}}

Одна из причин, почему я делаю акцент на \texttt{shared\_ptr} на неконстантный объект -- он нарушает локальность.
Два \texttt{shared\_ptr}-а могут быть сколь угодно далеко друг от друга в коде, но при этом ссылаться на одни и те же данные.
Подробнее про это можно почитать в разделе~\ref{section::Dangerous} и~\ref{section::SharedPtr}.

\paragraph{Глобальные данные}

Это еще один пример нарушения локальности.
Наличие глобального состояния у системы может сломать все что угодно.
Любой чих в любой строчке кода может изменить глобальное состояние и все функции могут начать выдавать другой результат из-за этого.
Если вы страдали с тем, чтобы выставить правильно все сиды в рандомных генераторах каких-нибудь крупных фреймворков, чтобы получить воспроизводимость результатов, то вы знаете о чем я говорю.
Тем не менее, бывает, что без глобальных данных не обойтись.
Про примеры и то, как этим пользоваться стоит посмотреть раздел~\ref{section::Singleton}.

\paragraph{Value Semantics}

Одна из причин почему value semantics важная штука -- она улучшает локальность.
Потому что по определению данные в двух разных переменных никогда ни при каких условиях не влияют друг на друга, какой бы ни была имплементация.
Подробнее про семантику можно глянуть в разделе~\ref{section::Semantics}.

\subsection{Явные зависимости}
\label{section::Explicitness}

Любая программа всегда состоит из двух частей
\begin{enumerate}
\item Данные

\item Методы
\end{enumerate}
Это все можно заворачивать в классы и прочие прелести, но у вас всегда есть данные, над которыми вы работаете, и методы, которые эти данные обрабатывают.

\paragraph{Диаграмма владения}

Когда вы работаете с данными, то очень важно понять какой объект какие другие объекты в себе содержит.
Это позволяет понять зону ответственности объекта и ограничить связанные данные вместе от посторонних.
Полезно перед глазами держать диаграмму владения.
Это граф, у которого вершины -- это объекты и вы проводите ребро из вершины подъобъекта в вершину владеющего объекта.
Либо вы можете это визуализировать в виде вложенных друг в друга боксов.
Если у вас не получается нарисовать такую диаграмму, значит у вас какие-то проблемы.
И часто проблемы связаны с отсутствием value semantics.
В данном случае диаграмма описывает явно зависимости между классами, кто кого содержит.

\paragraph{3D Renderer}

Я вернусь тут к примеру с 3D Renderer-ом с нуля.
Пусть у  нас есть несколько простых компонент в приложении как ниже.
Очень часто вижу приблизительно такой код, где вас должны сильно смутить указатели и отсутствие \verb"Screen".
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]

class Application {
public:
  Application(); // initializes resources
  
  void run(); // run event loop
  
private:

  Camera camera_;
  Lights lights_;
  World world_;
  Renderer renderer_;
};

\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
Application::Application()
  : camera_(initialize_camera()),
    lights_(initialize_lights()),
    world_(initialize_world(),
            &camera,
            &lights_),
    renderer_(600, 800, &world_) {
}
void Application::run() {
  ...
  /*Somewhere in event loop*/
  camera_.move(action)
  renderer_.make();
  ...
}
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
А потом выясняется вот такая схема владения.
\[
\xymatrix@R=10pt{
{\text{Renderer}}
  	{
	\save
   [].[dd]*+[F-:<3pt>]\frm{}
   \restore
	}
	&{}&{}\\
{\text{Screen}}
  	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
&{}&{}\\
{\text{ptr}}\ar[r]
  	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
&{\text{World}}
  	{
	\save
   [].[ddd]*+++[F-:<3pt>]\frm{}
   \restore
	}
&{}\\
{}&{\text{Objects}}
  	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
&{}\\
{}&{\text{ptr}}\ar[r]
  	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
&{\text{camera}}
  	{
	\save
   [].[]*+[F-:<3pt>]\frm{}
   \restore
	}
\\
{}&{\text{ptr}}\ar[r]
  	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
&{\text{lights}}
  	{
	\save
   [].[]*+[F-:<3pt>]\frm{}
   \restore
	}
\\
}
\]
В частности выясняется, что GUI код находится внутри \verb"Renderer".
И тут сразу становится понятно зачем надо было в \verb"Renderer" передавать размеры окна.
Диаграмма приведенная выше -- это на самом деле еще цветочки.
У меня были ситуации, когда надо было около $4$ часов тщательно изучать код и рисовать сложный граф, содержащий информацию о том, кто на кого содержит какие ссылки, кто реально владеет данными и кто кому как их передает.

Обратите внимание на \verb"run" функцию.
Тут я опустил код, читающий пользовательский ввод, но предположим мы считали данные \verb"action".
А дальше происходит какая-то магия в строчке \verb"renderer_.make()".
Потому что метод \verb"make" ничего не принимает, ничего не возвращает, но тем не менее эта строчка делает все.
С такой диаграммой владения, когда объекты неявно ссылаются друг на друга, у вас всегда есть возможность начать модифицировать состояние чужого объекта внутри своего метода.
А значит вы автоматически начинаете передавать данные неявно.
Это порождает кучу проблем с пониманием потока данных.

\paragraph{Диаграмма потока данных}

Другая полезная информация -- это поток данных между методами.
Просто потому что любое исполнение программы -- это выполнение ее методов: построение данных одними методами, передача этих данных в другие методы и так далее.
Важно не делать скрытых зависимостей и делать передачу данных явно.
Это одна из причин по которой я не люблю всякие ссылки и указатели внутри объектов.
Потому что вы могли передать данные в другой объект внутри метода, а пользователь метода снаружи даже не знает о том, что оказывается там какой-то скрытый метод выстрелил.
У вас всегда должны быть четкие границы между объектами.
Избегайте двустороннего общения между объектами.

\paragraph{Еще раз 3D Renderer}

Давайте вернемся к примеру 3D Renderer-а из начала раздела.
Здесь теперь объекты лежат как надо.
\begin{cppcode}
class Application {
public:
  Application(); // initializes resources
  
  void run(); // run event loop
private:
  auto read_user_input();

  World world_;
  Camera camera_;
  Lights lights_;
  Renderer renderer_;
  Picture picture_;
  Screen screen_;
};
\end{cppcode}
Диаграмма владения очень простая.
Нет никакой необходимости этим объектам знать хоть что-то друг про друга.
Всю информацию, которую нужно передать от одного объекта другому сможет передать \verb"Application" в своих методах.
\[
\xymatrix{
  {\phantom{Aworld}}&{}&{\text{Application}}
    	{
	\save
   [ll].[drrr]*+++[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{}&{}\\
  {\text{world}}
      	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  &{\text{camera}}
        	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  &{\text{lights}}
        	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  &{\text{renderer}}
        	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  &{\text{picture}}
        	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  &{\text{screen}}
        	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  \\
}
\]
Но даже в этом случае можно сделать очень плохой поток данных вот такой имплементацией.
\begin{cppcode}
void Application::run() {
  ...
  /*somewhere in event loop*/
  move_camera();
  make_picture();
  draw_picture();
  ...
}
void Application::move_camera() {
  auto action = read_user_input();
  camera_.move(action);
}

vpod Application::make_picture() {
  picture_ = renderer_.make(world_, camera_, lights_);
}

void Application::draw_picture() {
  screen_.draw(picture);
}
\end{cppcode}
Ну а действительно, зачем нам явно подставлять все поля класса в функции, они же видны из любого метода класса.
И у вас в классе появляются методы, которые ничего не принимают и ничего не возвращают, но они делают всю работу.
И вот как понять по коду выше в строках~4-6, откуда и куда текут данные?
Так же обратите внимание, что теперь название метода \verb"move_camera" просто врет программисту.
Дело в том, что этот метод не только двигает камеру, но и читает пользовательский ввод.
Кроме того, теперь мы еще и новую переменную положили в \verb"Application", которая вообще то имеет смысл только локально для передачи данных от \verb"renderer" к \verb"screen" и не отражает состояния приложения.
Это может быть желательно скажете вы, чтобы не переаллоцировать буффер под картинку.
Но это все можно исправить следующим образом.

В начале давайте избавимся от неявных методов только модифицирующих состояние.
\begin{cppcode}
void Application::run() {
  ...
  /*somewhere in event loop*/
  auto action = read_user_input();
  camera_.move(action);
  picture_ = renderer.make(world_, camera_, lights_);
  screen_.draw(picture);
  ...
}
\end{cppcode}
А теперь, чтобы переиспользовать память внутри \verb"picture_" заведем ее локально внутри \verb"run", но будем мувать ее внутрь \verb"make" метода объекта \verb"renderer", чтобы уже он решал может ли он и хочет ли он переиспользовать буффер.
Код будет выглядеть как-то так.
\begin{cppcode}
void Application::run() {
  Picture picture;
  ...
  /*somewhere in event loop*/
  auto action = read_user_input();
  camera_.move(action);
  picture = renderer.make(world_, camera_, lights_, std::move(picture));
  screen_.draw(picture);
  ...
}
\end{cppcode}
И у нас теперь нет необходимости хранить внутри \verb"Application" данные, которые не релевантны для состояния приложения и которые возникают только внутри конкретного метода, и при этом избежать неявного потока данных и переаллокации.
Метод \verb"make" уже проверит можно ли переиспользовать буфер внутри \verb"picture" или нет.

\paragraph{Аргументы ссылки}

Еще один прекрасный источник неявных зависимостей -- принимать аргументы методов по не константной ссылке.
Посмотрите на следующий код.
\begin{cppcode}
int x = 1;
double y = 2.;
char z = 'c';
short r = function(x, y, z);
\end{cppcode}
Вот какое значение вы ожидаете у аргументов после такого вызова?
А функция еще такая умная, возвращает значение, наверное они просто по трем значениям стоит четвертое, ведь так?
А вот ее сигнатура
\begin{cppcode}
short function(int, double&, char);
\end{cppcode}
И у вас нет ни шанса узнать на стороне пользователя, что второй аргумент может меняться.
Для того, чтобы подсказать на стороне пользователя, что аргумент может меняться, обычно принято передавать аргумент по указателю.
В этом случае картина выглядит так
\begin{cppcode}
short function(int, double&, char);

int x = 1;
double y = 2.;
char z = 'c';
short r = function(x, &y, z);
\end{cppcode}
На самом деле такой же походи использует функция \verb"scanf", которая пишет в аргумент ввод пользователя.
Она принимает аргументы по указателю.
Это подсказывает пользователю функции, что аргумент может измениться.
В рамках такого подхода принято разделять аргументы функции на входные и выходные.
\begin{enumerate}
\item Из входных параметров функция читает данные.

\item В выходные параметры функция пишет данные.
Бывает еще что некоторые выходные параметры имеют двойное назначение из них данные и читаются и в них пишутся.
\end{enumerate}
В этом случае принято придерживаться следующих правил:
\begin{enumerate}
\item Все входные параметры идут в начале, а все выходные параметры в конце.

\item Все входные параметры принимаются либо по значению либо по константной ссылке.

\item Все выходные параметры принимаются по указателю.
\end{enumerate}
В соответствии с этими соглашениями предыдущий пример выглядел бы так.
\begin{cppcode}
short function(int, char, double&);

int x = 1;
double y = 2.;
char z = 'c';
short r = function(x, z, &y);
\end{cppcode}
В этом случае возвращаемое значение может содержать код ошибки, если в этом есть необходимость.

\paragraph{Инкапсюляция}

Формально инкапсюляция -- это противник явных зависимостей.
Потому что вы скрываете детали имплементации и не знаете, что внутри происходит.
Тем не менее, это не рассматривается как что-то плохое.
Дело в том, что вы обычно имплементируете класс с требуемым поведением, а потому наличие каких-то зависимостей внутри класса для вас не важно.
Если вы поставили границу так, что класс теперь просто черный ящик с нужным поведением, то у вас все зависимые узлы спрятаны внутри ящика.
А если вы занимаетесь имплементацией ящика, то там конечно не стоит делать неявные зависимости между деталями через ссылки и указателями.
Обращайтесь с данными явно.

\paragraph{Observer pattern}

Есть различные мысли о том почему Observer pattern плох.
Один из аргументов в том, что он ломает явные зависимости: мы отправляем сообщение и не знаем, что там выполнится.
Но я бы не сказал, что это прям беда, это скорее фича этого паттерна.
Но вот бездумное использование указателей и ссылок и вызов через них методов -- это уже проблема для явных зависимостей.

\subsection{Уровни абстракции}
\label{section::AbstractionLevels}

При написании любого кода у вас есть мелкая рутинная работа, может быть прям на уровне машинного кода или вызова интринзиков или ассемблерные вставки и т.д.
А есть код очень высокого уровня, где вы оперируете сложными сущностями вроде \verb"Application", \verb"Scheduler", \verb"Renderer" и тому подобное.
Бывает, что код функций выполняет напрямую арифметические операции, а бывает, что вы вызываете другие функции.
То есть вы всегда находитесь на некоторой абстрактной линейной шкале между машиной и идейной моделью.
И глядя на разный код, можно смело сказать, что один является кодом более высокого уровня, чем другой.
Вот примеры
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
for (size_t i = 0; i < data.size(); ++i) {
  data[i] = function(data[i]);
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]

apply_algorithm(function, &data);

\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Обратите внимание, что код слева написан в виде сырого цикла, где мы руками бежим по элементам, руками применяем функцию \verb"function" к каждому элементу, и руками складываем результат в ту же ячейку вектора.
Справа же код более высокого уровня, потому что мы просто вызываем функцию, которой делегируем решение как именно исполнять алгоритм над данными.

Что плохо -- смешение уровней абстракции.
Любой блок кода всегда должен быть написан на одном уровне абстракции, без смешения этих уровней.

\paragraph{Простая функция \texttt{main}}

Вот пример кода с нарушением уровня абстракции.
\begin{cppcode}
int main() {
  auto data = read();
  vector<int> result (data.size());
  for (size_t i = 0; i < data.size(); ++i)
    result[i] = f(data[i]);
  print(result);
  return 0;
}
\end{cppcode}
Мы видим, что строки~2 и~6 -- это делегирование высокоуровневой работы другим функциям.
Но в то же время в строках с~3 по~5 идет низкоуровневая работа по построению результата.
Для изменения уровня абстракции, проще поднять уровень абстракции у секции с 3 по 5 строки выделением их в функцию:
\begin{cppcode}
int main() {
  auto data = read();
  vector<int> result = apply_algorithm(data);
  print(result);
  return 0;
}
\end{cppcode}
Обратите внимание как теперь выглядит функция \verb"main".
Теперь все строки кода на одном уровне: мы в начале читаем данные, потом обрабатываем данные и получаем результат, потом печатаем результат.
Нужны детали -- смотрим в имплементацию каждой функции.

\paragraph{Измерение времени}

Давайте еще раз посмотрим на пример из раздела~\ref{section::TimeEstimation}.
\begin{cppcode}
void f(int, double);

int main() {
  Time start = Timer.now();
  f(5, 42.);
  Time elapsed = Timer.now() - start;
  return 0;
}
\end{cppcode}
В этом случае строчка~5 -- это делегирование какой-то вычислительной задачи другой функции.
Это высокоуровневая работа.
Измерение времени происходит в строках~4 и~6.
Причем мы руками создаем две переменные, руками находим разность между началом и концом.
Это явно более низкоуровневая работа.
Потому в этом примере происходит нарушение абстракции.
Решить вопрос можно с помощью декораторов из раздела~\ref{section::Decorators}.
Выглядеть это будет как-то так:
\begin{cppcode}
void f(int, double);

int main() {
  measure_time::call<f>(5, 42.);
  return 0;
}
\end{cppcode}


\paragraph{Захват ресурса}

Очень частая проблема -- захват ресурса.
Например, если вы хотите защитить данные для много поточки мьютексом вы можете написать что-то такое
\begin{cppcode}
void function() {
  Data d = read_data();
  Header h = compose_header();
  std::scoped_lock(mutex); // too low level
  write_to_file(h, d);
}
\end{cppcode}
Если посмотреть на функцию выше, то мы видим, что строки~2, 3 и~5 -- это делегирование работы другим функциям.
Это код высокого уровня.
Однако, в строке~4 идет супер низкоуровневая операция -- захват мьютекса.
Это явно нарушение уровня абстракции.
В бизнеслогике вообще не должны фигурировать всякие низкоуровневые детали имплементации.
Вам все равно что там надо залочить на уровне железа, на уровне функции \verb"function" все что нас интересует -- мы хотим безопасно записать данные в файл.
Потому правильно будет либо создать отдельную функцию \verb"write_to_file_safely" либо воспользоваться декораторами как написано в разделе~\ref{section::Decorators}.
Вот как будет выглядеть исправленное решение:
\begin{cppcode}
void function() {
  Data d = read_data();
  Header h = compose_header();
  write_to_file_safely(h, d);
}
\end{cppcode}
Вопрос выбора имен -- это разумеется отдельная проблема, но зато теперь весь код написан на одном уровне абстракции.

\subsection{Уровни доступа}
\label{section::AccessLevels}

Давайте посмотрим на следующий пример
\begin{cppcode}
A a;
int x = a.b.f();
int y = a.b.c.g();
a.d.h(x, y);
\end{cppcode}
Обратите внимание, что мы создали объект класса \verb"A" и хотим с ним работать.
Мы хотим получить из него две целочисленные переменные \verb"x" и \verb"y" и потом их передать опять объекту типа \verb"A".
Однако, мы вместо использования методов класса \verb"A" стучимся в подъобъекты.
Это означает, что класс \verb"A" не содержит нужных методов для работы с ним, отчего приходится стучаться в его кишки.
Вместо этого надо в классе \verb"A" пробросить соответствующие методы
\begin{cppcode}
class A {
public:
  int f() const {
    return b.f();
  }
  int g() const {
    return b.c.g(); // BAD
  }
  void h(int x, int y) {
    d.h(x, y);
  }
private:
  B b;
  D d;
};
\end{cppcode}
Вот так уже лучше, но строчка~7 -- это тоже нарушение уровня доступа.
Теперь уже объект класса \verb"B" не предоставляет нужные методы для работы с ним, а потому надо метод \verb"g" пробросить в интерфейс класса \verb"B", чтоб написать так
\begin{cppcode}
int g() const {
  return b.g();
}
\end{cppcode}
После чего использование класса \verb"A" становится простым и понятным
\begin{cppcode}
A a;
int x = a.f();
int y = a.g();
a.h(x, y);
\end{cppcode}
Обратите внимание, что есть паттерн Builder (разобранный в разделе~\ref{section::Builder}), который наоборот использует вызовы вида
\begin{cppcode}
Builder b;
b.input(3).addLinear(5).add(Sigmoid).addLinear(2).add(ReLu);
Network n = b.extract();
\end{cppcode}
Такой подход вызова команд друг за другом называется Chaining.
Его использование нисколько не противоречит правилу про уровень доступа, потому что вы просто хотите на одном объекте вызвать много методов друг за другом.
Это просто другой стиль использования плюсового синтаксиса.

\subsection{Не сваливать все в кучу}
\label{section::SeparateStuff}

Это очень общее замечание, которое по сути говорит, что не надо плодить супер здоровые сущности, а именно:
\begin{enumerate}
\item Не пишите очень большие файлы.
Если получается слишком много, значит это скорее всего можно декомпозировать на более компактные компоненты.

\item Не пишите очень длинные функции.
Если вы пишите слишком большую функцию, скорее всего она состоит из кучи разной работы, которую можно делегировать.
Название функции должно в точности отражать ту работу, которую она делает.

\item Не пишите слишком большие классы, которые делают все на свете (см. пример про \verb"std::string" в следующем разделе).
Если у вас класс начинает делать слишком много, то скорее всего он начинает делать лишнюю работу.
А значит всю эту работу надо кому-то делегировать.
\end{enumerate}
Все эти соображения растут из того, что мы хорошо понимаем короткие куски кода состоящие из простых операций.
Это позволяет нам убедиться, что все работает корректно и как мы ожидаем.
И важно, что под <<простая операция>> не имеется в виду простая операция в терминах языка.
Это может быть сколь угодно сложный кусок кода, который снаружи выглядит как одна строчка или один простой вызов.
Если про каждую операцию вы знаете ее ожидаемое поведение и операций не много, вы можете проверить, что короткий кусок кода работает корректно.
Не возможно поддерживать спагетти-код или супер больших монстров, в которых все связано со всем.

\subsection{Не размазывайте код}

При желании не сваливать все в кучу, есть противоположная сторона -- делить все до тех пор, пока это можно сделать.
Но это тоже плохая вещь, потому что тогда, синтаксические единицы кода не могут вмещать содержательную работу.
Я бы сформулировал следующие три правила.
\begin{enumerate}
\item Не пишите слишком много мелких файлов.

\item Не пишите слишком много мелких функций.

\item Не пишите слишком много мелких классов, которые почти ничего не делают.
\end{enumerate}
Это другой пример раздутия кода, когда все на столько микроскопически мелкое, что содержательная работа не помещается целиком в один файл/функцию/класс.
Это размазывает содержательную работу по разным компонентам кода.
Важно чтобы код соответствовал логике, которая у вас в голове.
Это другая версия спагетти-кода.

\subsection{Не своя работа}
\label{section::WrongWork}

Тут я хочу обсудить пару примеров.

\paragraph{Чтение из файла}

Пусть у вас есть класс \verb"Picture", который некоторым образом работает с изображением.
Теперь вы хотите добавить возможность читать картинки из файла и писать их в файл.
Часто вижу, как люди добавляют конструкторы и функции записи так:
\begin{cppcode}
class Picture {
public:
  Picture(std::filesystem::path file);
  void write(std::filesystem::path file);
  ...
  /*public interface*/
private:
  /*Implementation*/
};
\end{cppcode}
Проблемы с таким подходом заключаются в том, что внезапно класс \verb"Picture", задача которого обрабатывать, скажем, растровое изображение, начинает разбираться в файловых системах, форматах файлов, парсинге и прочих странных вещах, которые не имеют отношения к его сути.
Особенно эту проблему тяжело заметить, если конструктор и метод записи короткие функции, которые легко имплементировать.
Но так бывает не всегда.
Если вы начинаете добавлять новые форматы, то у вас может получиться такая вот фигня
\begin{cppcode}
class Picture {
public:
  Picture(std::filesystem::path file) {
    switch(format_of(file)) {
      case BMP:
        read_bmp(file);
        break;
      case JPG:
        read_jpg(file);
        break;
        ...
      default:
    }
  }
  void write(std::filesystem::path file);
  ...
  /*public interface*/
private:
  void read_bmp(std::filesystem::path file);
  void read_jpg(std::filesystem::path file);
  ...
  /*Implementation*/
};
\end{cppcode}
И вот тут становится видно, что какого-то черта ваш класс содержит вспомогательные функции, которые не относятся к его сути.
Другой признак, что что-то пошло не так -- список \verb"#include" директив.
Вы увидите, что файл с классом \verb"Picture" почему-то начинает включать в себя совсем не относящиеся к нему заголовочные файлы посвященные файловой системе.

Мы уже обсуждали в разделе~\ref{section::Serialization}, как выносить из класса эту работу.
Но я кратко напомню, что должен быть отдельный класс отвечающий за чтение и запись (может быть два класса: один для чтения, другой для записи).
А для удобства, его вызов можно спрятать в статический метод или глобальную функцию так.
\begin{cppcode}
// some other header
class FileWriter {/*Implementation*/};
class FileReader {/*Implementation*/};

//Picture.h
class Picture {
public:
  ...
  static Picture fromBMP(std::filesystem::path file);
  static Picture fromJPG(std::filesystem::path file);
private:
  /*Implementation*/
};

//Picture.cpp
// includes for FileWriter and FileReader
Picture fromBMP(std::filesystem::path file) {
  FileReader r(file);
  return r.readBMP<Picture>();
}

Picture fromJPG(std::filesystem::path file) {
  FileReader r(file);
  return r.readJPG<Picture>();
}
\end{cppcode}
Так же приимплементации \verb"FileReader" если вам понадобится сложная задача парсинга, то выделите для этого отдельный класс.
Или даже много классов: по одному под каждый формат файла.
Не делайте всю работу в одном месте и сразу, особенно если она вообще не относится к сути класса.

\paragraph{\texttt{std::string}}

Стандартные строки -- это пример плохого класса.
Давайте посмотрим на список методов этого класса, начиная с модифицирующих методов.
\begin{multicols}{3}
\begin{enumerate}
\item \texttt{clear}
\item \texttt{insert}
\item \texttt{insert\_range}
\item \texttt{erase}
\item \texttt{push\_back}
\item \texttt{pop\_back}
\item \texttt{append}
\item \texttt{append\_range}
\item \texttt{operator+=}
\item \texttt{replace}
\item \texttt{replace\_with\_range}
\item \texttt{copy}
\item \texttt{resize}
\item \texttt{resize\_and\_overwrite}
\item \texttt{swap}
\item \texttt{find}
\item \texttt{rfind}
\item \texttt{find\_first\_of}
\item \texttt{find\_first\_not\_of}
\item \texttt{find\_last\_of}
\item \texttt{find\_last\_not\_of}
\item \texttt{compare}
\item \texttt{starts\_with}
\item \texttt{ends\_with}
\item \texttt{contains}
\item \texttt{substr}
\end{enumerate}
\end{multicols}
В особенности мне нравятся последние несколько функций с \verb"find" в названии.
Эти алгоритмы можно вызвать с помощью стандартной библиотеки на любом контейнере.
Зачем они находятся внутри класса строки -- загадка для всех.

\subsection{Плохо продуманные интерфейсы}
\label{section::BadInterfaces}

Важно, чтобы объекты и методы, которые вы пишете, могли удобно друг с другом коммуницировать.
В частности если один метод возвращает данные в каком-то формате, то удобно и другому методы принимать их в таком формате.
Если это не возможно, то значит должен быть промежуточный метод, который делает трансформацию данных.
Или же если один класс пользуется другим для своих целей, то хорошо бы, чтобы в интерфейсе этого другого класса был весь тот функционал, который необходим для использования.
Либо нужный функционал должен быть написан поверх предоставляемого.

\paragraph{Передача данных}

Предположим у вас есть две функции
\begin{cppcode}
struct Vector2D {
  double x;
  double y;
};

Vector2D produce();
void consume(double x, double y);
\end{cppcode}
Обе функции работают с двумерными векторами, но одна функция возвращает вектор как структуру, а другая принимает координаты вектора по-отдельности.
Что придется делать, чтобы передавать данные из одной функции в другую?
Конвертировать
\begin{cppcode}
Vector2D vec = produce();
consume(vec.x, vec.y);
\end{cppcode}
Либо симметричная ситуация
\begin{cppcode}
double produce_x();
double produce_y();
void consume(Vector2D);
\end{cppcode}
Тогда придется писать
\begin{cppcode}
consume(Vector2D{produce_x(), produce_y()});
\end{cppcode}
Проблема в этом случае в том, что один метод выдает данные не в том формате, в котором их ожидает другой метод.
Если вы разрабатывали эти интерфейсы, то вы просто плохо их продумали.
Вы знали, какие у вас есть функции и какие данные надо передавать между ними.
И раз вы их передаете в несовместимом формате, то это вы сами себе усложнили задачу.
В идеале должно быть
\begin{cppcode}
Vector2D produce();
void consume(Vector2D);

Vector2D vec = produce();
consume(vec);
\end{cppcode}
Если же интерфейсы этих функций вы поменять не можете, то вы на самом деле попали в ситуацию проблемы, которая будет адресована в разделе~\ref{section::NotEnoughHats}.
Попросту говоря, вам надо создать новую функцию, с нужным интерфейсом, которая будет внутри себя делать конвертацию и потом вызывать уже функцию с неудобным интерфейсом.
Такая функция называется адаптером.
Про адаптеры и фасады подробнее написано в разделе~\ref{section::AdaptorsFacades}.

\paragraph{Интерфейс класса}

Мой любимый пример -- пример из STL, а именно имплементация \verb"std::vector".
А точнее метод \verb"size".
Кто писал такой код
\begin{cppcode}
std::vector<int> vec = { ... };
for (int i = 0; i < vec.size(); ++i)
  vec[i] = ...;
\end{cppcode}
тот знает мою боль.
Дело в том, что в цикле \verb"for" происходит сравнение знакового \verb"i" и без знакового \verb"vec.size()".
Так лучше не делать, можно легко добиться UB смешивая знаковые и без знаковые типы.
Поэтому в C++20 даже добавили \verb"ssize", которая возвращает знаковое значение для размера вектора.
Я считаю это успех.

\subsection{Люди носят не достаточное количество шляп}
\label{section::NotEnoughHats}

Я думаю, что стоит начать с пояснения названия раздела.
Это название я взял из \href{https://youtu.be/glYq-dvgby4?si=NCKw80I6LdvJx4OR}{доклада} Tony Van Eerd <<SOLID, Revisited>>.
Его можно было сформулировать так: <<люди используют недостаточное количество функций>>.
Это значит, что какую-то работу, которую можно было погрузить в отдельную функцию, делают на месте руками, что усложняет код и работу с ним.
Я бы не стал ограничиваться в этом тезисе только функциями и сформулировал бы это более обще так.
Мы в коде часто делаем следующие ошибки:
\begin{enumerate}
\item Не вводим переменную для хранения некоторого промежуточного значения.
Это очень частая проблема у новичков в программировании.
И если вы программируете уже давно, то скорее всего с этой проблемой даже не сталкиваетесь.
Вот пример, который приходит из воспоминаний о том, как мои дети учились в школе программированию.
Им надо было считать значения ребер прямоугольника и распечатать его площадь и периметр.
Вот как это пишут дети
\begin{cppcode}
double x;
double y;
std::cin >> x;
std::cin >> y;
std::cout << "P = " << 2 * x + 2 * y << '\n';
std::cout << "S = " << x * y << '\n';
\end{cppcode}
В данном случае в последних двух строчках мы логически делаем две вещи: и содержательную работу по вычислению значения и работу по отображению этой работы пользователю.
В мелких проектах это не страшно, то куда разумнее кажется сделать так:
\begin{cppcode}
double x;
double y;
std::cin >> x;
std::cin >> y;
double P = 2 * x + 2 * y;
double S = x * y;
std::cout << "P = " << P << '\n';
std::cout << "S = " << S << '\n';
\end{cppcode}

\item Мы не вводим функции для выполнения вспомогательных работ.
Вот пример который мне приходит в голову.
В этом куске кода надо перемешать столбцы матрицы и для этого нужно предоставить вектор с перемешанными индексами.
\begin{cppcode}
Matrix m = ... ;

std::vector<int> indices;
indices.reserve(m.size());
for (int i = 0; i < m.size(); ++i)
  incides.push_back(i);

std::mt19937 generator = 42;
std::shuffle(indices.begin(), indices.end(), generator);

m.shuffle(incides);
\end{cppcode}
В этом коде много чего плохо.
Мы в строках~3-6 мы видим нарушение уровня абстракции.
В этой части все что мы хотим сделать -- создать вектор индексов от $0$ до $n-1$.
Это должно делаться в одну строчку вызовом одной функции, которую надо написать так/
\begin{cppcode}
std::vector<int> make_indices(int n) {
  std::vector<int> indices;
  indices.reserve(n);
  for (int i = 0; i < n; ++i)
    incides.push_back(i);
  return indices;
}
\end{cppcode}
Теперь код превращается в
\begin{cppcode}
Matrix m = ... ;

std::vector<int> indices  = make_indices(m.size());

std::mt19937 generator = 42;
std::shuffle(indices.begin(), indices.end(), generator);

m.shuffle(incides);
\end{cppcode}
Кроме того, благодаря NRVO объект \verb"indices" будет создан прямо по адресу возвращаемого объекта.
А потому это вам ничего не стоит при исполнении.
Теперь в строках~5-6 мы хотим просто перемешать элементы этого массива.
Мы не хотим тут задавать генератор, не хотим специфицировать как именно мы хотим это делать.
Это все мы хотим инкапсюлировать тоже.
Однако, тут у нас появляется состояние в виде инициализрующего сида.
Тут важно сказать, что никогда НЕ инициализируйте случайным сидом, потому что это дает вам невоспроизводимое окружение.
Если вы поймали баг, то вы его потом не сможете воспроизвести.
Передавать сид не имеет смысла, так как это будет по сути делать каждый вызов функции детерминированным, и вся случайность будет перенесена в выбор сида.
Потому я просто иницилизирую глобальную переменную спрятанную внутри функции, то есть статическую переменную в функции.
По-хорошему, надо спрятать все это в класс \verb"Random", который умеет помнить свое состояние.
Но тут я пойду простым путем.
\begin{cppcode}
std::vector<int> shuffle(std::vector<int>&& data) {
  static std::mt19937 generator = 42;
  std::shuffle(data.begin(), data.end(), generator);
  return data;
}
\end{cppcode}
После чего код превращается в
\begin{cppcode}
Matrix m = ... ;

std::vector<int> indices  = make_indices(m.size());
indices = shuffle(std::move(indices));

m.shuffle(incides);
\end{cppcode}
Ну и наконец-то в этом месте все что мы хотим сделать -- перемешать столбцы матрицы.
И нам не то чтобы важен массив индексов \verb"indices", потому что это лишь вспомогательные данные, которые нам приходится строить из-за того, что библиотека для работы с матрицами предоставляет такой интерфейс.
Давайте просто сделаем нужную функцию, которая будет делать то, что нам надо.
\begin{cppcode}
Matrix shuffle(Matrix&& matrix) {
  std::vector<int> indices  = make_indices(matrix.size());
  indices = shuffle(std::move(indices));
  matrix.shuffle(incides);
  return matrix;
}
\end{cppcode}
И теперь наш код превращается в
\begin{cppcode}
Matrix m = ... ;
m = shuffle(std::move(m));
\end{cppcode}
В конце хочу добавить небольшое замечание.
Можно было бы делать перемешивающие методы с помощью out параметров.
\begin{cppcode}
void shuffle(Matrix* matrix) {
  std::vector<int> indices  = make_indices(matrix->size());
  indices = shuffle(std::move(indices));
  matrix->shuffle(incides);
}
\end{cppcode}
И звать  код вида
\begin{cppcode}
Matrix m = ... ;
shuffle(&m);
\end{cppcode}
Это тоже вариант и до появления move семантики это был единственный эффективный способ не копировать данные.
Сейчас я предпочитаю использовать \verb"std::move", чтобы был явно виден поток данных.
Но это не принципиально.

\item Мы не вводим класс для выполнения вспомогательной работы.
Один из лучших примеров, который я знаю -- это имплементация \verb"std::vector".
Большинство пытаются имплементировать \verb"std::vector" напрямую следующим образом/
\begin{cppcode}
template<class T>
class vector {
public:
  ...
private:
  T* data_ = nullptr;
  size_t size_ = 0;
};
\end{cppcode}
Что не очевидно, так это то, что в этом случае вектор будет делать менеджмент сразу двух ресурсов:
\begin{enumerate}
\item Сырая память, которую надо выделять и удалять на куче.

\item Объекты, размещенные в сырой памяти.
\end{enumerate}
Так вот правильно ввести отдельный класс \verb"buffer", который будет заниматься менеджментом сырой памяти, а сам \verb"vector" будет только отвечать за размещение объектов в памяти.
\begin{cppcode}
template<class T>
class buffer {
public:
  ...
private:
  T* data_ = nullptr;
  size_t size_ = 0;
};

template<class T>
class vector {
public:
  ...
private:
  buffer<T> buffer_;
};
\end{cppcode}
Почему это важно.
Когда вы будете создавать вектор из $n$ объектов, то у вас есть две точки бросания исключений
\begin{enumerate}
\item Выделение сырой памяти.

\item Размещение объекта в сырой памяти посредством placement \verb"new" оператора.
\end{enumerate}
Так вот, если брошено исключение на втором этапе, то вам надо во-первых, удалить все уже построенные объекты, а потом еще и почистить сырую память.
Попытки сделать это одним классом порождают жуткую мешанину из \verb"try"/\verb"catch" блоков в коде.
Это не значит, что вы не сможете написать так вектор.
Но будет сложнее написать его верно, еще сложнее проверить, что оно верное и еще на много более сложная задача -- убедить окружающих в этом.
\end{enumerate}

\subsection{Комментарии}

Комментарии в коде -- это почти всегда плохо.
Чаще всего если вам нужны комментарии -- ваш код не достаточно выразительный и надо не писать комментарии, а переписывать код.
Проблема комментариев в том, что их не читают программисты и их не понимают компиляторы.
А еще комментарии могут не обновляться вовремя и тогда они начинают врать.

\paragraph{Сложные условия}

Одна из самых частых ситуаций -- сложные условия внутри \verb"if" блока.
В этом случае хочется помочь пользователю и добавить комментарий, поясняющий, что же мы проверяем.
Например
\begin{cppcode}
Point p = ... ;
Box b = ... ;
...
// check if p is in the box
if (p.x >= b.leftdown.x && p.x <= b.rightup.y && p.y >= b.leftdown.y && p.y <= b.rightup.y) {
  ...
}
\end{cppcode}
В этом случае вместо комментария нужно создать нормальную функцию, чье имя будет говорить, что вы проверяете
\begin{cppcode}
bool is_in_box(Point p, Box b) {
  return p.x >= b.leftdown.x && p.x <= b.rightup.y && p.y >= b.leftdown.y && p.y <= b.rightup.y;
}
// Then the previous code:
Point p = ... ;
Box b = ... ;
...
if (is_in_box(p, b)) {
  ...
}
\end{cppcode}
И комментарий больше не нужен.

\paragraph{Разделение функции на блоки}

Другая ситуация, когда у вас длинная функция имеет несколько различных логических блоков и вы хотите отделить один от другого с пояснениями зачем этот блок нужен.
\begin{cppcode}
F algorith(const A& a, const B& b, const C&c) {
  // Convert data to required format
  D d;
  for (const auto& v : a.data()) {
    d.add(v);
  }
  
  //Merge b and c together
  E e;
  for (const auto& x : b.data()) {
    for (const auto& y : c.data()) {
      e.add(merge(x, y));
    }
  }
  
  // Merge e with d;
  F f;
  for (const auto& x : e.data()) {
    for (const auto& y : d.data()) {
      f.add(merge(x, y));
    }
  }
  return f;
}
\end{cppcode}
Содержание кода выше не имеет значение.
Важно, что наша функция поделена внутри на три логических блока.
И мы их даже честно прокомментировали.
Но намного лучше будет выделить блоки с комментариями в функции.
\begin{cppcode}
F algorith(const A& a, const B& b, const C&c) {
  D d = convert(a);
  E e = merge(b, c);
  F f = merge(e, d);
  return f;
}
\end{cppcode}
И уже внутри этих функций вы имплементируете каждую стадию.
Теперь это разделение на части видит не только программист, то и компилятор.
И не надо словами объяснять, что делает код.

\paragraph{Общий принцип, когда не нужны комментарии}

Примеры выше призваны показать важный принцип -- никогда НЕ поясняйте словами, что делает код.
Потому что по коду и так ясно что он делает.
Не в том смысле, что это обязательно очевидно, а в том смысле, что компилятор только по коду без ваших комментариев сделает машинный код, который делает конкретную работу.
А потому если ваш код не очевиден, то надо не комментировать, а переписывать.

\paragraph{Примеры, когда комментарии нужны}

Есть несколько ситуаций, когда комментарии действительно в коде нужны и важны.
\begin{enumerate}
\item Пояснение решений, которые были сделаны, когда решалось как будет писаться код.
Вот конкретный пример.
Предположим у вас в проекте есть требования по написанию кода, но при тестировании критической для производительности функции вы выяснили, что написанный по этим правилам код не укладывается в требования по производительности.
Тогда вы только внутренность нужной функции пишете так, чтобы она укладывалась в требования.
Добавляете хаки, трюки и прочие грязные приемы.
Теперь, когда ваш коллега придет работать над проектом, увидев именно эту функцию, он сильно удивится.
И скорее всего даже захочет переписать данную функцию в соответствии с требованиями проекта.
В таких случаях надо снабжать данную функцию комментариям перед ее объявлением, где вы поясняете причины, почему функция написана так.
Что без костылей вы не могли достичь нужной производительности.

\item Когда вы имплементируете алгоритм из конкретной статьи и используете обозначения этой статьи, то очень полезно перед объявлением функции добавить комментарий поясняющий весь контекст.
Что вообще дано, какие данные, что они значат.
Что делает функция, какие данные для чего используются и прочие важные детали.
Так же полезно добавить ссылку на статью.

\item Если вы пишите какой-то библиотечный код, который будет часто использоваться в проекте.
То имеет смысл написать инструкцию с примерами, как этим кодом пользоваться, чтобы пользователи понимали, как вы предполагали использовать данный библиотечный код и не ломали голову, почему что-то не компилируется.
Пояснение всяких тонких деталей.
\end{enumerate}

\subsection{Не обеспечена семантика класса}

Это более или менее техническая деталь.
Семантику мы подробно обсуждали в разделе~\ref{section::Semantics}.
Семантика любого класса обеспечивается обычно генерируемыми автоматически методами.
\begin{cppcode}
class A {
public:
  A();
  A(const A&);
  A(A&&) noexcept;
  A& operator=(const A&);
  A& operator=(A&&) noexcept;
  ~A();
};
\end{cppcode}
Если все поля класса имеют value semantics, то ничего кроме конструкторов для построения объекта вам не нужно.
Однако, если объект внутри собран скажем из указателей (красно-черное дерево для примера), то снаружи вам нужно обеспечить ему корректное поведение при операциям перемещения и копирования.
Это надо не забывать.
Потому что, когда вы имплементируете методы объекта, вы обычно думаете, что он прибит гвоздями к одному месту в памяти.
Однако, это не обязательно так и нужно поддержать нужное поведение.
Это все подробно обсуждалось в разделе~\ref{section::Classes}.
