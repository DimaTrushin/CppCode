\ProvidesFile{BadCode.tex}[Признаки плохого кода]


\section{Признаки хорошего и плохого кода}
% TO DO

\subsection{Общие слова}

Вы скорее всего встретите много разных советов, что в коде хорошо, а что плохо.
И с большой вероятностью все эти правила буду противоречить друг другу.
Потому очень важно понимать как к этому относиться.
Ситуация с кодом очень похожа на ситуацию со скоростными ограничениями на дороге.
Плохая идея гонять по городу $110$, в то же время плохая идея ехать по трассе $60$.
Главная мысль в том, что все сильно зависит от ситуации и обстоятельств.
Чтобы хоть как-то пояснить это я хочу начать с примера.

\paragraph{Олимпиадное программирование}

Вы когда-нибудь смотрели посылки на codeforces?
Вы видели какое безобразие люди пишут в коде?
Вот один из примеров.
\begin{cppcode}
#define int long long
\end{cppcode}
А теперь вопрос: хорошо это или плохо?
Раз топовые участники codeforces так пишут, то видимо хорошо.
Однако, в то же время топовые программисты со всего мира рассказывают вам, что ни в коем случае так писать нельзя.
Возникает вопрос, почему в олимпиадном программировании так писать хорошо, а в промышленном программировании плохо.
Дело в том, что задача олимпиадного программиста максимально быстро написать программу, которая продет все тесты системы и все.
После этого код никогда не используется, он выкидывается на помойку и про него никто не вспоминает.
Его не надо поддерживать, его не надо модифицировать, его вообще не надо даже вспоминать.
А потому любые трюки, которые позволяют что-либо сделать быстрее -- это хорошо.
В частности вместо того, чтобы везде менять int на long long и получить ошибку от того, что вы где-то это забыли сделать, можно просто воспользоваться препроцессором.

С другой стороны в промышленном коде подобные трюки плохи, потому что они мешают поддерживать код.
Основная проблема с этим макросом, что он меняет код где угодно после него.
И тогда код который видит программист и который видит компилятор -- это два разных кода.
А это значит, что код начинает врать программисту.
Это не локальное изменение, которое тяжело обслуживать.

\paragraph{Математика и алгоритмы}

Есть хорошее правило, что размер функций должен быть не большим, чтобы можно было понять, что функция делает.
Что переменные должны иметь нормальные имена, чтобы было понятно, что они делают.
Что не должно быть больше $3$ вложенных scope, чтобы не было спагетти кода.
Все это хорошо, но вот вы начинаете писать какой-то известный алгоритм.
Предположим в этом алгоритме используются обозначения для времени, координаты, скорости, массы и импульса $t$, $x$, $v$, $m$ и $p$, соответственно.
Теперь сравните два кода
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
x = v * t;
p = m * v;
E = 1/2 * m * v * v;
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
coordinate = velocity * time;
impulse = mass * velocity;
Energy = 1/2 * mass * velocity * velocity;
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Обратите внимание на сколько тяжелее читать код справа, хотя мы дали всем переменным говорящие имена.
Тут есть две проблемы:
\begin{enumerate}
\item Имена справа не привычные, а обозначения слева нам более привычны.

\item Имена справа врут.
Дело в том, что переменная \verb"time" не ясно какое именно время обозначает.
То есть мы вроде уточнили, что \verb"t" это время, но вот время от какого момента до какого, не уточнили.
Или \verb"Energy" справа -- это все таки кинетическая энергия, а не просто какая-то энергия.
И усложнять эти имена до длинных предложений не имеет смысла.
\end{enumerate}
Аналогичная проблема с именами в математических алгоритмах или в имплементации структур данных.
Часто авторы статей используют для обозначений короткие обозначения, которые облегчают понимание алгоритма.
Разумно так и записать алгоритм, а перед этим алгоритмом добавить пояснения для всех переменных, которые присутствуют в статье.

Сюда же я хочу добавить замечания по поводу размеров функций и количества вложенных scope.
Так часто бывает, что какой-нибудь сложный алгоритм может содержать $4$ вложенных цикла.
И он не бьется никаким разумным образом на подфункции, в которые можно было бы спрятать внутренние циклы или как-то разбить его на логические части.

Я хочу сказать, что в подобных ситуациях нет смысла пытаться подогнать ваш код под какие-то специфические правила.
Вы можете ухудшить читаемость кода и/или его производительность.
И причина почему вы можете себе это позволить -- вы этот алгоритм пишете один раз.
Вы точно знаете, что он так работает корректно и никогда не будете его модифицировать.
В худшем случае, вы имплементируете новый алгоритм из другой статьи.
А потому лучше для понимания, чтобы код был близок к статье, по которой вы его пишете.

\paragraph{Масштабы проекта}

Вы можете прочитать кучу разных теорий о том как писать то или иное приложение, о разных подходах к архитектуре или прочие тонкости.
Однако, не всегда следует применять все что вы видите, только потому что это было создано для вашей ситуации.
Все сильно зависит от масштабов вашего проекта.
Если проект маленький, то нет смысла в него внедрять сложные конструкции или парадигмы.
Не занимайтесь Over Engeneering.
Вот пример, который мне часто приходится видеть на проектах.
Ребята имплементируют 3D Renderer с нуля и используя его пишут интерактивное приложение, которое демонстрирует возможности движка.
Схема потока данных в интерактивном приложении следующая
\[
\xymatrix{
  {}&{\text{World}}\ar[dr]&{}&{}&{}&{}\\
  {\text{Input}}\ar[r]&{\text{Camera}}\ar[r]&{\text{Renderer}}\ar[r]&{\text{Picture}}\ar[r]&{\text{Screen}}&{}\\
  {}&{\text{Lights}}\ar[ur]&{}&{}&{}&{}\\
}
\]
Для такой простой схемы, можно даже не городить никакую Message Driven System, не использовать MVC или другие паттерны.
Весь код можно засунуть целиком в цикл обработчик событий.
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
class Application {
public:
  Application(); // initializes resources
  
  void run(); // run event loop
private:
  auto read_user_input();

  World world_;
  Camera camera_;
  Lights lights_;
  Renderer renderer_;
  Screen screen_;
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
Application::Application() {
  /*Initialization*/
}
void Application::run() {
  ...
  /*somewhere in event loop*/
  auto action = read_user_input();
  camera_.move(action);
  Picture picture = renderer.make(world_,
                                  camera_,
                                  lights_);
  screen_.draw(picture);
  ...
}
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Заметьте, что нет необходимости делить код на ядро, и другие компоненты.
Все хранится непосредственно в классе приложения.
И вы просто друг за другом передаете данные от одного объекта другому, как и требуется.
В этой простой ситуации нет необходимости использовать межобъектную коммуникацию или какие-то сложные паттерны.
Вы даже можете не использовать event loop, вы можете просто крутиться в бесконечном цикле и опрашивать клавиатуру.
Нужно только защититься таймером, чтобы цикл не проходил слишком быстро и все.

Недостаток такого подхода -- его не возможно масштабировать.
Но если вам надо начать масштабировать это решение, то вы можете стартовать с кода выше.
У вас уже есть в готовые работающие компоненты и теперь лишь надо распилить \verb"Application" и соединить его компоненты  друг с другом в соответствии с MVC.
То есть вы делаете эту работу тогда, когда она нужна, а не заранее, когда вы даже не знаете нужно это или нет.

\paragraph{Идеал и реальность}

Есть хороший вопрос: как понять, когда что-то надо использовать или нет.
Есть по сути три простых ситуации
\begin{enumerate}
\item Вы знаете что в данной ситуации надо использовать и умеете это имплементировать.
Например, вы знаете, что лучше использовать \verb"std::vector" из-за локальности в памяти данных.
Или вы умеете имплементировать поиск за $O(\log(n))$ или $O(1)$ с помощью соответствующей структуры данных и вы знаете, что вам это нужно.
Ну значит так и делайте.
Раз вы знаете, что это тут нужно и умеете, то глупо этого не делать.

\item Вы не знаете, что в данной ситуации надо использовать.
Тут все проще, вы даже не поймете, что у вас была такая ситуация.
Либо если вы задумаетесь над ней, то это повод что-то почитать и изучить.

\item Вы знаете, что в данной ситуации надо использовать, но не умеете это имплементировать.
Вот тут ситуация интереснее.
Вы можете поступить двумя способами
\begin{enumerate}
\item Имплементировать как получится и как вы умеете.

\item Изучить, что в этом случае люди делают.
\end{enumerate}
И тут все зависит от ваших ресурсов.Если вы ограничены
 во времени и ресурсах, то намного проще и правильнее  будет имплементировать как получится.
Очень может оказаться, что оно и так сойдет, что не оказывается тут нет никакого узкого горлышка и все и так работает.
Вы сэкономите время и силы на то, что не потратите его на ненужную работу.
Во втором подходе есть так же проблема в том, что вам без опыта и понимания надо как-то понять какое из предлагаемых решений вам действительно нужно и какое из них действительно хорошо.
И часто вы просто придете к тому, что надо было просто имплементировать как есть.
\end{enumerate}
От себя хочу добавить, что работая над проектом анализа качества печати в одиночку, я часто встречался с ситуацией, что есть какая-то второстепенная деталь в проекте, которую надо имплементировать и без нее нельзя продвинуться дальше в содержательных вопросах.
И я понятия не имел как это делать.
И каждый раз решение -- сделать как-то было самым правильным.
Оно сохраняло время, силы и желание работать над важной частью проекта.
Чем опытнее вы будете становиться, тем больше у вас будет понимания, а как теперь надо писать проект.

\subsection{Локальность}
\label{section::Locality}

Local Reasoning или возможность делать выводы по небольшому куску кода -- очень важное свойство.
Давайте я поделюсь тут некоторым философским замечанием.
Я знаю, что в среде программистов не особенно принято доказывать, что их программа работает корректно.
Мы просто пишем код.
Потом смотрим, кто на него ругается.
Если ругается компилятор -- исправляем на что ругается.
Если ругаются тесты -- исправляем на что ругается.
Если ругается начальник -- исправляем на что ругается.
Все работа выполнена.
При таком подходе не возможно ничего гарантировать.
И вот тут я бы сравнил написание программ с написанием математических статей.
Математические статьи оперируют куда более сложными конструкциями, чем проекты в индустрии.
Однако, если вы почитаете хорошие статьи в них нет ошибок.
Это не просто привычка писать текст и проверять себя, просто на дисциплине такое держать сложно.
Один из важных инструментов -- Local Reasoning.
Мы разбиваем сложное утверждение на маленькие утверждения, чьи доказательства проверить на корректность легко.
А потом собираем все из кусочков так, чтобы ошибке некуда было закрасться.
У профессиональных математиков этого достаточно чтобы гарантировать отсутствие ошибок (хотя не на 100\% как показывает практика).
Однако, даже в этом вопросе программисты пошли другим путем.
Есть специальные языки программирования, которые позволяют проверить корректность работы программы.
И если она не корректная, то вам на это ругнется компилятор, а если он не ругнулся, то значит проблем нет, это гарантируется.
Это очень здорово на самом деле и жаль, что такие инструменты мало распространены и не всегда ими удобно пользоваться.
А теперь давайте перейдем все таки от философии к делу.


Вся идея написания большого и сложного программного проекта -- разбить его на независимые части поменьше, обозначить четкие границы и правила взаимодействия между ними сквозь эти границы.
А дальше мы применяем это правило рекурсивно, бьем полученные компоненты на меньшие части и так далее.
Отсюда сразу становится понятно почему важна value semantics.
Наличие ссылок и указателей в данных или в объектах друг на друга (если только это не специальный паттерн) -- это всегда большая проблема для локальности.
Например
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
class A {
public:
  ...
  void f(int);
  void g(int);
private:
  B* b_;
  int data_;
};
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
class B {
public:
  ...
  void h(int);
  void w(int);
private:
  A* a_;
  int data_;
};
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Как мы видим выше у нас два класса и каждый из них хранит указатель на другой.
Тут важно понимать, что это не значит, что два объекта обязаны хранить указатели друг на друга.
Сырые указатели не спрятанные внутрь шаблона проектирования не дают никаких гарантий.
Теперь, представьте, что внутри метода \verb"A::f" вы дергаете метод \verb"B::h" доступный по указателю \verb"b_".
То есть теперь, чтобы понять, что делает класс \verb"A", вам надо знать, что делает класс \verb"B" и как он коммуницирует с \verb"A".
Но этого мало.
Вам надо держать в голове целый граф из всех возможных объектов класса \verb"A" и \verb"B", потому что они могут ссылаться друг на друга случайным образом.
А еще надо не забыть, что указатель может быть нулевым.
И чтобы написать код корректно, вам придется обрабатывать все возможные ситуации.
Вероятность, что вы это сделаете, почти ноль.
А значит ваш код очень быстро начнет падать на всем подряд.

\paragraph{Ссылки для передачи данных}

В таких ситуациях надо понять зачем вам нужны ссылки и указатели на другие объекты.
Очень часто бывает так, что вам надо передать данные из одного объекта в другой.
Вот пример кода и как его переделать
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
struct A {
  void do_something() {
    int x = make();
    b->do_something(x);
  }
  int make() const;
  B* b;
};

struct B {
  void do_something(int);
};

int main() {
  A a;
  B b;
  a.b = &b;
  a.do_something();  
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
struct A {
  int make() const;
};

struct B {
  void do_something(int);
};






int main() {
  A a;
  B b;
  int x = a.make();
  b.do_something(x);
}
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Как вы видите нет необходимости хранить указатель на другой объект, мы просто получаем данные из \verb"A" и отдаем их \verb"B".
Тут есть одна особенность.
Что эту передачу данных должен кто-то делать.
Если оба объекта лежат в каком-то классе, то за передачу данных отвечает класс.
Если оба объекта являются локальными объектами функции (как в примере выше), то за передачу данных отвечает сама функция.
Это так называемый мастер объект.
Однако, так бывает, что объекты равноправны и не имеют одного мастер объекта, который бы мог передавать данные.
В таких ситуациях надо использовать Observer pattern, который будет описан в разделе~\ref{section::Observer}.
В целом всегда можно организовать любую программу как пайплайн, где объекты поглощают и производят данные, и передача данных между объектами делается посредством Observer pattern-а.
Это не всегда нужно, но там где нужно, это позволяет полностью избавиться от каких-либо ссылок и указателей.

\paragraph{Парные операции}

Еще один пример отсутствия локальности мы видели в разделе~\ref{section::TimeEstimation} посвященному измерению времени.
Давайте посмотрим на вот такой кусок кода
\begin{cppcode}
void f(int, double);

int main() {
  Time start = Timer.now();
  f(5, 42.);
  Time elapsed = Timer.now() - start;
  return 0;
}
\end{cppcode}
Этот код хорош, что в нем сразу несколько проблем.
Но тут же мы видим не локальность.
А именно, мы работу по измерению времени делаем не в одном месте, а сразу в двух строчках~4 и~6.
И на практике эти строчки могут разъехаться очень далеко.
Данную ситуацию можно отнести к случаю, когда у вас есть какие-то парные связанные друг с другом операции, которые должны гарантированно выполняться парами.
Раздел~\ref{section::Decorators} про Декораторы как раз был посвящен тому, как стоит организовывать код в такой ситуации.

\paragraph{\texttt{shared\_ptr}}

Одна из причин, почему я делаю акцент на \texttt{shared\_ptr} на неконстантный объект -- он нарушает локальность.
Два \texttt{shared\_ptr}-а могут быть сколь угодно далеко друг от друга в коде, но при этом ссылаться на одни и те же данные.
Подробнее про это можно почитать в разделе~\ref{section::Dangerous} и~\ref{section::SharedPtr}.

\paragraph{Глобальные данные}

Это еще один пример нарушения локальности.
Наличие глобального состояния у системы может сломать все что угодно.
Любой чих в любой строчке кода может изменить глобальное состояние и все функции могут начать выдавать другой результат из-за этого.
Если вы страдали с тем, чтобы выставить правильно все сиды в рандомных генераторах каких-нибудь крупных фреймворков, чтобы получить воспроизводимость результатов, то вы знаете о чем я говорю.
Тем не менее, бывает, что без глобальных данных не обойтись.
Про примеры и то, как этим пользоваться стоит посмотреть раздел~\ref{section::Singleton}.

\paragraph{Value Semantics}

Одна из причин почему value semantics важная штука -- она улучшает локальность.
Потому что по определению данные в двух разных переменных никогда ни при каких условиях не влияют друг на друга, какой бы ни была имплементация.
Подробнее про семантику можно глянуть в разделе~\ref{section::Semantics}.

\subsection{Явные зависимости}
\label{section::Explicitness}
% TO DO
% Нужны примеры и побольше

Любая программа всегда состоит из двух частей
\begin{enumerate}
\item Данные

\item Методы
\end{enumerate}
Это все можно заворачивать в классы и прочие прелести, но у вас всегда есть данные, над которыми вы работаете, и методы, которые эти данные обрабатывают.

\paragraph{Диаграмма владения}

Когда вы работаете с данными, то очень важно понять какой объект какие другие объекты в себе содержит.
Это позволяет понять зону ответственности объекта и ограничить связанные данные вместе от посторонних.
Полезно перед глазами держать диаграмму владения.
Это граф, у которого вершины -- это объекты и вы проводите ребро из вершины подъобъекта в вершину владеющего объекта.
Либо вы можете это визуализировать в виде вложенных друг в друга боксов.
Если у вас не получается нарисовать такую диаграмму, значит у вас какие-то проблемы.
И часто проблемы связаны с отсутствием value semantics.
В данном случае диаграмма описывает явно зависимости между классами, кто кого содержит.

\paragraph{3D Renderer}

Я вернусь тут к примеру с 3D Renderer-ом с нуля.
Пусть у  нас есть несколько простых компонент в приложении как ниже.
Очень часто вижу приблизительно такой код, где вас должны сильно смутить указатели и отсутствие \verb"Screen".
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]

class Application {
public:
  Application(); // initializes resources
  
  void run(); // run event loop
  
private:

  Camera camera_;
  Lights lights_;
  World world_;
  Renderer renderer_;
};

\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
Application::Application()
  : camera_(initialize_camera()),
    lights_(initialize_lights()),
    world_(initialize_world(),
            &camera,
            &lights_),
    renderer_(600, 800, &world_) {
}
void Application::run() {
  ...
  /*Somewhere in event loop*/
  camera_.move(action)
  renderer_.make();
  ...
}
\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
А потом выясняется вот такая схема владения.
\[
\xymatrix@R=10pt{
{\text{Renderer}}
  	{
	\save
   [].[dd]*+[F-:<3pt>]\frm{}
   \restore
	}
	&{}&{}\\
{\text{Screen}}
  	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
&{}&{}\\
{\text{ptr}}\ar[r]
  	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
&{\text{World}}
  	{
	\save
   [].[ddd]*+++[F-:<3pt>]\frm{}
   \restore
	}
&{}\\
{}&{\text{Objects}}
  	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
&{}\\
{}&{\text{ptr}}\ar[r]
  	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
&{\text{camera}}
  	{
	\save
   [].[]*+[F-:<3pt>]\frm{}
   \restore
	}
\\
{}&{\text{ptr}}\ar[r]
  	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
&{\text{lights}}
  	{
	\save
   [].[]*+[F-:<3pt>]\frm{}
   \restore
	}
\\
}
\]
В частности выясняется, что GUI код находится внутри \verb"Renderer".
И тут сразу становится понятно зачем надо было в \verb"Renderer" передавать размеры окна.
Диаграмма приведенная выше -- это на самом деле еще цветочки.
У меня были ситуации, когда надо было около $4$ часов тщательно изучать код и рисовать сложный граф, содержащий информацию о том, кто на кого содержит какие ссылки, кто реально владеет данными и кто кому как их передает.

Обратите внимание на \verb"run" функцию.
Тут я опустил код, читающий пользовательский ввод, но предположим мы считали данные \verb"action".
А дальше происходит какая-то магия в строчке \verb"renderer_.make()".
Потому что метод \verb"make" ничего не принимает, ничего не возвращает, но тем не менее эта строчка делает все.
С такой диаграммой владения, когда объекты неявно ссылаются друг на друга, у вас всегда есть возможность начать модифицировать состояние чужого объекта внутри своего метода.
А значит вы автоматически начинаете передавать данные неявно.
Это порождает кучу проблем с пониманием потока данных.

\paragraph{Диаграмма потока данных}

Другая полезная информация -- это поток данных между методами.
Просто потому что любое исполнение программы -- это выполнение ее методов: построение данных одними методами, передача этих данных в другие методы и так далее.
Важно не делать скрытых зависимостей и делать передачу данных явно.
Это одна из причин по которой я не люблю всякие ссылки и указатели внутри объектов.
Потому что вы могли передать данные в другой объект внутри метода, а пользователь метода снаружи даже не знает о том, что оказывается там какой-то скрытый метод выстрелил.
У вас всегда должны быть четкие границы между объектами.
Избегайте двустороннего общения между объектами.

\paragraph{Еще раз 3D Renderer}

Давайте вернемся к примеру 3D Renderer-а из начала раздела.
Здесь теперь объекты лежат как надо.
\begin{cppcode}
class Application {
public:
  Application(); // initializes resources
  
  void run(); // run event loop
private:
  auto read_user_input();

  World world_;
  Camera camera_;
  Lights lights_;
  Renderer renderer_;
  Picture picture_;
  Screen screen_;
};
\end{cppcode}
Диаграмма владения очень простая.
Нет никакой необходимости этим объектам знать хоть что-то друг про друга.
Всю информацию, которую нужно передать от одного объекта другому сможет передать \verb"Application" в своих методах.
\[
\xymatrix{
  {\phantom{Aworld}}&{}&{\text{Application}}
    	{
	\save
   [ll].[drrr]*+++[F-:<3pt>]\frm{}
   \restore
	}
  &{}&{}&{}\\
  {\text{world}}
      	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  &{\text{camera}}
        	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  &{\text{lights}}
        	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  &{\text{renderer}}
        	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  &{\text{picture}}
        	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  &{\text{screen}}
        	{
	\save
   [].[]*[F-]\frm{}
   \restore
	}
  \\
}
\]
Но даже в этом случае можно сделать очень плохой поток данных вот такой имплементацией.
\begin{cppcode}
void Application::run() {
  ...
  /*somewhere in event loop*/
  move_camera();
  make_picture();
  draw_picture();
  ...
}
void Application::move_camera() {
  auto action = read_user_input();
  camera_.move(action);
}

vpod Application::make_picture() {
  picture_ = renderer_.make(world_, camera_, lights_);
}

void Application::draw_picture() {
  screen_.draw(picture);
}
\end{cppcode}
Ну а действительно, зачем нам явно подставлять все поля класса в функции, они же видны из любого метода класса.
И у вас в классе появляются методы, которые ничего не принимают и ничего не возвращают, но они делают всю работу.
И вот как понять по коду выше в строках~4-6, откуда и куда текут данные?
Так же обратите внимание, что теперь название метода \verb"move_camera" просто врет программисту.
Дело в том, что этот метод не только двигает камеру, но и читает пользовательский ввод.
Кроме того, теперь мы еще и новую переменную положили в \verb"Application", которая вообще то имеет смысл только локально для передачи данных от \verb"renderer" к \verb"screen" и не отражает состояния приложения.
Это может быть желательно скажете вы, чтобы не переаллоцировать буффер под картинку.
Но это все можно исправить следующим образом.

В начале давайте избавимся от неявных методов только модифицирующих состояние.
\begin{cppcode}
void Application::run() {
  ...
  /*somewhere in event loop*/
  auto action = read_user_input();
  camera_.move(action);
  picture_ = renderer.make(world_, camera_, lights_);
  screen_.draw(picture);
  ...
}
\end{cppcode}
А теперь, чтобы переиспользовать память внутри \verb"picture_" заведем ее локально внутри \verb"run", но будем мувать ее внутрь \verb"make" метода объекта \verb"renderer", чтобы уже он решал может ли он и хочет ли он переиспользовать буффер.
Код будет выглядеть как-то так.
\begin{cppcode}
void Application::run() {
  Picture picture;
  ...
  /*somewhere in event loop*/
  auto action = read_user_input();
  camera_.move(action);
  picture = renderer.make(world_, camera_, lights_, std::move(picture));
  screen_.draw(picture);
  ...
}
\end{cppcode}
И у нас теперь нет необходимости хранить внутри \verb"Application" данные, которые не релевантны для состояния приложения и которые возникают только внутри конкретного метода, и при этом избежать неявного потока данных и переаллокации.
Метод \verb"make" уже проверит можно ли переиспользовать буфер внутри \verb"picture" или нет.

\paragraph{Аргументы ссылки}

Еще один прекрасный источник неявных зависимостей -- принимать аргументы методов по не константной ссылке.
Посмотрите на следующий код.
\begin{cppcode}
int x = 1;
double y = 2.;
char z = 'c';
short r = function(x, y, z);
\end{cppcode}
Вот какое значение вы ожидаете у аргументов после такого вызова?
А функция еще такая умная, возвращает значение, наверное они просто по трем значениям стоит четвертое, ведь так?
А вот ее сигнатура
\begin{cppcode}
short function(int, double&, char);
\end{cppcode}
И у вас нет ни шанса узнать на стороне пользователя, что второй аргумент может меняться.
Для того, чтобы подсказать на стороне пользователя, что аргумент может меняться, обычно принято передавать аргумент по указателю.
В этом случае картина выглядит так
\begin{cppcode}
short function(int, double&, char);

int x = 1;
double y = 2.;
char z = 'c';
short r = function(x, &y, z);
\end{cppcode}
На самом деле такой же походи использует функция \verb"scanf", которая пишет в аргумент ввод пользователя.
Она принимает аргументы по указателю.
Это подсказывает пользователю функции, что аргумент может измениться.
В рамках такого подхода принято разделять аргументы функции на входные и выходные.
\begin{enumerate}
\item Из входных параметров функция читает данные.

\item В выходные параметры функция пишет данные.
Бывает еще что некоторые выходные параметры имеют двойное назначение из них данные и читаются и в них пишутся.
\end{enumerate}
В этом случае принято придерживаться следующих правил:
\begin{enumerate}
\item Все входные параметры идут в начале, а все выходные параметры в конце.

\item Все входные параметры принимаются либо по значению либо по константной ссылке.

\item Все выходные параметры принимаются по указателю.
\end{enumerate}
В соответствии с этими соглашениями предыдущий пример выглядел бы так.
\begin{cppcode}
short function(int, char, double&);

int x = 1;
double y = 2.;
char z = 'c';
short r = function(x, z, &y);
\end{cppcode}
В этом случае возвращаемое значение может содержать код ошибки, если в этом есть необходимость.

\paragraph{Инкапсюляция}

Формально инкапсюляция -- это противник явных зависимостей.
Потому что вы скрываете детали имплементации и не знаете, что внутри происходит.
Тем не менее, это не рассматривается как что-то плохое.
Дело в том, что вы обычно имплементируете класс с требуемым поведением, а потому наличие каких-то зависимостей внутри класса для вас не важно.
Если вы поставили границу так, что класс теперь просто черный ящик с нужным поведением, то у вас все зависимые узлы спрятаны внутри ящика.
А если вы занимаетесь имплементацией ящика, то там конечно не стоит делать неявные зависимости между деталями через ссылки и указателями.
Обращайтесь с данными явно.

\paragraph{Observer pattern}

Есть различные мысли о том почему Observer pattern плох.
Один из аргументов в том, что он ломает явные зависимости: мы отправляем сообщение и не знаем, что там выполнится.
Но я бы не сказал, что это прям беда, это скорее фича этого паттерна.
Но вот бездумное использование указателей и ссылок и вызов через них методов -- это уже проблема для явных зависимостей.

\subsection{Уровни абстракции}
\label{section::AbstractionLevels}

При написании любого кода у вас есть мелкая рутинная работа, может быть прям на уровне машинного кода или вызова интринзиков или ассемблерные вставки и т.д.
А есть код очень высокого уровня, где вы оперируете сложными сущностями вроде \verb"Application", \verb"Scheduler", \verb"Renderer" и тому подобное.
Бывает, что код функций выполняет напрямую арифметические операции, а бывает, что вы вызываете другие функции.
То есть вы всегда находитесь на некоторой абстрактной линейной шкале между машиной и идейной моделью.
И глядя на разный код, можно смело сказать, что один является кодом более высокого уровня, чем другой.
Вот примеры
% TO DO
% Плохой пример. Надо сделать лучше.
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
for (size_t i = 0; i < data.size(); ++i) {
  data[i] = function(data[i]);
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]

apply_algorithm(function, &data);

\end{cppcode}
\end{minipage}
}\\
\end{tabular}
\end{center}
Обратите внимание, что код слева написан в виде сырого цикла, где мы руками бежим по элементам, руками применяем функцию \verb"function" к каждому элементу, и руками складываем результат в ту же ячейку вектора.
Справа же код более высокого уровня, потому что мы просто вызываем функцию, которой делегируем решение как именно исполнять алгоритм над данными.

Что плохо -- смешение уровней абстракции.
Любой блок кода всегда должен быть написан на одном уровне абстракции, без смешения этих уровней.

\paragraph{Простая функция \texttt{main}}

Вот пример кода с нарушением уровня абстракции.
\begin{cppcode}
int main() {
  auto data = read();
  vector<int> result (data.size());
  for (size_t i = 0; i < data.size(); ++i)
    result[i] = f(data[i]);
  print(result);
  return 0;
}
\end{cppcode}
Мы видим, что строки~2 и~6 -- это делегирование высокоуровневой работы другим функциям.
Но в то же время в строках с~3 по~5 идет низкоуровневая работа по построению результата.
Для изменения уровня абстракции, проще поднять уровень абстракции у секции с 3 по 5 строки выделением их в функцию:
\begin{cppcode}
int main() {
  auto data = read();
  vector<int> result = apply_algorithm(data);
  print(result);
  return 0;
}
\end{cppcode}
Обратите внимание как теперь выглядит функция \verb"main".
Теперь все строки кода на одном уровне: мы в начале читаем данные, потом обрабатываем данные и получаем результат, потом печатаем результат.
Нужны детали -- смотрим в имплементацию каждой функции.

\paragraph{Измерение времени}

Давайте еще раз посмотрим на пример из раздела~\ref{section::TimeEstimation}.
\begin{cppcode}
void f(int, double);

int main() {
  Time start = Timer.now();
  f(5, 42.);
  Time elapsed = Timer.now() - start;
  return 0;
}
\end{cppcode}
В этом случае строчка~5 -- это делегирование какой-то вычислительной задачи другой функции.
Это высокоуровневая работа.
Измерение времени происходит в строках~4 и~6.
Причем мы руками создаем две переменные, руками находим разность между началом и концом.
Это явно более низкоуровневая работа.
Потому в этом примере происходит нарушение абстракции.
Решить вопрос можно с помощью декораторов из раздела~\ref{section::Decorators}.
Выглядеть это будет как-то так:
\begin{cppcode}
void f(int, double);

int main() {
  measure_time::call<f>(5, 42.);
  return 0;
}
\end{cppcode}


\paragraph{Захват ресурса}

Очень частая проблема -- захват ресурса.
Например, если вы хотите защитить данные для много поточки мьютексом вы можете написать что-то такое
\begin{cppcode}
void function() {
  Data d = read_data();
  Header h = compose_header();
  std::scoped_lock(mutex); // too low level
  write_to_file(h, d);
}
\end{cppcode}
Если посмотреть на функцию выше, то мы видим, что строки~2, 3 и~5 -- это делегирование работы другим функциям.
Это код высокого уровня.
Однако, в строке~4 идет супер низкоуровневая операция -- захват мьютекса.
Это явно нарушение уровня абстракции.
В бизнеслогике вообще не должны фигурировать всякие низкоуровневые детали имплементации.
Вам все равно что там надо залочить на уровне железа, на уровне функции \verb"function" все что нас интересует -- мы хотим безопасно записать данные в файл.
Потому правильно будет либо создать отдельную функцию \verb"write_to_file_safely" либо воспользоваться декораторами как написано в разделе~\ref{section::Decorators}.
Вот как будет выглядеть исправленное решение:
\begin{cppcode}
void function() {
  Data d = read_data();
  Header h = compose_header();
  write_to_file_safely(h, d);
}
\end{cppcode}
Вопрос выбора имен -- это разумеется отдельная проблема, но зато теперь весь код написан на одном уровне абстракции.

\subsection{Уровни доступа}
\label{section::AccessLevels}

Давайте посмотрим на следующий пример
\begin{cppcode}
A a;
int x = a.b.f();
int y = a.b.c.g();
a.d.h(x, y);
\end{cppcode}
Обратите внимание, что мы создали объект класса \verb"A" и хотим с ним работать.
Мы хотим получить из него две целочисленные переменные \verb"x" и \verb"y" и потом их передать опять объекту типа \verb"A".
Однако, мы вместо использования методов класса \verb"A" стучимся в подъобъекты.
Это означает, что класс \verb"A" не содержит нужных методов для работы с ним, отчего приходится стучаться в его кишки.
Вместо этого надо в классе \verb"A" пробросить соответствующие методы
\begin{cppcode}
class A {
public:
  int f() const {
    return b.f();
  }
  int g() const {
    return b.c.g(); // BAD
  }
  void h(int x, int y) {
    d.h(x, y);
  }
private:
  B b;
  D d;
};
\end{cppcode}
Вот так уже лучше, но строчка~7 -- это тоже нарушение уровня доступа.
Теперь уже объект класса \verb"B" не предоставляет нужные методы для работы с ним, а потому надо метод \verb"g" пробросить в интерфейс класса \verb"B", чтоб написать так
\begin{cppcode}
int g() const {
  return b.g();
}
\end{cppcode}
После чего использование класса \verb"A" становится простым и понятным
\begin{cppcode}
A a;
int x = a.f();
int y = a.g();
a.h(x, y);
\end{cppcode}
Обратите внимание, что есть паттерн Builder (разобранный в разделе~\ref{section::Builder}), который наоборот использует вызовы вида
\begin{cppcode}
Builder b;
b.input(3).addLinear(5).add(Sigmoid).addLinear(2).add(ReLu);
Network n = b.extract();
\end{cppcode}
Такой подход вызова команд друг за другом называется Chaining.
Его использование нисколько не противоречит правилу про уровень доступа, потому что вы просто хотите на одном объекте вызвать много методов друг за другом.
Это просто другой стиль использования плюсового синтаксиса.

\subsection{Не сваливать все в кучу}
\label{section::SeparateStuff}
% TO DO

\subsection{Не своя работа}
\label{section::WrongWork}
% TO DO

\subsection{Плохо продуманные интерфейсы}
\label{section::BadInterfaces}

Важно, чтобы объекты и методы, которые вы пишете, могли удобно друг с другом коммуницировать.
В частности если один метод возвращает данные в каком-то формате, то удобно и другому методы принимать их в таком формате.
Если это не возможно, то значит должен быть промежуточный метод, который делает трансформацию данных.
Или же если один класс пользуется другим для своих целей, то хорошо бы, чтобы в интерфейсе этого другого класса был весь тот функционал, который необходим для использования.
Либо нужный функционал должен быть написан поверх предоставляемого.

\paragraph{Передача данных}

Предположим у вас есть две функции
\begin{cppcode}
struct Vector2D {
  double x;
  double y;
};

Vector2D produce();
void consume(double x, double y);
\end{cppcode}
Обе функции работают с двумерными векторами, но одна функция возвращает вектор как структуру, а другая принимает координаты вектора по-отдельности.
Что придется делать, чтобы передавать данные из одной функции в другую?
Конвертировать
\begin{cppcode}
Vector2D vec = produce();
consume(vec.x, vec.y);
\end{cppcode}
Либо симметричная ситуация
\begin{cppcode}
double produce_x();
double produce_y();
void consume(Vector2D);
\end{cppcode}
Тогда придется писать
\begin{cppcode}
consume(Vector2D{produce_x(), produce_y()});
\end{cppcode}
Проблема в этом случае в том, что один метод выдает данные не в том формате, в котором их ожидает другой метод.
Если вы разрабатывали эти интерфейсы, то вы просто плохо их продумали.
Вы знали, какие у вас есть функции и какие данные надо передавать между ними.
И раз вы их передаете в несовместимом формате, то это вы сами себе усложнили задачу.
В идеале должно быть
\begin{cppcode}
Vector2D produce();
void consume(Vector2D);

Vector2D vec = produce();
consume(vec);
\end{cppcode}
Если же интерфейсы этих функций вы поменять не можете, то вы на самом деле попали в ситуацию проблемы, которая будет адресована в разделе~\ref{section::NotEnoughHats}.
Попросту говоря, вам надо создать новую функцию, с нужным интерфейсом, которая будет внутри себя делать конвертацию и потом вызывать уже функцию с неудобным интерфейсом.
Такая функция называется адаптером.
Про адаптеры и фасады подробнее написано в разделе~\ref{section::AdaptorsFacades}.

\paragraph{Интерфейс класса}

Мой любимый пример -- пример из STL, а именно имплементация \verb"std::vector".
А точнее метод \verb"size".
Кто писал такой код
\begin{cppcode}
std::vector<int> vec = { ... };
for (int i = 0; i < vec.size(); ++i)
  vec[i] = ...;
\end{cppcode}
тот знает мою боль.
Дело в том, что в цикле \verb"for" происходит сравнение знакового \verb"i" и без знакового \verb"vec.size()".
Так лучше не делать, можно легко добиться UB смешивая знаковые и без знаковые типы.
Поэтому в C++20 даже добавили \verb"ssize", которая возвращает знаковое значение для размера вектора.
Я считаю это успех.

\subsection{Люди носят не достаточное количество шляп}
\label{section::NotEnoughHats}
% TO DO

Я думаю, что стоит начать с пояснения названия раздела.
Это название я взял из доклада Tony Van Eerd <<SOLID, Revisited>>.
Его можно было сформулировать так: <<люди используют недостаточное количество функций>>.
Это значит, что какую-то работу, которую можно было погрузить в отдельную функцию, делают на месте руками, что усложняет код и работу с ним.
% TO DO

%\subsubsection{Комментарии}
% TO DO

%\subsection{Не обеспечена семантика класса}
% TO DO
