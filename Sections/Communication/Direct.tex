\ProvidesFile{Direct.tex}[Прямое взаимодействие]


\subsection{Прямое взаимодействие объектов}

Если два объекта классов \verb"B" и \verb"C" хотят коммуницировать и передавать друг другу данные, то самый простой способ организовать такую связь -- хранить указатели друг на друга
\[
\xymatrix@R=15pt@C=15pt{
	{B}
	{
	\save
   [].[rd]*[F-:<3pt>]\frm{}
   \restore
	}
	&{}&{}&{C}
	&{\phantom{C}}\\
	{}&{ptr}\ar@(r, l)[rru]+(-4,0)&{}&{ptr}
	{
	\save
   [].[ru]*[F-:<3pt>]\frm{}
   \restore
	}
	\ar@(l,r)[ull]+(4,0)&{}\\
}
\]
Однако у такого решения есть серьезные проблемы как идейные так и технические.

\paragraph{Идейные проблемы}
\begin{enumerate}
\item В таком подходе \verb"B" зависит от имплементации \verb"C".
Объект \verb"B" должен знать названия методов из объекта \verb"C" и дергать их по назначению.
Любые изменения в \verb"C" могут повлечь изменения в \verb"B" и наоборот.
По сути в этом случае мы распилили одну структуру данных на два класса, которые должны поддерживать общий инвариант.

\item В таком подходе \verb"B" должен знать об объекте \verb"C".
Мы должны инклудить зависимости объекта \verb"C" в имплементацию объекта \verb"B" и наоборот.
Это может сильно ломать и нарушать логику разделения программы на части.
\end{enumerate}

\paragraph{Технические проблемы}
\begin{enumerate}
\item Проблема указателя в том, что он может быть нулевым.
Это состояние надо не забыть.

\item Объект мог переехать по другому адресу.
Действительно, обычные указатели не дают никаких гарантий, есть ли по данному адресу нужный нам объект или нет.
Например указатель может ссылаться на мертвый объект.

\item Ну и самое классное -- указатели в объектах \verb"B" и \verb"C" могут не ссылаться друг на друга.
То есть указатели могут быть не в корректном рассинхронизированном состоянии.
\end{enumerate}
