\ProvidesFile{Why.tex}[Зачем]


\subsection{Зачем?}

\paragraph{Стандартный код}

Давайте начнем с двух примеров того, как принято писать код
\begin{center}
\begin{tabular}{cc}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]



int main() {
  Data1 input = read();
  Data2 result = apply_algorithm(input);
  print(result);
  return 0;
}
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{9cm}
\begin{cppcode}[numbers = none]
struct A {
  void process(const char* command) {
    parse(command); // set arg
    Data1 data = read(arg.file1);
    Data2 result = apply(data, arg.algorithm);
    write(result, arg.file2);
  }
  Command arg;
};
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}
Слева пример стандартного консольного приложения.
Оно состоит по сути из трех строчек
\begin{enumerate}
\item Считать данные и положить в \verb"input".

\item Применить к \verb"input" алгоритм и получить \verb"result".

\item Вывести \verb"result" на печать.
\end{enumerate}
Вся работа на каждом шаге делегируется трем различным функциям.
Я хочу обратить внимание на то, кто занимается передачей данных между тремя функциями.
За передачу данных и временные переменные отвечает сама функция \verb"main".
В примере справа происходит более или менее то же самое.
У класса \verb"A" есть метод \verb"process", который вызывает такие же три стадии:
\begin{enumerate}
\item Считать данные и положить в \verb"data".

\item Применить к \verb"data" алгоритм и получить \verb"result".

\item Вывести \verb"result" на печать.
\end{enumerate}
Отличие лишь в том, что теперь у нас есть состояние, хранящееся внутри класса \verb"A", которое может на что-то неявно повлиять.
И в этом случае за передачу данных между методами отвечает по сути класс \verb"A".
Если быть точнее, то надо сказать метод \verb"process".

Давайте отметим, что это стандартный способ писать код.
Мы так привыкли писать функции и классы.
Функции внутри себя передают данные между отдельными функциями.
Классы сами передают свои внутренние данные между разными методами.
В этом случае передача данных осуществляется внешним объектом, который видит всех участников и может осуществить передачу.


\paragraph{Важный пример}

Чтобы понять зачем нам нужно что-то еще, стоит рассмотреть один важный пример.
Давайте представим, что мы хотим логически иметь pipeline из объектов.
Чтобы объекты могли передавать друг другу данные вдоль пайплайна.
Изобразим схематично такой pipeline:
\[
\xymatrix@R=15pt@C=15pt{
  {}&{c}&{}\\
  {b}\ar[ru]\ar[r]&{d}\ar[r]&{f}\\
}
\]
Здесь $b$, $c$, $d$ и $f$ -- это объекты каких-то классов, а стрелки означают поток данных.
Давайте попробуем реализовать это в рамках классического подхода.
Чтобы мы могли передавать данные между указанными четырьмя объектами, нужно их всех поместить либо внутрь функции, либо внутрь класса.
Давайте поместим внутрь класса.
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
class A {
public:
  void process(int x) {
    b.process(x);
    signal_BC();
    signal_BD();
    signal_DF();
  }

private:
  void signal_BC() {
    int x = b.get();
    c.process(x);
  }
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
  void signal_BD() {
    int x = b.get();
    d.process(x);
  }
  void signal_DF() {
    int x = d.get();
    f.process(x);
  }

  B b;
  C c;
  D d;
  F f;
};
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}
Мы положили в класс \verb"A" все четыре переменные.
Для каждой стрелки мы завели соответствующую функцию, которая берет данное из вершины source и отдает эти данные на обработку в вершину target.
И есть еще общая функция \verb"process", которая проталкивает данные сквозь весь пайплайн.

Вроде бы все хорошо и работает как надо.
Но давайте попробуем внести изменение и добавить еще одну вершину $s$ следующим образом:
\[
\xymatrix@R=15pt@C=15pt{
  {}&{}&{c}&{}\\
  {s}\ar[r]&{b}\ar[ru]\ar[r]&{d}\ar[r]&{f}\\
}
\]
Теперь нужно внести следующие изменения
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
class A {
public:
  void process_B(int x) {
    b.process(x);
    signal_BC();
    signal_BD();
    signal_DF();
  }
  
  void process_S(int x) {
    s.process(x);
    signal_SB();
    signal_BC();
    signal_BD();
    signal_DF();
  }
private:
  void signal_SB() {
    int x = s.get();
    b.process(x);
  }
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
  void signal_BC() {
    int x = b.get();
    b.process(x);
  }
  
  void signal_BD() {
    int x = b.get();
    d.process(x);
  }
  
  void signal_DF() {
    int x = d.get();
    f.process(x);
  }

  S s;
  B b;
  C c;
  D d;
  F f;
};
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}
Давайте отметим сразу несколько вещей:
\begin{enumerate}
\item Добавить новую переменную \verb"s" и написать метод \verb"signal_SB" мы вынуждены.
Так как это новая информация для пайплайна.

\item Метод \verb"process_S" подозрительно дублирует методы из \verb"process_B", что плохо.
Можно переиспользовать \verb"process_B", но тогда мы не будем использовать \verb"signal_SB".
А это означает, что мы будем имплементацию \verb"signal_SB" вставлять внутрь \verb"process_S".
Это еще хуже, тогда у нас действия отвечающие за ребро $s\to b$ будут размазаны по коду и не будет единого источника правды.
\end{enumerate}
То что мы проделали все еще не страшно.
Давайте попробуем удалить ребро $b \to d$ на диаграмме
\[
\xymatrix@R=15pt@C=15pt{
  {}&{}&{c}&{}\\
  {s}\ar[r]&{b}\ar[ru]\ar@{..>}[r]&{d}\ar[r]&{f}\\
}
\]
\begin{center}
\begin{tabular}{ll}
{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
class A {
public:
  void process_B(int x) {
    b.process(x);
    signal_BC();
    // signal_BD();
    signal_DF();
  }
  void process_S(int x) {
    s.process(x);
    signal_SB();
    signal_BC();
    // signal_BD();
    signal_DF();
  }
\end{cppcode}
\end{minipage}
}&{
\begin{minipage}[\baselineskip]{8cm}
\begin{cppcode}[numbers = none]
private:
  void signal_SB() {
  }
  void signal_BC() {
  }
  void signal_BD() {
  }
  void signal_DF() {
  }
  S s;
  B b;
  C c;
  D d;
  F f;
};
\end{cppcode}
\end{minipage}
}
\end{tabular}
\end{center}
И вот тут видна еще одна проблема -- наши действия не локальны.
Код соответствующий ребру находится в двух функциях.
А потому удаление ребра $b \to d$ заставляет нам вносить изменения в несколько разных функций.
Это тоже очень плохо.

\paragraph{Что мы хотим}

Мы бы хотели строить системы по схемам из кусочков как на схеме ниже.
\[
\xymatrix@R=15pt@C=15pt{
  {}&{c}&{}\\
  {b}\ar[ru]\ar[r]&{d}\ar[r]&{f}\\
}
\]
При этом мы хотим, чтобы логическая структура диаграммы максимально точно соответствовала коду.
Это значит, что простейшая процедура удаления одного ребра должна быть локальной и выглядеть как удаление одной и только одной строчки вне зависимости от размеров и сложности диаграммы.

\paragraph{Проблемы с обычным подходом:}

\begin{enumerate}
\item Код основан на соглашениях.
То есть логически у нас конечно пайплайн, но ментальная модель не соответствует модели в коде.
Как пример логически единственное ребро $b\to d$ в коде разбросано сразу в нескольких местах.
И логически простая операция удаление ребра или добавление ребра влечет изменение сразу нескольких мест в коде.

\item Статические соединения.
Это значит, что все соединения известны на момент компиляции.
Это не такая страшная проблема в таком подходе, потому что можно было бы заводить указатели на функции и работать с ними.

\item Подобъекты не могут общаться.
Если вдруг внутри \verb"b" есть объект, который бы вы хотели соединить с кем-то, то вам придется пробрасывать его соединение сквозь интерфейс \verb"b".
Либо вываливать наружу кишки \verb"b" и отказываться от инкапсюляции.

\item Нельзя передавать информацию в середине методов.
Вот это самая страшная проблема из всех.
Так как вы работаете с объектом \verb"b" снаружи, вы не можете оповестить кого-то в середине процесса.
Потому что вам не доступны внутренности \verb"b" из-за инкапсюляции.
А подобное может понадобится.
Например если вы визуализируете структуру данных и хотите сделать анимацию на вставку элемента.
То хорошо бы посылать сигнал не в начале и конце операции, а в промежуточные моменты, чтобы отобразить промежуточное состояние структуры.

\item Масштабируемость.
На примерах выше, мы увидели как много действий приходится делать при малейших изменениях в системе.
Причем, чем больше узлов и соединений, чем больше разных путей, через которые могут пройти сигналы, тем сложнее вносить любые изменения.
В целом это связано с тем, что функция -- это целый путь в пайплайне, а не ребро.

\item Повторяемость кода.
Эту проблему мы тоже наблюдали выше.
Именно она влечет проблемы с масштабируемостью.
Но важнее, что у вас теряется единый источник правды.
В этом случае одно и то же действие может быть продублировано в нескольких местах.
Что практически не возможно поддерживать.
\end{enumerate}
Если вам нужны подобные пайплайны, то по-хорошему вам нужны примитивы для их построения.
Ниже я собираюсь обсудить один из подобных примитивов -- observer pattern.
