\ProvidesFile{CandCpp.tex}[Си и C++]


\subsection{Си и C++}

Дизайн языка C++ изначально планировал, что любая программа на Си должна компилироваться компилятором C++.%
\footnote{И это почти работает.
Точнее есть одно ключевое слово из Си, которое не поддерживается компилятором C++ -- это слово \texttt{restrict}.
Давайте я не буду ничего про него говорить.}
Однако, если вы когда-нибудь настраивали сборку проектов, то заметили, что вы всегда указываете два компилятора -- один для Си, другой для C++.
Возникает вопрос: а зачем?
Если C++ компилятор может компилировать все.
И тут мы приходим в суровый мир продуманного Си, как низкоуровнего языка, и прекрасный мир стихийного развития C++ поверх Си.

\subsubsection{ABI совместимость и Name Mangling}
% ABI и для чего не предназначен С++

Одна из основных идей за двухступенчатой системой компиляции -- модульная структура приложений на уровне бинарного кода.
А именно, мы будем хранить приложение не в виде одного бинарного файла, в виде нескольких бинарных файлов.
И если нам надо обновить какую-то компоненту, то мы можем перекомпилировать только нужный бинарник и подменить его.
Но для такого подхода важно, чтобы на уровне бинарного кода старая и новая имплементация были совместимы.
Такая совместимость в частности предполагает одни и те же имена функций.
И потому, если у вас на уровне бинарного кода есть Name Mangling (смотри раздел~\ref{section::DefectCpp}), который не стандартизирован, то вы просто не можете использовать язык C++ в рамках такой парадигмы.

Давайте вернемся к вопросу зачем нам два компилятора для Си и C++ кода.
Если вы имеете код на Си, то он конечно скомпилируется обоими компиляторами.
Но бинарный файл будет разные.
В случае компилятора Си имена методов будут такими же как их видит программист, а в случае C++ имена будут подвергнуты Name Mangling-у.
Подобная проблема в частности не позволяет слинковаться с методами скомпилированными с помощью Си компилятора.
Действительно
\begin{cppcode}
// c-file 
void f(int) {
...
}
// c++ file
void f(int);

int main() {
  f(5); // linking error
  return 0;
}
\end{cppcode}
Если мы скомпилировали первый файл с помощью Си компилятора на на уровне бинарника имя функции будет \verb"f".
А при компиляции второго файла с помощью C++ компилятора имя объявленной в строчке 6 и вызываемой в строчке 9 функции будет совсем другой, условно пусть будет \verb"_Zfint".
А тогда линковщик не найдет нужную функцию.
Для решения этой проблемы есть специальное ключевое слово: % extern "c"
\begin{cppcode}
// c-file 
void f(int) {
...
}
// c++ file
extern "C" void f(int);

int main() {
  f(5); // OK
  return 0;
}
\end{cppcode}
Теперь для функции \verb"f" в строчке 6 отключен Name Mangling и линковщик сможет понять какое у нее имя в бинарнике после Си компилятора.

\subsubsection{ABI совместимость и отсутствие стандартизации}

Если вы думали, что Name Mangling -- это единственная причина для отсутствия ABI совместимости, то у меня для вас плохие новости.
На этом список не заканчивается.
Если вы хотите ABI совместимость, то вы автоматически не можете использовать STL, даже для одно и того же компилятора, потому что имплементация STL не фиксирована на уровне бинарников.
И есть известная история со строками в STL для gcc.
Изначальная имплементация строк имела copy-on-write оптимизацию, которую потом насильно запретили.
И потому теперь есть две несовместимые на уровне бинарника имплементации STL для gcc, между которыми нужно переключаться специальным макросом.
Но и это не самая большая проблема.
Даже внутри самого языка ничего не стандартизировано.
Вот перечень проблем:
\begin{enumerate}
\item Exception (смотри раздел~\ref{section::Dangerous}).
Данный механизм языка имплементирован по разному на разных компиляторах.
При этом на msvc есть еще возможность переключаться между разными имплементациями исключений по флагу компилятора.

\item RTTI (смотри раздел~\ref{section::Dangerous}).
Имплементация этой фичи тоже не стандартизирована и на разных компиляторах имплементирована по разному.

\item Наследование с виртуальными методами (смотри раздел~\ref{section::Dangerous}).
Имплементация так называемых виртуальных методов также не стандартизирована.
Где и как располагается таблица виртуальных функций, какого она размера и прочие и прочие детали не стандартизированы.
Да и вообще, что должна быть использована именно таблица для виртуальных методов никак в стандарте не указано (хотя все имплементации используют только такой подход).
Тем не менее, конкретное расположение в памяти объектов такого класса может отличаться для разных компиляторов.

\item C-run-time.
Если вы изучали АКОС,%
\footnote{Архитектура компьютера и операционной системы}
то знаете, что точка входа в программу -- функция start, а не main.
Дело в том, что для работы программы на C++ нужны некоторые возможности, которые гарантируются языком, но не операционной системой.
Например использование операторов \verb"new" и \verb"delete".
Эти операции зовут библиотечный код относящийся к так называемому C-run-time-у.
И конечно же его имплементация не стандартизирована.
И у разных компиляторов эти методы работают по-разному и не совместимы.
\end{enumerate}
Все указанные выше проблемы практически уничтожают возможность распространения кода для C++ проектов на уровне бинарников.
Потому подключение сторонних библиотек почти всегда означает сборку библиотеки из исходников для своего проекта, либо использовать пакетный менеджер и надеяться, что ваша конфигурация найдется и не надо будет собирать все с нуля.
Под Windows из-за распространенности компилятора Visual Studio (msvc) вопросы со стандартизации на уровне бинарников в некоторой степени решаются сильно проще, но все же привязаны к версии компилятора.
