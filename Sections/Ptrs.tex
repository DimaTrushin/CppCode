\ProvidesFile{Ptrs.tex}[Указатели]


\section{Указатели}
\label{section::Ptrs}


В C++ существует два владеющих указателя:
\begin{itemize}
\item \texttt{unique\_ptr} для уникального владения объектом, а потому поддерживается только перемещение.

\item \texttt{shared\_ptr} для совместного владения объектом.
Данный вид указателя является очень опасным механизмом языка, потому что он ломает сразу несколько принципов и им важно научиться пользоваться правильно.
\end{itemize}
При этом в связке с ними идут еще два не владеющих указателя:
\begin{itemize}
\item Сырой указатель \texttt{T*}, который используется для указания на данные, когда гарантируется, что данные будут живы.
Такой указатель обычно используется в паре с \texttt{unique\_ptr}.

\item \texttt{weak\_ptr}, не владеющий указатель, который знает, что он ссылается на данные лежащие в \texttt{shared\_ptr}.
Такой указатель используется в паре с \texttt{shared\_ptr}.
\end{itemize}

Все указатели кроме сырого принято называть <<умными>> указателями.
Однако, более правильно делить их на владеющие и не владеющие.
Кроме владеющих указателей есть еще один вид указателей, который я буду обсуждать (и которые хорошо было бы называть умными) -- это <<отслеживающие>> указатели.
Такие указатели позволяют отслеживать адрес объекта и знать жив ли еще объект.
Такие указатели можно использовать в мультиагентной среде для посылки сообщений между агентами, где вы можете не знать, будет ли жив адресат к моменту, когда письмо дойдет.
Примером такого указателя является \texttt{QPointer} в экосистеме Qt.
Ниже в разделе~\ref{section::TrackingPtr} я расскажу о таких указателях более детально.

\subsection{Владеющий указатель \texttt{unique\_ptr}}
\label{section::UniquePtr}

Основное время вы будете использовать переменные нужного класса для хранения данных и нет необходимости пользоваться указателями.
Однако, есть ситуации, когда бывает осмысленно поместить объект в памяти на кучу.
Давайте поговорим об этих ситуация:
\begin{enumerate}
\item Вам необходимо сделать объект адресуемым, то есть чтобы его адрес был постоянен в течение жизни программы, чтобы на него можно было ссылаться (предполагается, что вы как-то организуете гарантию, что объект будет жив при этом).
В этом случае проще всего положить объект в \texttt{unique\_ptr}.
При таком подходе вы не теряете value semantics и можете спокойно пользоваться контейнерами вроде \texttt{std::vector} для хранения подобного объекта.

\item Хрупкие объекты.
Мы уже обсуждали их в разделе~\ref{section::fragile}.
Напомню, что если внутри объекта у вас есть указатели на разные элементы объекта, то очень проблематично писать напрямую копирование и перемещение объекта, вам придется все данные указатели настраивать после снятия копии или перемещения.
И если копирование просто так не решается, то вот перемещение можно сделать бесплатным, положив объект в \texttt{unique\_ptr}.

\item Борьба с тяжелыми объектами.
Если объект класса имеет легкую локальную часть и для него move операция дешевая, то можно легко перемещать данные между методами через rvalue reference.
Однако, если же данные в объекте все живет локально, как например в \texttt{std::array}, то нет разницы между move и copy.
С другой стороны, перемещать по ссылке данные не всегда возможно.
Например, если вызов метода не блокирующий и будет использовать данные позже или же при передачи данных между потоками.
В этом случае для облегчения данных их можно положить в \texttt{unique\_ptr}.
Если вы хотите поддержать копирование, то вам придется написать соответствующую обертку.

\item Освобождение стека.
Если вы пишете приложение, то точка входа в программу может выглядеть так
\begin{cppcode}
int main() {
  try {
    Application app;
    app.run();
  } catch (...) {
    react();
  }
}
\end{cppcode}
В операционной системе функция \texttt{main} запускается на своем thread-е со своим стеком.
И объект \texttt{Application} создается на стеке.
Если он слишком тяжелый и содержит все свои данные локально, то может съесть слишком много места на стеке.
Вы скорее всего этого не почувствуете, пока не сработает какая-нибудь рекурсия, которая съест стек.
Так же надо иметь в виду, что размер стека на разных операционных системах разный и обычно на Windows стек больше, чем на Linux по умолчанию.
В таком случае принято \texttt{Application} заворачивать в \texttt{unique\_ptr} как это рассказывалось в разделе~\ref{section::fragile} про хрупкие объекты.
Или как в разделе~\ref{section::Pimpl} про Pimpl.
\end{enumerate}

\subsection{Владеющий указатель \texttt{shared\_ptr}}
\label{section::SharedPtr}

Существует всего три и только три случая использования \texttt{shared\_ptr}:
\begin{enumerate}
\item Использование \texttt{shared\_ptr<const T>}.
В этом случае это дешевый способ сделать тяжелые данные легко копируемыми за счет невозможности их модифицировать.

\item Использование \texttt{shared\_ptr<T>}, где \texttt{T} не константный тип.
Это более опасный объект и у него есть два случая применения:
\begin{enumerate}
\item Имплементация механизмов межпотокового взаимодействия, например \texttt{future/promise}.
В этом случае оба thread-а должны владеть областью памяти для возможности коммуникации.
При этом никто из thread-ов не может зарание знать, кто из них умрет раньше, потому никто не может гарантировать, кто должен последним отпустить ресурсы.
Причина использования \texttt{shared\_ptr} в этом случае в том, что без него просто не возможно имплементировать подобное взаимодействие.

\item Персистентные структуры данных или структуры, которые должны шарить общие ресурсы для обеспечения более эффективного механизма копирования.
В этом случае все копии одной структуры имеют внутри большое количество общих данных, которые они копируют лишь при необходимости.
И владение этим ресурсом осуществляется с помощью \texttt{shared\_ptr}.
Самый простой пример -- copy-on-write подход.
В рамках этого подхода внутри класса хранится \texttt{shared\_ptr} на данные и только при необходимости изменить данные с них снимается копия (при наличии нескольких владельцев).
Мы обсудим один из примеров использования \texttt{shared\_ptr}, когда классы имеют общий инвариант, ниже в разделе~\ref{section::TrackingPtr}.
\end{enumerate}
\end{enumerate}

\paragraph{\texttt{shared\_ptr<const T>}}

Обратите внимание, что когда вы используете \texttt{shared\_ptr} на константный объект, то это гарантированно value semantics.
Потому это безопасное использование механизма языка.
Однако, не стоит пользоваться сырым \texttt{shared\_ptr} в коде, заверните указатель в класс или шаблон например так
\begin{cppcode}
template<class T>
class ConstValue {
public:
  template<class... Args>
  ConstValue(Args&&... args)
   : data_(std::make_shared<const T>(std::forward<Args>(args)...)) {}
  ConstValue(const ConstValue&) = default;
  ConstValue(ConstValue&&) noexcept = delete;
  ConstValue& operator=(const ConstValue&) = default;
  ConstValue& operator=(ConstValue&&) noexcept = delete;
  ~ConstValue() = default;
  
  const T* operator->() const {
    return data_.get();
  }
private:
  std::shared_ptr<const T> data_;
};
\end{cppcode}
Тут надо сделать несколько замечаний.
Во-первых, зачем производится такое заворачивание.
Дело в том, что вы хотите снаружи иметь поведение такое же как и у вашего класса типа \texttt{T} и не иметь как минимум лишних методов в интерфейсе объекта.
Если использовать \texttt{shared\_ptr} напрямую, то в интерфейсе у вас будет много методов специфических для указателя, которых не должно быть в классе \texttt{T}.
Во-вторых, если вдруг вам потом понадобится поменять что-то в коде или добавить какое-то специальное поведение, то проще его добавить в один класс, а не мучиться переписывать все места использования \texttt{shared\_ptr} напрямую.
В-третьих, обратите внимание на удаление методов мува.
Это сделано для того, чтобы ваш объект не мог находиться в пустом состоянии, в этом случае \texttt{operator->} никогда не вернет \texttt{nullptr} и потому безопасен в использовании.
Можно пойти другим путем и просто сделать move равносильным копированию, что тоже обеспечит нужное поведение, при котором оператор \texttt{operator->} никогда не падает, и это даже будет работать лучше.

\paragraph{\texttt{shared\_ptr<T>}}

Если же вы используете \texttt{shared\_ptr} на неконстантный объект, то это всегда имплементация какого-то паттерна или структуры, а потому его можно использовать напрямую внутри этой структуры, так как это обычно деталь имплементации.
Тем не менее, даже в этом случае имеет смысл заводить псевдоним, чтобы можно было потом легко подменять разные версии \texttt{shared\_ptr} (если вдруг вы захотите использовать не STL версию).

В разделе~\ref{section::Dangerous} я уже обсуждал проблемы с \texttt{shared\_ptr} на неконстантный объект.
Давайте я резюмирую эти соображения тут еще раз
\begin{enumerate}
\item Нарушение локальности.
У вас могут быть сколь далекие друг от друга переменные \texttt{shared\_ptr} ссылающиеся на одни и те же данные.
Эти переменные могут даже быть в разных единицах трансляции, в разных бинарниках, в разных проектах.
И любые изменения одной влекут непредсказуемое поведение в совершенно другой части кодовой базы.
Это означает, что эти разбросанные по кодовой базе данные имеют общий инвариант, который не скрыт в класс.
А потому пользователь этих переменных обязан всегда при любом использовании следить негласно за выполнением нужных инвариантов, что разумеется не реалистично (вы можете банально не знать о таких инвариантах).
Разбросанные в коде данные с общим инвариантом называются Incidental Data Structures.
Их надо всегда избегать и заворачивать в классы.

\item Нарушение value semantics.
Тут я не буду особенно повторяться, но reference semantics она контринтуитивная и с ней очень тяжело работать.
С другой стороны value semantics is safe by default.
\end{enumerate}
